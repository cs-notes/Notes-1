<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>CS 466 F13</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title">CS 466<br />F13</h1>
</div>
<h1 id="cha:introduction">Introduction</h1>
<p>In this course, we want to solve algorithmic problems, and compounding general knowledge with developments of the last 30 years. Though these notes are grouped by lecture, this course can be split into three sections:</p>
<ol>
<li><p>Algorithmic Design</p>
<ul>
<li><p>Assumed knowledge of greedy, divide &amp; conquer, and dynamic programming techniques</p></li>
<li><p>Introduction to randomization, approximation, and online algorithmic techniques</p></li>
</ul></li>
<li><p>Algorithmic Analysis</p>
<ul>
<li><p>Assumed knowledge of big <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O" alt="O" title="O" />, worst case asymptotic analysis techniques</p></li>
<li><p>Introduction to amortized analysis, probabilistic analysis, and approximation factors methods</p></li>
</ul></li>
<li><p>Lower Bounds</p>
<ul>
<li><p>Understanding of <span><span style="font-variant: small-caps;">NP-complete</span></span>-ness is assumed</p></li>
<li><p>Hardness of approximation is introduced</p></li>
</ul></li>
</ol>
<p>The class website is <a href="https://www.student.cs.uwaterloo.ca/~cs466/">https://www.student.cs.uwaterloo.ca/~cs466/</a>.</p>
<h2 id="sec:tsp">TSP</h2>
<h3 id="sub:problem_statement">Problem Statement</h3>
<p>Given a graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G%20%3D%20%28V%2C%20E%29" alt="G = (V, E)" title="G = (V, E)" /> with weights on edges <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=w%20%3A%20E%20%5Cto%20R" alt="w : E \to R" title="w : E \to R" />, find a <a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>, which is a Hamiltonian Tour<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" /> that visits each vertex exactly once and has minimum weight: <br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Csum_%7Be%20%5Cin%20C%7D%20w%28e%29" alt="\sum_{e \in C} w(e)" title="\sum_{e \in C} w(e)" /><br /></p>
<p>Since we can add infinite-weight edges to any non-complete graph, we assume that we have a complete graph<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p><span style="font-variant: small-caps;">TSP</span> is a known <span><span style="font-variant: small-caps;">NP-complete</span></span>problem.</p>
<h3 id="sub:npcomplete"><span><span style="font-variant: small-caps;">NP-complete</span></span></h3>
<p>To show a problem <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R" alt="R" title="R" /> is <span><span style="font-variant: small-caps;">NP-complete</span></span>, we need to show that both:</p>
<ol>
<li><p>Prove <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R" alt="R" title="R" /> is in <span><span style="font-variant: small-caps;">NP</span></span>.</p></li>
<li><p>Give a reduction (denoted “<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle_p" alt="\le_p" title="\le_p" />”) from a known <span><span style="font-variant: small-caps;">NP-complete</span></span>problem to an instance of the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R" alt="R" title="R" /> problem.</p></li>
</ol>
<p>Thus to prove that <span style="font-variant: small-caps;">TSP</span> is <span><span style="font-variant: small-caps;">NP-complete</span></span>, we need to show both:</p>
<ul>
<li><p><span style="font-variant: small-caps;">TSP</span> is in <span><span style="font-variant: small-caps;">NP</span></span></p></li>
<li><p>Hamiltonian Cycle <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle_p" alt="\le_p" title="\le_p" /> <span style="font-variant: small-caps;">TSP</span>.</p></li>
</ul>
<p>Assuming that Hamiltonian Cycle in our reduction is a known <span><span style="font-variant: small-caps;">NP-complete</span></span>problem, we now know that <span style="font-variant: small-caps;">TSP</span> is <span><span style="font-variant: small-caps;">NP-complete</span></span>too.</p>
<p>Unless <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />, we need to choose two of these three options:</p>
<ul>
<li><p>A <em>speedy</em> algorithm</p></li>
<li><p>Solve the <em>problem precisely</em></p></li>
<li><p>Solve a <em>hard problem</em></p></li>
</ul>
<p><span><span style="font-variant: small-caps;">NP-complete</span></span>problems are hard, so we must choose between <em>precision</em> and <em>speed</em> when solving them.</p>
<h2 id="sec:metric_tsp">Metric <span style="font-variant: small-caps;">TSP</span></h2>
<p>We define Metric <span style="font-variant: small-caps;">TSP</span> as a weaker variant of <span style="font-variant: small-caps;">TSP</span> where the distance between two vertexes is the same in either order, and distances always follows the triangle inequality.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20d%28u%2C%20v%29%20%26%3D%20%20%20d%28v%2C%20u%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20d%28u%2C%20v%29%20%26%5Cle%20d%28u%2C%20%5Cbeta%29%20%2B%20d%28%5Cbeta%2C%20v%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    d(u, v) &amp;=   d(v, u) \\
                    d(u, v) &amp;\le d(u, \beta) + d(\beta, v)
                \end{aligned}" title="\begin{aligned}
                    d(u, v) &amp;=   d(v, u) \\
                    d(u, v) &amp;\le d(u, \beta) + d(\beta, v)
                \end{aligned}" /><br /></p>
<p>There exists a fast approximation algorithm that exists for this problem:</p>
<ul>
<li><p>Find minimum-spanning tree (see Chapter [cha:minimum<sub>s</sub>panning<sub>t</sub>rees] for more information) of the graph using <a href="https://en.wikipedia.org/wiki/Kruskal&#39;s_algorithm">Kruskal’s Algorithm</a> (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%5Clog%20n%29" alt="O(m \log n)" title="O(m \log n)" />).</p></li>
<li><p>Take a tour walking around the tree, taking shortcuts to avoid re-visiting vertexes</p></li>
<li><p>The distance added by the shortcuts is less than or equal to twice the distance of remaining in the tree.</p></li>
</ul>
<p>Here’s a quick proof to this lemma: In a given graph, call <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cell" alt="\ell" title="\ell" /> the length of the tour of our algorithm, and call <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cell_%7BTSP%7D" alt="\ell_{TSP}" title="\ell_{TSP}" /> the distance traveled in the minimal <span style="font-variant: small-caps;">TSP</span> tour.</p>
<p>We want to prove that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cell%20%5Cle%202%20%5Cell_%7BTSP%7D" alt="\ell \le 2 \ell_{TSP}" title="\ell \le 2 \ell_{TSP}" />, so that this is a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2" alt="2" title="2" />-approximation (For more information, see Chapter [cha:approximation<sub>a</sub>lgorithms]).</p>
<p>We know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cell%20%5Cle%202%20%5Cell_%7BMST%7D%20%5Cle%202%20%5Cell_%7BTSP%7D" alt="\ell \le 2 \ell_{MST} \le 2 \ell_{TSP}" title="\ell \le 2 \ell_{MST} \le 2 \ell_{TSP}" /> since deleting one edge of a minimum <span style="font-variant: small-caps;">TSP</span> tour gives us a spanning tree.</p>
<p><strong>Sidenote:</strong> There exists a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1.5" alt="1.5" title="1.5" /> approximation, but there were no specifics given in class. The apparently, the idea is to use a matching algorithm.</p>
<h3 id="sub:implementation">Implementation</h3>
<ul>
<li><p>We must find a minimum spanning tree, which takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%5Clog%20n%29" alt="O(m\log n)" title="O(m\log n)" /> time using Prim and Kruskal’s Algorithm.</p>
<dl>
<dt><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /></dt>
<dd><p>is the number of edges.</p>
</dd>
<dt><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /></dt>
<dd><p>is the number of vertexes.</p>
</dd>
</dl></li>
<li><p>We will see improved heaps in this class that allow us to take the time down to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%2B%20n%20%5Clog%20n%29" alt="O(m + n \log n)" title="O(m + n \log n)" /></p></li>
</ul>
<p>This method doesn’t work for General <span style="font-variant: small-caps;">TSP</span>, since if there exists a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-approximation, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}={\textsc{NP}\xspace}" title="{\textsc{P}\xspace}={\textsc{NP}\xspace}" /><a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</p>
<h2 id="sec:types_of_tsp">Types of <span style="font-variant: small-caps;">TSP</span></h2>
<p>In general, the ordering is from hardest to easiest:</p>
<p>General <span style="font-variant: small-caps;">TSP</span> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge" alt="\ge" title="\ge" /> Metric <span style="font-variant: small-caps;">TSP</span> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge" alt="\ge" title="\ge" /> Euclidean <span style="font-variant: small-caps;">TSP</span></p>
<dl>
<dt>General</dt>
<dd><p>is the basic “general” <span style="font-variant: small-caps;">TSP</span> problem.</p>
</dd>
<dt>Metric</dt>
<dd><p>is described above <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
</dd>
<dt>Euclidean</dt>
<dd><p>is where vertexes are placed on a plane, and the weight of edges is the euclidean distance between vertexes <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>.</p>
</dd>
</dl>
<p>Every algorithm must store, access, or search data. We look at amortized analysis and more complicated data structures these data structures.</p>
<p>It’s assumed knowledge of the following:</p>
<ul>
<li><p>Heap-based priority queue</p></li>
<li><p>Dictionaries built using hashing, and balanced binary search.</p></li>
</ul>
<h1 id="cha:binomial_heaps">Binomial Heaps</h1>
<h2 id="sec:heaps">Heaps</h2>
<p>Heaps store are binary trees of elements, each with an numeric key. For a minimum heap, the minimum key is the root. Usually, we shape our heap as a near-perfect triangle, so we can store an array in level order and use indexing instead of pointers. The height of a heap is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28%5Clog%20n%29" alt="\theta(\log n)" title="\theta(\log n)" />.</p>
<p>We have five main operations in priority queues:</p>
<dl>
<dt>Insert</dt>
<dd><p>inserts at the bottom, and bubbles up - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28%5Clog%20n%29" alt="\theta(\log n)" title="\theta(\log n)" /></p>
</dd>
<dt>Delete Minimum</dt>
<dd><p>remove the root element, put the last item there, and bubble down. - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28%5Clog%20n%29" alt="\theta(\log n)" title="\theta(\log n)" /></p>
</dd>
<dt>Decrement Key</dt>
<dd><p>bubble the item up (or down) - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28n%29" alt="\theta(n)" title="\theta(n)" /></p>
</dd>
<dt>Build</dt>
<dd><p>can be done faster than repeated insertion - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28n%29" alt="\theta(n)" title="\theta(n)" /></p>
</dd>
<dt>Merge</dt>
<dd><p>merge two heaps into one heap - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28n%29" alt="\theta(n)" title="\theta(n)" /></p>
</dd>
</dl>
<h2 id="sec:prim_s_algorithm">Prim’s Algorithm</h2>
<p>Prim’s Algorithm finds the <strong>Minimum Spanning Tree</strong> of a graph.</p>
<p>Start with one node <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s%20%5Cin%20V" alt="s \in V" title="s \in V" />.</p>
<pre><code>remaining = V
while |remaining| &gt; 0:
    e_connecting, v_connected = heap.popMin()
    answer.put(e_connecting)
    remaining.remove(v_connected)
    heap.updateWeights(v_connected)
return answer
                </code></pre>
<p>We define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> as the number of edges, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> is the number of edges. <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20%3D%20O%28n%5E2%29" alt="m = O(n^2)" title="m = O(n^2)" />.</p>
<p>We can implement this two ways.</p>
<ul>
<li><p>If we store a heap of edges ordered by weight, this takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%5Ctext%7BDeleteMin%7D%20%2B%20m%28%5Ctext%7BInsert%7D%20%2B%20%5Ctext%7BDelete%7D%29%20%3D%20O%28%28n%2Bm%29%20%5Clog%20m%29" alt="n\text{DeleteMin} + m(\text{Insert} + \text{Delete}) = O((n+m) \log m)" title="n\text{DeleteMin} + m(\text{Insert} + \text{Delete}) = O((n+m) \log m)" /> time.</p></li>
<li><p>If we store a heap of vertexes, this takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%5Ctext%7BDeleteMin%7D%20%2B%20m%20%5Ctext%7BDecreaseKey%7D%20%3D%20O%28%28n%2Bm%29%20%5Clog%20n%29" alt="n \text{DeleteMin} + m \text{DecreaseKey} = O((n+m) \log n)" title="n \text{DeleteMin} + m \text{DecreaseKey} = O((n+m) \log n)" /> time.</p></li>
</ul>
<p>For now, these are the same<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a>. Once we implement different heaps, this difference becomes relevant.</p>
<h2 id="sec:binomial_heap">Binomial Heap</h2>
<p>We can improve the merge speed of our “standard” heaps by using pointers (where each node has any number of children) instead of an array to implement the heaps.</p>
<p>We keep the heap order, but we go beyond the fact that the heaps are made of trees.</p>
<h2 id="sec:binomial_tree">Binomial Tree</h2>
<p>We define binomial trees as follows:</p>
<p>The root of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_0" alt="B_0" title="B_0" /> is a single vertex with no children.</p>
<p>The root of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_1" alt="B_1" title="B_1" /> is the root of a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_0" alt="B_0" title="B_0" /> with an additional <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_0" alt="B_0" title="B_0" /> root vertex attached.</p>
<p>The root of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_2" alt="B_2" title="B_2" /> is the root of a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_1" alt="B_1" title="B_1" /> with an additional <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_1" alt="B_1" title="B_1" /> root vertex attached.</p>
<p>The root of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_k" alt="B_k" title="B_k" /> is the root of a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_%7Bk-1%7D" alt="B_{k-1}" title="B_{k-1}" /> tree with an additional <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_%7Bk-1%7D" alt="B_{k-1}" title="B_{k-1}" /> root vertex as a child of the root vertex.</p>
<p><img src="images/binomial_tree.png" title="fig:" alt="Sample Binomial Heaps" /> [fig:binomial<sub>h</sub>eap]</p>
<p>There are a few properties of Binomial Heaps we know about<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a>:</p>
<dl>
<dt>Size</dt>
<dd><p>of a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_k" alt="B_k" title="B_k" /> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%5Ek" alt="2^k" title="2^k" />.</p>
</dd>
<dt>Height</dt>
<dd><p>of a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_k" alt="B_k" title="B_k" /> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />, defined in the number of edges from the root to a leaf vertex.</p>
</dd>
<dt>Width of level</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> of a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_k" alt="B_k" title="B_k" /> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%20%7Bk%20%5Cchoose%20i%7D%29" alt=" {k \choose i})" title=" {k \choose i})" />.</p>
<p>This is since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7Bk%20%5Cchoose%20i%7D%20%3D%20%7B%7Bk-1%7D%20%5Cchoose%20i%7D%20%2B%20%7B%7Bk-1%7D%20%5Cchoose%20%7Bi-1%7D%7D" alt="{k \choose i} = {{k-1} \choose i} + {{k-1} \choose {i-1}}" title="{k \choose i} = {{k-1} \choose i} + {{k-1} \choose {i-1}}" /></p>
</dd>
</dl>
<h2 id="sec:binomial_heaps">Binomial Heaps</h2>
<p>To create binomial trees of arbitrary heights, we need to start using forests of binomial trees.</p>
<p>We can represent <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%3D%2013%20%3D%200b1101%20%3D%202%5E0%20%2B%202%5E2%20%2B%202%5E3" alt="n = 13 = 0b1101 = 2^0 + 2^2 + 2^3" title="n = 13 = 0b1101 = 2^0 + 2^2 + 2^3" /> elements as a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_0" alt="B_0" title="B_0" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_2" alt="B_2" title="B_2" />, and a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_3" alt="B_3" title="B_3" />.</p>
<p>In general, for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> elements, use <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%20n" alt="\log n" title="\log n" /> trees.</p>
<p>Most of our operations on this will be through a series of merges.</p>
<dl>
<dt>Merge</dt>
<dd><p>works like binary addition (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%281%29" alt="\theta(1)" title="\theta(1)" />) across the trees, so the cost is the same as the bit cost of addition - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28%5Clog%20n%29" alt="\theta(\log n)" title="\theta(\log n)" /></p>
</dd>
<dt>Insert</dt>
<dd><p>is a merge of the pre-existing forest and a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B_0" alt="B_0" title="B_0" /> tree - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28%5Clog%20n%29" alt="\theta(\log n)" title="\theta(\log n)" /> worst-case<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a></p>
</dd>
<dt>Delete Minimum</dt>
<dd><p>is done by finding the smallest tree, breaking removing the root vertex, and merging those to the remaining untouched trees - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28%5Clog%20n%29" alt="\theta(\log n)" title="\theta(\log n)" /></p>
</dd>
<dt>Decrease Key</dt>
<dd><p>is done inside a binomial tree as a standard “bubble up”, so the effect is limited to the height of the individual - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28%5Clog%20n%29" alt="\theta(\log n)" title="\theta(\log n)" /></p>
</dd>
<dt>Build Binomial Heap</dt>
<dd><p>can be done by repeated insertion in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> time.</p>
</dd>
</dl>
<h1 id="cha:amortized_analysis">Amortized Analysis</h1>
<h2 id="sec:example_for_binomial_heaps">Example For Binomial Heaps</h2>
<p>Binomial heaps take <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> time to merge. Let’s prove that.</p>
<p>We want to determine the bit cost for incrementing a binary counter from <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0" alt="0" title="0" /> to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />.</p>
<h3 id="sub:worst_case_analysis">Worst-Case Analysis</h3>
<p>The worst-case cost of one increment on a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-bit counter is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> increments cost <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%29" alt="O(n \log n)" title="O(n \log n)" /> (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%20n" alt="\log n" title="\log n" /> bits flipped <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> times).</p>
<h3 id="sub:amortized_analysis">Amortized Analysis</h3>
<p>We can get a better bound.</p>
<ul>
<li><p>The <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%5E0" alt="2^0" title="2^0" /> bit flips every time - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /></p></li>
<li><p>The <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%5E1" alt="2^1" title="2^1" /> bit flips every other time - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7Bn%7D%7B2%7D" alt="\frac{n}{2}" title="\frac{n}{2}" /></p></li>
<li><p>The <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%5E2" alt="2^2" title="2^2" /> bit flips every 4th time - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7Bn%7D%7B4%7D" alt="\frac{n}{4}" title="\frac{n}{4}" /></p></li>
<li><p>etc.</p></li>
</ul>
<p>The total cost is:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Csum_%7Bi%3D0%7D%5Ek%20%5Cfrac%7Bn%7D%7B2%5Ei%7D%20%5Cle%202n%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \sum_{i=0}^k \frac{n}{2^i} \le 2n
                    \end{aligned}" title="\begin{aligned}
                        \sum_{i=0}^k \frac{n}{2^i} \le 2n
                    \end{aligned}" /><br /></p>
<p>Thus, the average cost of incrementing a counter is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B2n%7D%7Bn%7D%20%3D%202" alt="\frac{2n}{n} = 2" title="\frac{2n}{n} = 2" />.</p>
<p>Since binomial heap appending is representable with a bit cost of a binary counter, the total cost for making a binomial heap is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" />.</p>
<h2 id="sec:an_amortized_definition">An Amortized Definition</h2>
<p>Given a sequence of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> operations with total cost <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28m%29" alt="T(m)" title="T(m)" />, then the <strong>amortized cost</strong> per operation is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7BT%28m%29%7D%7Bm%7D" alt="\frac{T(m)}{m}" title="\frac{T(m)}{m}" />.</p>
<h2 id="sec:potential_method_for_amortized_analysis">Potential Method for Amortized Analysis</h2>
<p>The idea for this method is that we are keeping an account of (time) cost.</p>
<p>Keeping track of a “potential-time” bank account, we keep track of the amortized difference between true of operations and a expected for all operations.</p>
<p>We call the bank balance after the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />th operation <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_i" alt="\Phi_i" title="\Phi_i" />.</p>
<ul>
<li><p>Cost is true.</p></li>
<li><p>Charge is artificial.</p></li>
</ul>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CPhi_i%20%26%3D%20%5CPhi_%7Bi-1%7D%20%2B%20%5Ctext%7Bcharge%7D%28i%29%20-%20%5Ctext%7Bcost%7D%28i%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    \Phi_i &amp;= \Phi_{i-1} + \text{charge}(i) - \text{cost}(i)
                \end{aligned}" title="\begin{aligned}
                    \Phi_i &amp;= \Phi_{i-1} + \text{charge}(i) - \text{cost}(i)
                \end{aligned}" /><br /></p>
<p>Since the potential (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_i" alt="\Phi_i" title="\Phi_i" />) and charge are artificial, we define them to make analysis easy.</p>
<p>It’s much simpler to define potential to get the charge:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7Bcharge%7D%28i%29%20%26%3D%20%5Ctext%7Bcost%7D%28i%29%20%2B%20%5CPhi_i%20-%20%5CPhi_%7Bi-1%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    \text{charge}(i) &amp;= \text{cost}(i) + \Phi_i - \Phi_{i-1}
                \end{aligned}" title="\begin{aligned}
                    \text{charge}(i) &amp;= \text{cost}(i) + \Phi_i - \Phi_{i-1}
                \end{aligned}" /><br /></p>
<p>If the final potential is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge" alt="\ge" title="\ge" /> than the initial potential, then the amortized cost is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle" alt="\le" title="\le" /> max charge.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Csum_%7Bi%3D1%7D%5Em%20%5Ctext%7Bcharge%7D%28i%29%20%26%3D%20%5Csum_%7Bi%3D1%7D%5Em%20%5Ctext%7Bcost%7D%28i%29%20%2B%20%5Csum_%7Bi%3D1%7D%5Em%20%5CPhi_i%20-%20%5Csum_%7Bi%3D0%7D%5E%7Bm-1%7D%20%5CPhi_i%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Csum_%7Bi%3D1%7D%5Em%20%5Ctext%7Bcost%7D%28i%29%20%2B%20%5CPhi_m%20-%20%5CPhi_0%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CPhi_m%20-%20%5CPhi_0%20%5Cge0%20%26%5Cimplies%20%5Csum%20%5Ctext%7Bcharge%7D%28i%29%20%5Cge%20%5Csum%20%5Ctext%7Bcost%7D%28i%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7Bamortized%20cost%7D%20%26%3D%20%5Csum%20%5Cfrac%7B%5Ctext%7Bcost%7D%28i%29%7D%7Bm%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%5Csum%20%5Cfrac%7B%5Ctext%7Bcharge%7D%28i%29%7D%7Bm%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%5Ctext%7Bmax%20charge%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    \sum_{i=1}^m \text{charge}(i) &amp;= \sum_{i=1}^m \text{cost}(i) + \sum_{i=1}^m \Phi_i - \sum_{i=0}^{m-1} \Phi_i \\
                    &amp;= \sum_{i=1}^m \text{cost}(i) + \Phi_m - \Phi_0 \\
                    \Phi_m - \Phi_0 \ge0 &amp;\implies \sum \text{charge}(i) \ge \sum \text{cost}(i) \\
                    \text{amortized cost} &amp;= \sum \frac{\text{cost}(i)}{m} \\
                    &amp;\le \sum \frac{\text{charge}(i)}{m} \\
                    &amp;\le \text{max charge}
                \end{aligned}" title="\begin{aligned}
                    \sum_{i=1}^m \text{charge}(i) &amp;= \sum_{i=1}^m \text{cost}(i) + \sum_{i=1}^m \Phi_i - \sum_{i=0}^{m-1} \Phi_i \\
                    &amp;= \sum_{i=1}^m \text{cost}(i) + \Phi_m - \Phi_0 \\
                    \Phi_m - \Phi_0 \ge0 &amp;\implies \sum \text{charge}(i) \ge \sum \text{cost}(i) \\
                    \text{amortized cost} &amp;= \sum \frac{\text{cost}(i)}{m} \\
                    &amp;\le \sum \frac{\text{charge}(i)}{m} \\
                    &amp;\le \text{max charge}
                \end{aligned}" /><br /></p>
<h3 id="sub:potential_analysis_in_a_nutshell">Potential Analysis in a Nutshell</h3>
<p>We need to invent a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7Bpotential%7D%28i%29" alt="\text{potential}(i)" title="\text{potential}(i)" /> and a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7Bcharge%7D%28i%29" alt="\text{charge}(i)" title="\text{charge}(i)" /> and prove that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_m%20%5Cge%20%5CPhi_0" alt="\Phi_m \ge \Phi_0" title="\Phi_m \ge \Phi_0" />.</p>
<p>A goal when inventing potential and charge is to prove that max charge is small, since the amortized cost is less than or equal to the maximum charged.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7Bcharge%7D%28i%29%20%26%3D%20%5Ctext%7Bcost%7D%28i%29%20%2B%20%5CPhi_i%20-%20%5CPhi_%7Bi-1%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \text{charge}(i) &amp;= \text{cost}(i) + \Phi_i - \Phi_{i-1}
                    \end{aligned}" title="\begin{aligned}
                        \text{charge}(i) &amp;= \text{cost}(i) + \Phi_i - \Phi_{i-1}
                    \end{aligned}" /><br /></p>
<h3 id="sub:binary_counters_using_the_potential_method">Binary Counters Using the Potential Method</h3>
<p>We know that only one bit will undergo <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0%20%5Cto%201" alt="0 \to 1" title="0 \to 1" /> in a given increment.</p>
<p>The cost is high when <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1%20%5Cto%200" alt="1 \to 0" title="1 \to 0" /> occurs many times. Let’s pay for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0%20%5Cto%201" alt="0 \to 1" title="0 \to 1" /> and an extra $1 for when this bit eventually flips <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1%20%5Cto%200" alt="1 \to 0" title="1 \to 0" />.</p>
<p>Thus, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7Bcharge%7D%28i%29%20%3D%202" alt="\text{charge}(i) = 2" title="\text{charge}(i) = 2" />.</p>
<p>By theorem, the amortized cost <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle" alt="\le" title="\le" /> max charge <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3D2" alt="=2" title="=2" />, so long as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_m%20%5Cge%20%5CPhi_0" alt="\Phi_m \ge \Phi_0" title="\Phi_m \ge \Phi_0" />.</p>
<p>Formally, we’d like to specify the relation between <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7Bcharge%7D%28i%29" alt="\text{charge}(i)" title="\text{charge}(i)" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_i" alt="\Phi_i" title="\Phi_i" />.</p>
<p>We make a jump here that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_i" alt="\Phi_i" title="\Phi_i" /> is the number of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1" alt="1" title="1" />s in the counter after the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />th operation.</p>
<p>Supposing the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />th operation changes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t_i" alt="t_i" title="t_i" /> bits <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1%5Cto0" alt="1\to0" title="1\to0" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1" alt="1" title="1" /> bit <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0%5Cto1" alt="0\to1" title="0\to1" />.</p>
<p>Then we have:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7Bcost%7D%28i%29%20%26%3D%20t_i%20%2B%201%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CPhi_i%20%26%3D%20%5CPhi_%7Bi-1%7D%20-%20t_i%20%2B%201%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7Bcharge%7D%28i%29%20%26%3D%20%5Ctext%7Bcost%7D%28i%29%20%2B%20%5CPhi_i%20-%20%5CPhi_%7Bi-1%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20t_i%20%2B%201%20-%20t_i%20-%201%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%202%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \text{cost}(i) &amp;= t_i + 1 \\
                        \Phi_i &amp;= \Phi_{i-1} - t_i + 1 \\
                        \text{charge}(i) &amp;= \text{cost}(i) + \Phi_i - \Phi_{i-1} \\
                        &amp;= t_i + 1 - t_i - 1 \\
                        &amp;= 2
                    \end{aligned}" title="\begin{aligned}
                        \text{cost}(i) &amp;= t_i + 1 \\
                        \Phi_i &amp;= \Phi_{i-1} - t_i + 1 \\
                        \text{charge}(i) &amp;= \text{cost}(i) + \Phi_i - \Phi_{i-1} \\
                        &amp;= t_i + 1 - t_i - 1 \\
                        &amp;= 2
                    \end{aligned}" /><br /></p>
<p>Thus, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_0%20%3D%200" alt="\Phi_0 = 0" title="\Phi_0 = 0" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_m%20%5Cge%200" alt="\Phi_m \ge 0" title="\Phi_m \ge 0" />, so the theorem applies.</p>
<h2 id="sec:mergeable_heaps">Mergeable Heaps</h2>
<p>There’s a family of heaps who’s main operation is a <code>merge</code>.</p>
<p>[h]</p>
<p><span> l | c | c | c </span> &amp; Binomial Heap &amp; Lazy Binomial Heap &amp; Fibonacci Heap<br /></p>
<p>insert &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> &amp; <span><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" /></span> &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" /><br />delete min &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> &amp; A <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> &amp; A <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /><br />merge &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> &amp; <span><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" /></span> &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" /><br />decrease key &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> &amp; <span>A <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" /></span><br />build &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> &amp; <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" /><br /></p>
<h3 id="sub:lazy_binomial_heaps">Lazy Binomial Heaps</h3>
<p>We can improve merge an insert by lazily combining trees during <code>insert</code> and <code>merge</code> operations. We catch up on work when performing a <code>delete min</code> operation to have exactly one tree of each rank.</p>
<h4 id="ssub:implementing_delete_min">Implementing Delete-Min</h4>
<ul>
<li><p>Look at all roots to find the min</p></li>
<li><p>Delete that root, its children become separate</p></li>
<li><p>Consolidate ranks from smallest to largest</p></li>
</ul>
<p>The wost case cost of <code>delete min</code> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28n%29" alt="\theta(n)" title="\theta(n)" />, with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> singleton trees.</p>
<h4 id="ssub:amortized_analysis_of_delete_min">Amortized Analysis of Delete Min</h4>
<p>We theorize that Lazy Binomial Heaps have A <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> cost for <code>delete min</code>.</p>
<p>By <em>magic</em>, we pick <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi" alt="\Phi" title="\Phi" /> to represent the number of trees. Thus, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_0%20%3D%200" alt="\Phi_0 = 0" title="\Phi_0 = 0" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_m%20%5Cge%200" alt="\Phi_m \ge 0" title="\Phi_m \ge 0" />, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_m%20%5Cge%20%5CPhi_0" alt="\Phi_m \ge \Phi_0" title="\Phi_m \ge \Phi_0" />.</p>
<p>We know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7Bcharge%7D%28i%29%20%3D%20%5Ctext%7Bcost%7D%28i%29%20%2B%20%5CPhi_i%20-%20%5CPhi_%7Bi-1%7D" alt="\text{charge}(i) = \text{cost}(i) + \Phi_i - \Phi_{i-1}" title="\text{charge}(i) = \text{cost}(i) + \Phi_i - \Phi_{i-1}" />. Let’s examine other operations costs first:</p>
<ul>
<li><p>Merge cost is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" />, since the number of trees is the same.</p></li>
<li><p>Decrease key cost is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" />, and the number of trees is the same.</p></li>
<li><p>Insert cost is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" />, since the number of trees increase by one.</p></li>
</ul>
<p>In the case of <code>delete min</code>, we have the degree <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r%20%5Cin%20O%28%5Clog%20n%29" alt="r \in O(\log n)" title="r \in O(\log n)" /> of the node being deleted, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t%20%3D%20%5CPhi_%7Bi-1%7D" alt="t = \Phi_{i-1}" title="t = \Phi_{i-1}" /> as the number of trees being deleted.</p>
<p>Consolidate is called on <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t-1%2Br" alt="t-1+r" title="t-1+r" /> trees.</p>
<p>Thus the total cost is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t%20-%201%20%2B%20r%20%2B%20O%28%5Clog%20n%29" alt="t - 1 + r + O(\log n)" title="t - 1 + r + O(\log n)" />.</p>
<p>After consolidation, we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_i%20%5Cin%20O%28%5Clog%20n%29" alt="\Phi_i \in O(\log n)" title="\Phi_i \in O(\log n)" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7Bamortized%20cost%7D%20%26%5Cle%20%5Ctext%7Bmax%20charge%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%5Ctext%7Bcost%7D%28i%29%20%2B%20%5CPhi_i%20-%20%5CPhi_%7Bi-1%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20t%20-%201%20%2B%20r%20%2B%20O%28%5Clog%20n%29%20-%20t%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20r%20%2B%20O%28%5Clog%20n%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20r%20%5Cin%20O%28%5Clog%20n%29%20%26%5Cimplies%20%5Ctext%7Bamortized%20cost%7D%20%5Cin%20O%28%5Clog%20n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                            \text{amortized cost} &amp;\le \text{max charge} \\
                            &amp;\le \text{cost}(i) + \Phi_i - \Phi_{i-1} \\
                            &amp;= t - 1 + r + O(\log n) - t \\
                            &amp;\le r + O(\log n) \\
                            r \in O(\log n) &amp;\implies \text{amortized cost} \in O(\log n)
                        \end{aligned}" title="\begin{aligned}
                            \text{amortized cost} &amp;\le \text{max charge} \\
                            &amp;\le \text{cost}(i) + \Phi_i - \Phi_{i-1} \\
                            &amp;= t - 1 + r + O(\log n) - t \\
                            &amp;\le r + O(\log n) \\
                            r \in O(\log n) &amp;\implies \text{amortized cost} \in O(\log n)
                        \end{aligned}" /><br /></p>
<p>Thus <code>delete min</code> for lazy binomial heaps runs in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> worst case, but <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> amortized.</p>
<h3 id="sub:fibonacci_heaps">Fibonacci Heaps</h3>
<p>In these heaps, we want to improve the amortized cost of <code>decrease key</code>.</p>
<p>What if instead of bubbling up, we simply “cut off” the node being decreased (and its sub-tree) from its parents?</p>
<p>This is dangerous, since the number of trees increases, and the number of child nodes change (not just <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%5Ei" alt="2^i" title="2^i" />) for details.</p>
<p>TODO: the notes in lecture 3 reference assignment 2 for a practical alternative to Fibonacci Heaps. Dig this up.</p>
<h1 id="cha:splay_trees">Splay Trees</h1>
<p>In a nutshell, splay trees are self-adjusting data structures that alter data structure after each query. They’re the tree equivalent to lists that use <a href="move-to-front">https://en.wikipedia.org/wiki/Move-to-front_transform</a> to improve lookup times.</p>
<h2 id="sec:requisite_knowledge">Requisite Knowledge</h2>
<h3 id="sub:dictionaries">Dictionaries</h3>
<p>These use keys from a totally ordered universe. Operations include:</p>
<ul>
<li><p>Insert</p></li>
<li><p>Delete</p></li>
<li><p>Search</p></li>
</ul>
<h4 id="ssub:unbalanced_binary_search_trees">Unbalanced Binary Search Trees</h4>
<p>All operations take <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28h%29" alt="O(h)" title="O(h)" />, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h" alt="h" title="h" /> is the height of the tree.</p>
<h4 id="ssub:balanced_binary_search_tree">Balanced Binary Search Tree</h4>
<p>We limit <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h%20%5Cin%20O%28%5Clog%20n%29" alt="h \in O(\log n)" title="h \in O(\log n)" />. There are two (main) implementations: AVL and red-black trees. Both implementations must keep the balance information, and are re-balanced using rotations.</p>
<h2 id="sec:regarding_splay_trees">Regarding Splay Trees</h2>
<p>Splay trees were invented (discovered?) by Sleator and Tarjan in `85. They offer A <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28%5Clog%20n%29" alt="\theta(\log n)" title="\theta(\log n)" /> cost per operation, with a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28n%29" alt="\theta(n)" title="\theta(n)" /> worst case running time. By not keeping balance information, they become easier to implement than other conventional balanced trees.</p>
<p>The course notes allude to an example where single rotations do not give good average behavior, so we will do double rotations instead.</p>
<h3 id="sub:splay_operation">Splay Operation</h3>
<p>The <code>splay(x)</code> operation moves <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> repeatedly to the root. This occurs through three cases. Refer to Figures [fig:splay<sub>t</sub>rees<sub>c</sub>ase<sub>1</sub>], [fig:splay<sub>t</sub>rees<sub>c</sub>ase<sub>2</sub>], and [fig:splay<sub>t</sub>rees<sub>c</sub>ase<sub>3</sub>].</p>
<p><img src="images/splay_trees_case_1.png" title="fig:" alt="Splay Trees Case 1" /> [fig:splay<sub>t</sub>rees<sub>c</sub>ase<sub>1</sub>]</p>
<p><img src="images/splay_trees_case_2.png" title="fig:" alt="Splay Trees Case 2" /> [fig:splay<sub>t</sub>rees<sub>c</sub>ase<sub>2</sub>]</p>
<p><img src="images/splay_trees_case_3.png" title="fig:" alt="Splay Trees Case 3" /> [fig:splay<sub>t</sub>rees<sub>c</sub>ase<sub>3</sub>]</p>
<h3 id="sub:splay_tree_methods">Splay Tree Methods</h3>
<dl>
<dt>Search</dt>
<dd><p>- after finding <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />, calling <code>splay(x)</code>, even for unsuccessful searches.</p>
</dd>
<dt>Insert</dt>
<dd><p>- usual binary search tree insert, then we <code>splay</code> the new node.</p>
</dd>
<dt>Delete</dt>
<dd><p>- usual binary search tree delete, then splay the parent of the node being removed.</p>
</dd>
</dl>
<h2 id="sec:amortized_analysis_of_splay_trees">Amortized Analysis of Splay Trees</h2>
<p>If the height <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h" alt="h" title="h" /> of a tree is large, then search is expensive, and we pay out of potential.</p>
<p>We define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=D%28x%29" alt="D(x)" title="D(x)" /> as the number of descendants of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />, including <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r%28x%29%20%3D%20%5Clog%28D%28x%29%29" alt="r(x) = \log(D(x))" title="r(x) = \log(D(x))" /> . Finally, we define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi%28T%29%20%3D%20%5Csum_x%20r%28x%29" alt="\Phi(T) = \sum_x r(x)" title="\Phi(T) = \sum_x r(x)" />. By <em>magic</em>, we have the max as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_%7B%5Ctext%7Bmax%7D%7D%20%3D%20O%28%5Clog%28n%21%29%29%20%3D%20O%28n%5Clog%28n%29%29" alt="\Phi_{\text{max}} = O(\log(n!)) = O(n\log(n))" title="\Phi_{\text{max}} = O(\log(n!)) = O(n\log(n))" />, and the min as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_%5Ctext%7Bmin%7D%20%3D%20O%28n%29" alt="\Phi_\text{min} = O(n)" title="\Phi_\text{min} = O(n)" />.</p>
<p>For a single node, we call <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r%28x%29" alt="r(x)" title="r(x)" /> the current rank, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r%27%28x%29" alt="r&#39;(x)" title="r&#39;(x)" /> the rank after calling <code>splay(x)</code>.</p>
<p>We claim that the amortized cost of one step of <code>splay(x)</code> is:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20O%28%5Ctext%7Bsplay%7D%28x%29%29%20%26%5Cle%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cleft%5C%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cbegin%7Barray%7D%7Blr%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%203%20%28r%27%28x%29%20-%20r%28x%29%29%20%3A%26%20%5Ctext%7B%20for%20cases%201%20and%202%7D%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%203%20%28r%27%28x%29%20-%20r%28x%29%29%20%2B%201%20%3A%26%20%5Ctext%7B%20for%20case%203%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Barray%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cright.%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    O(\text{splay}(x)) &amp;\le
                    \left\{
                        \begin{array}{lr}
                            3 (r&#39;(x) - r(x)) :&amp; \text{ for cases 1 and 2}\\
                            3 (r&#39;(x) - r(x)) + 1 :&amp; \text{ for case 3}
                        \end{array}
                    \right.
                \end{aligned}" title="\begin{aligned}
                    O(\text{splay}(x)) &amp;\le
                    \left\{
                        \begin{array}{lr}
                            3 (r&#39;(x) - r(x)) :&amp; \text{ for cases 1 and 2}\\
                            3 (r&#39;(x) - r(x)) + 1 :&amp; \text{ for case 3}
                        \end{array}
                    \right.
                \end{aligned}" /><br /></p>
<p>Note that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28r%27%27%28x%29%20-%20r%27%28x%29%29%20%2B%20%28r%27%28x%29%20-%20r%28x%29%29%20%3D%20r%27%27%28x%29%20-%20r%28x%29" alt="(r&#39;&#39;(x) - r&#39;(x)) + (r&#39;(x) - r(x)) = r&#39;&#39;(x) - r(x)" title="(r&#39;&#39;(x) - r&#39;(x)) + (r&#39;(x) - r(x)) = r&#39;&#39;(x) - r(x)" />.</p>
<p>Since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPhi_i%20%5Cge%20%5CPhi_0" alt="\Phi_i \ge \Phi_0" title="\Phi_i \ge \Phi_0" />, we now want to find the amortized cost.</p>
<ul>
<li><p>For case 3, refer to Figure [fig:splay<sub>t</sub>rees<sub>a</sub>mortized<sub>c</sub>ase<sub>3</sub>].</p>
<p><img src="images/splay_trees_amortized_case_3.png" title="fig:" alt="Amortized Splay Tree Analysis - Case 3" /> [fig:splay<sub>t</sub>rees<sub>a</sub>mortized<sub>c</sub>ase<sub>3</sub>]</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7Bamortized%20cost%7D%20%26%5Cle%20%5Ctext%7Bcharge%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Ctext%7Btrue%20cost%7D%20%2B%20%5Ctext%7Bchange%20in%20potential%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%201%20%2B%20r%27%28x%29%20%2B%20r%27%28y%29%20-%20r%28x%29%20-%20r%28y%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20r%27%28x%29%20%3D%20r%28y%29%20%26%5Cimplies%20%5Ctext%7Bamortized%20cost%7D%20%3D%201%20%2B%20r%27%28y%29%20-%20r%28x%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%201%20%2B%20r%27%28x%29%20-%20r%28x%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%201%20%2B%203%28r%27%28x%29%20-%20r%28x%29%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                            \text{amortized cost} &amp;\le \text{charge} \\
                            &amp;= \text{true cost} + \text{change in potential} \\
                            &amp;= 1 + r&#39;(x) + r&#39;(y) - r(x) - r(y) \\
                            r&#39;(x) = r(y) &amp;\implies \text{amortized cost} = 1 + r&#39;(y) - r(x) \\
                            &amp;\le 1 + r&#39;(x) - r(x) \\
                            &amp;\le 1 + 3(r&#39;(x) - r(x))
                        \end{aligned}" title="\begin{aligned}
                            \text{amortized cost} &amp;\le \text{charge} \\
                            &amp;= \text{true cost} + \text{change in potential} \\
                            &amp;= 1 + r&#39;(x) + r&#39;(y) - r(x) - r(y) \\
                            r&#39;(x) = r(y) &amp;\implies \text{amortized cost} = 1 + r&#39;(y) - r(x) \\
                            &amp;\le 1 + r&#39;(x) - r(x) \\
                            &amp;\le 1 + 3(r&#39;(x) - r(x))
                        \end{aligned}" /><br /></p></li>
<li><p>For case 1, refer to Figure [fig:splay<sub>t</sub>rees<sub>a</sub>mortized<sub>c</sub>ase<sub>1</sub>].</p>
<p><img src="images/splay_trees_amortized_case_1.png" title="fig:" alt="Amortized Splay Tree Analysis - Case 1" /> [fig:splay<sub>t</sub>rees<sub>a</sub>mortized<sub>c</sub>ase<sub>1</sub>]</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7Bamortized%20cost%7D%20%26%5Cle%20%5Ctext%7Btrue%20cost%7D%20%2B%20%5Ctext%7Bchange%20in%20potential%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%202%20%2B%20%28r%27%28x%29%20%2B%20r%27%28y%29%20%2B%20r%27%28z%29%20-%20r%28x%29%20-%20r%28y%29%20-%20r%28z%29%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20r%27%28x%29%20%3D%20r%28z%29%20%26%5Cimplies%20%5Ctext%7Bamortized%20cost%7D%20%5Cle%202%20%2B%20r%27%28y%29%20%2B%20r%27%28z%29%20-%20r%28x%29%20-%20r%28y%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20r%27%28y%29%20%5Cle%20r%27%28x%29%20%5Cland%20-r%28y%29%20%5Cle%20-r%28x%29%20%26%5Cimplies%20%5Ctext%7Bamortized%20cost%7D%20%5Cle%202%20%2B%20r%27%28x%29%20%2B%20r%27%28z%29%20-%202r%28x%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                            \text{amortized cost} &amp;\le \text{true cost} + \text{change in potential} \\
                            &amp;= 2 + (r&#39;(x) + r&#39;(y) + r&#39;(z) - r(x) - r(y) - r(z)) \\
                            r&#39;(x) = r(z) &amp;\implies \text{amortized cost} \le 2 + r&#39;(y) + r&#39;(z) - r(x) - r(y) \\
                            r&#39;(y) \le r&#39;(x) \land -r(y) \le -r(x) &amp;\implies \text{amortized cost} \le 2 + r&#39;(x) + r&#39;(z) - 2r(x)
                        \end{aligned}" title="\begin{aligned}
                            \text{amortized cost} &amp;\le \text{true cost} + \text{change in potential} \\
                            &amp;= 2 + (r&#39;(x) + r&#39;(y) + r&#39;(z) - r(x) - r(y) - r(z)) \\
                            r&#39;(x) = r(z) &amp;\implies \text{amortized cost} \le 2 + r&#39;(y) + r&#39;(z) - r(x) - r(y) \\
                            r&#39;(y) \le r&#39;(x) \land -r(y) \le -r(x) &amp;\implies \text{amortized cost} \le 2 + r&#39;(x) + r&#39;(z) - 2r(x)
                        \end{aligned}" /><br /></p>
<p>To show that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%20%2B%20r%27%28x%29%20%2B%20r%27%28z%29%20-%202r%28x%29%20%5Cle%203%28r%27%28x%29%20-%20r%28x%29%29" alt="2 + r&#39;(x) + r&#39;(z) - 2r(x) \le 3(r&#39;(x) - r(x))" title="2 + r&#39;(x) + r&#39;(z) - 2r(x) \le 3(r&#39;(x) - r(x))" />, it is enough to show that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%20%5Cle%202r%27%28x%29%20-%20r%28x%29%20-%20r%27%28z%29" alt="2 \le 2r&#39;(x) - r(x) - r&#39;(z)" title="2 \le 2r&#39;(x) - r(x) - r&#39;(z)" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cforall%20x%2C%20y%20%3E%200%20%5Cland%20x%2By%20%5Cle%201%20%26%3A%20%5Ctext%7BRange%7D%28%5Clog%20x%20%2B%20%5Clog%20y%29%20%3D%20%28-%5Cinfty%2C%20-2%5D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cimplies%20%5Cforall%20a%20%2B%20b%20%5Cle%20c%20%26%5Cto%20%5Clog%7B%5Cleft%28%5Cfrac%7Ba%7D%7Bc%7D%5Cright%29%7D%20%2B%20%5Clog%7B%5Cleft%28%5Cfrac%7Bb%7D%7Bc%7D%5Cright%29%7D%20%5Cle%20-2%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20D%28x%29%20%2B%20D%27%28z%29%20%5Cle%20D%27%28x%29%20%26%5Cimplies%20%5Clog%28D%28x%29%2B%20%5Clog%28D%27%28z%29%29%20%5Cle%202%20%5Clog%28D%27%28x%29%29%20-%202%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20r%28x%29%20%2B%20r%27%28z%29%20%26%5Cle%202r%27%28x%29%20-%202%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%202%20%26%5Cle%202r%27%28x%29%20-%20r%28x%29%20-%20r%27%28z%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                            \forall x, y &gt; 0 \land x+y \le 1 &amp;: \text{Range}(\log x + \log y) = (-\infty, -2] \\
                            \implies \forall a + b \le c &amp;\to \log{\left(\frac{a}{c}\right)} + \log{\left(\frac{b}{c}\right)} \le -2 \\
                            D(x) + D&#39;(z) \le D&#39;(x) &amp;\implies \log(D(x)+ \log(D&#39;(z)) \le 2 \log(D&#39;(x)) - 2 \\
                            r(x) + r&#39;(z) &amp;\le 2r&#39;(x) - 2 \\
                            2 &amp;\le 2r&#39;(x) - r(x) - r&#39;(z)
                        \end{aligned}" title="\begin{aligned}
                            \forall x, y &gt; 0 \land x+y \le 1 &amp;: \text{Range}(\log x + \log y) = (-\infty, -2] \\
                            \implies \forall a + b \le c &amp;\to \log{\left(\frac{a}{c}\right)} + \log{\left(\frac{b}{c}\right)} \le -2 \\
                            D(x) + D&#39;(z) \le D&#39;(x) &amp;\implies \log(D(x)+ \log(D&#39;(z)) \le 2 \log(D&#39;(x)) - 2 \\
                            r(x) + r&#39;(z) &amp;\le 2r&#39;(x) - 2 \\
                            2 &amp;\le 2r&#39;(x) - r(x) - r&#39;(z)
                        \end{aligned}" /><br /></p>
<p>Thus the amortized cost of case 1 is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%203%28r%27%28x%29%20-%20r%28x%29%29" alt="\le 3(r&#39;(x) - r(x))" title="\le 3(r&#39;(x) - r(x))" />.</p></li>
<li><p>Case 2 is incredibly similar to case 1 with minor (ordering) modifications.</p></li>
</ul>
<p>Without proof<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a>, we claim that a tree <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> root <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" /> and node <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />, the amortized cost of <code>splay(x)</code> is:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20A%20O%28%5Ctext%7Bsplay%7D%29%20%26%5Cle%203%28r%28t%29%20-%20r%28x%29%29%20%2B%201%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cin%20O%28%5Clog%7B%5Cfrac%7BD%28t%29%7D%7BD%28x%29%7D%7D%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20O%28%5Clog%20n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    A O(\text{splay}) &amp;\le 3(r(t) - r(x)) + 1 \\
                    &amp;\in O(\log{\frac{D(t)}{D(x)}}) \\
                    &amp;= O(\log n)
                \end{aligned}" title="\begin{aligned}
                    A O(\text{splay}) &amp;\le 3(r(t) - r(x)) + 1 \\
                    &amp;\in O(\log{\frac{D(t)}{D(x)}}) \\
                    &amp;= O(\log n)
                \end{aligned}" /><br /></p>
<p>Let <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_i%20%3D%20r%28x%29" alt="r_i = r(x)" title="r_i = r(x)" /> after the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />th step of the splay. So <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_0%20%3D%20r%28x%29" alt="r_0 = r(x)" title="r_0 = r(x)" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_k%20%3D%20r%28t%29" alt="r_k = r(t)" title="r_k = r(t)" /> (where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> is the final step). Thus the overall amortized cost of splay is:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20A%20O%28%5Ctext%7Bsplay%7D%29%20%26%3D%201%20%2B%20%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%203%28r_i%20-%20r_%7Bi-1%7D%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%203%28r_k%20-%20r_0%29%20%2B%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    A O(\text{splay}) &amp;= 1 + \sum_{i=1}^{k} 3(r_i - r_{i-1}) \\
                    &amp;= 3(r_k - r_0) + 1
                \end{aligned}" title="\begin{aligned}
                    A O(\text{splay}) &amp;= 1 + \sum_{i=1}^{k} 3(r_i - r_{i-1}) \\
                    &amp;= 3(r_k - r_0) + 1
                \end{aligned}" /><br /></p>
<p>We know that the cost of walking down the tree in each operation is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle" alt="\le" title="\le" /> the cost of the ensuing splay. Thus, we know the amortized cost of <code>insert</code>, <code>search</code>, and <code>delete</code> in a splay tree is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" />.</p>
<p>We briefly touched in class that <code>insert</code> and <code>delete</code> both modify potential, but this is still covered by the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%20n" alt="\log n" title="\log n" /> work to walk to the inserted and deleted value.</p>
<h1 id="cha:union_find_problem">Union-Find Problem</h1>
<p>Connected components in a graph are essentially the components where two can reach each other.</p>
<p>We want to find all connected components, and identify which component a given vertex is in. Let’s make this efficient.</p>
<p>In general, we assume we are given a graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G" alt="G" title="G" /> with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> vertexes and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> edges. We then need to respond to two queries:</p>
<dl>
<dt>find</dt>
<dd><p>are vertexes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a" alt="a" title="a" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=b" alt="b" title="b" /> in the same component?</p>
</dd>
<dt>union</dt>
<dd><p>connect the components which vertexes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" /> lie in.</p>
</dd>
</dl>
<p>Using depth-first search, it takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%2Bm%29" alt="O(n+m)" title="O(n+m)" /> time to perform <code>find</code>, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" /> time to perform <code>union</code>.</p>
<h2 id="sec:dynamic_graph_connectivity">Dynamic Graph Connectivity</h2>
<p>For many data structures, we can get much faster runtime by maintaining (and later updating) results as the underlying data changes.</p>
<p>Examples of where this is useful:</p>
<ul>
<li><p>Social networks as relationships are added and deleted.</p></li>
<li><p>Minimum spanning tree<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a></p></li>
<li><p>Kruskal’s Algorithm<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a></p></li>
</ul>
<h2 id="sec:union_find_data_structure">Union-Find Data Structure</h2>
<p>We want to maintain a collection of disjoint sets then evaluate:</p>
<dl>
<dt>Union<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28A%2C%20B%29" alt="(A, B)" title="(A, B)" /></dt>
<dd><p>unites (modifies) the two sets <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B" alt="B" title="B" /> to be in the same set.</p>
</dd>
<dt>Find<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28e%29" alt="(e)" title="(e)" /></dt>
<dd><p>which set contains <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" />?</p>
</dd>
</dl>
<p>If we analyze Kruskal’s algorithm using union-find data structure, we get:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cmbox%7Bsort%7D%20%2B%202m%20%5Cmbox%7BFinds%7D%20%2B%20n%20%5Cmbox%7BUnions%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    \mbox{sort} + 2m \mbox{Finds} + n \mbox{Unions}
                \end{aligned}" title="\begin{aligned}
                    \mbox{sort} + 2m \mbox{Finds} + n \mbox{Unions}
                \end{aligned}" /><br /></p>
<p>Sort takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%5Clog%20m%29%20%3D%20O%28m%20%5Clog%20n%29" alt="O(m \log m) = O(m \log n)" title="O(m \log m) = O(m \log n)" /> time<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a>, so we want the finds and unions to work in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20O%20%28m%20%5Clog%20n%29" alt="\le O (m \log n)" title="\le O (m \log n)" /> to have a speedy algorithm.</p>
<p>Define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> as the number of elements, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> as the number of operations. For all implementations, the number of unions <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20n%20-%201" alt="\le n - 1" title="\le n - 1" />.</p>
<h3 id="sub:implementation_with_an_array">Implementation With an Array</h3>
<p>Using an array <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%5B1...n%5D" alt="S[1...n]" title="S[1...n]" />, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%5Bi%5D" alt="S[i]" title="S[i]" /> contains the name of a set containing <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />.</p>
<dl>
<dt>Find</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" /></p>
</dd>
<dt>Union</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> worst case</p>
</dd>
</dl>
<p>To make this marginally faster, we can maintain a set for each set as well. Thus, <code>union(A, B)</code> will update <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> for the smaller set. Since each element changes its set name <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Clog%20n" alt="\le \log n" title="\le \log n" /> times, the overall cost of all unions is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20O%28n%20%5Clog%20n%29" alt="\le O(n \log n)" title="\le O(n \log n)" />.</p>
<p>The cost of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> operations is thus <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%2B%20n%20%5Clog%20n%29" alt="O(m + n \log n)" title="O(m + n \log n)" />. With this implementation, this is the best possible if the number of finds is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5COmega%28n%20%5Clog%20n%29" alt="\Omega(n \log n)" title="\Omega(n \log n)" />.</p>
<p>Thus in this case, we get <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%28n%2Bm%29%20%5Clog%20n%29" alt="O((n+m) \log n)" title="O((n+m) \log n)" /> for Kruskal’s algorithm.</p>
<h3 id="sub:a_better_implementation">A Better Implementation</h3>
<p>In the case that the number of finds is small, the array-based union-find implementation is horrible.</p>
<p>When we represent each set as a tree, life becomes much better.</p>
<dl>
<dt>Union</dt>
<dd><p>is implemented as merging the smaller tree as a child to the root of the larger tree. See Figure [fig:union<sub>f</sub>ind<sub>u</sub>nion] for a pictorial visualization.</p>
</dd>
<dt>Find</dt>
<dd><p>is implemented by traversing up the tree from the node, then returning the name of the root node. After traversing upwards, we perform path compression by setting the parent of all vertexes in the path to be the root of this tree. See Figure [fig:union<sub>f</sub>ind<sub>f</sub>ind] for a pictorial visualization.</p>
</dd>
</dl>
<p><img src="images/union_find_union.png" title="fig:" alt="Union Operation in the Union-Find Data Structure" /> [fig:union<sub>f</sub>ind<sub>u</sub>nion]</p>
<p><img src="images/union_find_find.png" title="fig:" alt="Find Operation in the Union-Find Data Structure" /> [fig:union<sub>f</sub>ind<sub>f</sub>ind]</p>
<p>We determine the smaller tree by keeping track of the “rank” of a tree - the height if there was no path compression. When <code>union</code>-ing a smaller <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_2" alt="r_2" title="r_2" /> onto a larger <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_1" alt="r_1" title="r_1" />, the the new rank is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cmax%5C%7Br_1%2C%20r_2%2B1%5C%7D" alt="\max\{r_1, r_2+1\}" title="\max\{r_1, r_2+1\}" />.</p>
<h2 id="sec:analysis_of_the_union_find_data_structure">Analysis of the Union-Find Data Structure</h2>
<p>The implementation is simple, but the analysis is hard. In `75, Tarjan proved that the cost of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> operations is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CTheta%28m%20%5Calpha%28m%2C%20n%29%29" alt="\Theta(m \alpha(m, n))" title="\Theta(m \alpha(m, n))" /> time<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a>.</p>
<p>We will prove the slightly higher bound of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%5Clog%5E%2A%20n%29" alt="O(m \log^* n)" title="O(m \log^* n)" /> time for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> operations<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a>.</p>
<p>We know that the cost of <code>find(v)</code> is the same as the distance from <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> to the root. In a nutshell, we will charge some to the <code>find</code>, and some to the nodes along the path from <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> to the root, then sum it up.</p>
<p>We claim (without proof) that:</p>
<ol>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7Brank%7D%28v%29%20%3C%20%5Ctext%7Brank%7D%28%5Ctext%7Bparent%7D%28v%29%29" alt="\text{rank}(v) &lt; \text{rank}(\text{parent}(v))" title="\text{rank}(v) &lt; \text{rank}(\text{parent}(v))" />.</p></li>
<li><p>The number of vertexes of rank <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r" alt="r" title="r" /> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Cfrac%7Bn%7D%7B2%5Er%7D" alt="\le \frac{n}{2^r}" title="\le \frac{n}{2^r}" /> in size<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a>.</p></li>
</ol>
<p>In our analysis, we divide vertexes into groups based on their rank. A vertex of rank <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r" alt="r" title="r" /> goes in a group number <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%5E%2A%28r%29" alt="\log^*(r)" title="\log^*(r)" />. Thus a group <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=g" alt="g" title="g" /> contain the ranks <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%5Cuparrow%28g-1%29%20%2B%201%2C%202%5Cuparrow%28g-1%29%20%2B%202%2C%20%5Cldots%2C%202%5Cuparrow%20g" alt="2\uparrow(g-1) + 1, 2\uparrow(g-1) + 2, \ldots, 2\uparrow g" title="2\uparrow(g-1) + 1, 2\uparrow(g-1) + 2, \ldots, 2\uparrow g" />. For group <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=g" alt="g" title="g" />, the number different ranks <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%28g%29%2B1" alt="c(g)+1" title="c(g)+1" /> in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=g" alt="g" title="g" /> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%202%20%5Cuparrow%20g" alt="\le 2 \uparrow g" title="\le 2 \uparrow g" />.</p>
<p>Since the largest rank in a structures can be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />, the number of groups must be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Clog%5E%2A%20n" alt="\le \log^* n" title="\le \log^* n" />.</p>
<p>We want to find the charge for <code>find(v)</code>: For each vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" /> on the path from <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> to the root:</p>
<ul>
<li><p>if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" /> has a parent and grandparent, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7Bgroup" alt="\text{group" title="\text{group" />(u)<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7D%20%3D%20%5Ctext%7Bgroup" alt="} = \text{group" title="} = \text{group" />()<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7D" alt="}" title="}" />, then charge 1 to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" />.</p></li>
<li><p>Otherwise, charge 1 to <code>find(v)</code>.</p></li>
</ul>
<p>Thus the total charge to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7Bfind" alt="\text{find" title="\text{find" />(v)<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7D%20%5Cle%20%5Clog%5E%2A%20n%20%2B%201" alt="} \le \log^* n + 1" title="} \le \log^* n + 1" />, since the group changes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Clog%5E%2An%20-%201" alt="\le \log^*n - 1" title="\le \log^*n - 1" /> times, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2" alt="2" title="2" /> more for the root and it’s child.</p>
<p>We now need to determine the charge to individual nodes.</p>
<p>If a vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" /> in group <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=g" alt="g" title="g" /> is charged, then path compression will give it a new parent of higher rank. Therefore a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" /> in group <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=g" alt="g" title="g" /> is charged <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%28g%29" alt="c(g)" title="c(g)" /> times until its parent is in a higher group. We know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%28g%29%20%5Cle%202%20%5Cuparrow%20g" alt="c(g) \le 2 \uparrow g" title="c(g) \le 2 \uparrow g" />.</p>
<p>The total charge to all nodes in a group <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=g" alt="g" title="g" /> is:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%28%5Ctext%7Bnumber%20of%20ranks%20in%20%24g%24%7D%29%28%5Ctext%7Bnumber%20of%20nodes%20in%20%24g%24%7D%29%20%26%3D%20c%28g%29N%28g%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20N%28g%29%20%26%5Cle%20%5Csum_%7Br%20%3D%202%5Cuparrow%28g-1%29%2B1%7D%5E%7B2%20%5Cuparrow%20g%7D%20%5Cfrac%7Bn%7D%7B2%5Er%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%5Cfrac%7Bn%7D%7B2%5E%7B2%20%5Cuparrow%28g-1%29%2B1%7D%7D%20%5Csum_%7Bi%3D0%7D%5E%5Cinfty%20%5Cfrac%7B1%7D%7B2%5Ei%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%5Cfrac%7Bn%7D%7B2%20%5Cuparrow%20g%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cimplies%20c%28g%29N%28g%29%20%26%5Cle%20n%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    (\text{number of ranks in $g$})(\text{number of nodes in $g$}) &amp;= c(g)N(g) \\
                    N(g) &amp;\le \sum_{r = 2\uparrow(g-1)+1}^{2 \uparrow g} \frac{n}{2^r} \\
                    &amp;\le \frac{n}{2^{2 \uparrow(g-1)+1}} \sum_{i=0}^\infty \frac{1}{2^i} \\
                    &amp;\le \frac{n}{2 \uparrow g} \\
                    \implies c(g)N(g) &amp;\le n
                \end{aligned}" title="\begin{aligned}
                    (\text{number of ranks in $g$})(\text{number of nodes in $g$}) &amp;= c(g)N(g) \\
                    N(g) &amp;\le \sum_{r = 2\uparrow(g-1)+1}^{2 \uparrow g} \frac{n}{2^r} \\
                    &amp;\le \frac{n}{2^{2 \uparrow(g-1)+1}} \sum_{i=0}^\infty \frac{1}{2^i} \\
                    &amp;\le \frac{n}{2 \uparrow g} \\
                    \implies c(g)N(g) &amp;\le n
                \end{aligned}" /><br /></p>
<p>Thus the total charge to all nodes is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%5Clog%5E%2A%20n" alt="n \log^* n" title="n \log^* n" />.</p>
<p>For Kruskal’s algorithm, we find the total charge to <code>finds</code> and <code>nodes</code> as:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20O%28m%20%28%5Clog%5E%2An%20%2B%201%29%20%2B%20n%20%5Clog%5E%2A%20n%29%20%26%3D%20O%28m%20%5Clog%5E%2A%20n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    O(m (\log^*n + 1) + n \log^* n) &amp;= O(m \log^* n)
                \end{aligned}" title="\begin{aligned}
                    O(m (\log^*n + 1) + n \log^* n) &amp;= O(m \log^* n)
                \end{aligned}" /><br /></p>
<p>Not bad.</p>
<h1 id="cha:geometric_data_structures">Geometric Data Structures</h1>
<p>So far data structures have been implemented with comparable keys.</p>
<p>When working in higher dimensions, we have two main problem types:</p>
<ul>
<li><p>Find points inside a region</p></li>
<li><p>Find regions containing a point</p></li>
</ul>
<h2 id="sec:range_search">Range Search</h2>
<p>By preprocessing <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> points in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> dimensions, so we can handle range queries. In 2D, this would be querying for points contained within a rectangle.</p>
<p>We have 3 main measures for range search methods:</p>
<dl>
<dt>P</dt>
<dd><p>the preprocessing time</p>
</dd>
<dt>S</dt>
<dd><p>the space taken for preprocessing</p>
</dd>
<dt>Q</dt>
<dd><p>the query time</p>
</dd>
<dt>U</dt>
<dd><p>the update time (only some algorithms can have updated data)</p>
</dd>
</dl>
<h3 id="sub:range_queries_for_k_1">Range Queries for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%3D1" alt="k=1" title="k=1" /></h3>
<p>When <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%3D1" alt="k=1" title="k=1" />, we sort data and use binary searches. Thus we have:</p>
<dl>
<dt>P</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%29" alt="O(n \log n)" title="O(n \log n)" /></p>
</dd>
<dt>S</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /></p>
</dd>
<dt>Q</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%20%2B%20t%29" alt="O(\log n + t)" title="O(\log n + t)" />, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" /> is the output size.</p>
</dd>
<dt>U</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /></p>
</dd>
</dl>
<h3 id="sub:range_queries_for_k_2">Range Queries for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%3D2" alt="k=2" title="k=2" /></h3>
<p>We have a few cool implementations, most of which are covered in CS240.</p>
<h4 id="ssub:quad_tree">Quad Tree</h4>
<p>Divide squares into four subsquares, repeat until each square has <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%280%2C%201%29" alt="(0, 1)" title="(0, 1)" /> points.</p>
<h4 id="ssub:kd_tree"><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />d-Tree</h4>
<p>Divide points in half vertically then horizontally (then recurse).</p>
<dl>
<dt>P</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%29" alt="O(n \log n)" title="O(n \log n)" /></p>
</dd>
<dt>S</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /></p>
</dd>
<dt>Q</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CTheta%28%5Csqrt%7Bn%7D%20%2B%20t%29" alt="\Theta(\sqrt{n} + t)" title="\Theta(\sqrt{n} + t)" />, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" /> is the output size.</p>
</dd>
</dl>
<h4 id="ssub:range_trees">Range Trees</h4>
<p>See the subsection on Range trees below.</p>
<h3 id="sub:range_trees_for_k_2">Range Trees for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%3D2" alt="k=2" title="k=2" /></h3>
<p>A <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />th dimension range tree improves <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Q" alt="Q" title="Q" /> at the expense of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" />. It uses a binary search tree across one dimension, where each internal node has an additional <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n-1" alt="n-1" title="n-1" />-dimension range tree.</p>
<p>A <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%3D1" alt="k=1" title="k=1" />-dimension range tree is a sorted list.</p>
<dl>
<dt>P</dt>
<dd><p>sort by <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />, then sort by <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" /> and do some work - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%29" alt="O(n \log n)" title="O(n \log n)" /></p>
</dd>
<dt>S</dt>
<dd><p>each point occurs in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%20n" alt="\log n" title="\log n" /> of the sorted-by-<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" /> lists - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%29" alt="O(n \log n)" title="O(n \log n)" /></p>
</dd>
<dt>Q</dt>
<dd><p>search for the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_l" alt="x_l" title="x_l" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_r" alt="x_r" title="x_r" /> in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> time. For all children of paths to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_l" alt="x_l" title="x_l" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_r" alt="x_r" title="x_r" />, we search the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" /> list - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%5E2%20n%20%2B%20t%29" alt="O(\log^2 n + t)" title="O(\log^2 n + t)" /></p>
</dd>
</dl>
<h4 id="ssub:fractional_cascading">Fractional Cascading</h4>
<p>We can improve <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Q" alt="Q" title="Q" /> to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%20%2B%20t%29" alt="O(\log n + t)" title="O(\log n + t)" /> by using a technique called fractional cascading.</p>
<p>Generally, we keep a pointer from each element in the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />’s list to the corresponding element in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" />’s list. This gives us <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Q%20%3D%20%28%5Clog%20n%20%2B%20t%29" alt="Q = (\log n + t)" title="Q = (\log n + t)" />, since we binary search for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y_U%2C%20y_L" alt="y_U, y_L" title="y_U, y_L" /> in the list of root and follow pointers.</p>
<h2 id="sec:point_location">Point Location</h2>
<p>Given a set of disjoint regions in a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-dimensional space, we want to quickly respond to queries that query the location they are in. This can help with queries like: which city is coordinate <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28a%2Cb%29" alt="(a,b)" title="(a,b)" /> in? Where is the nearest Tim Hortons? etc.</p>
<h3 id="sub:point_location_for_k_1_dimension">Point Location for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%3D1" alt="k=1" title="k=1" /> Dimension</h3>
<p>In <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1" alt="1" title="1" />d, we use a balanced binary search tree.</p>
<dl>
<dt>P</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%29" alt="O(n \log n)" title="O(n \log n)" /></p>
</dd>
<dt>S</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /></p>
</dd>
<dt>Q</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /></p>
</dd>
</dl>
<h3 id="sub:point_location_for_k_2_dimensions">Point Location for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%3D2" alt="k=2" title="k=2" /> dimensions</h3>
<p>We can divide the entire space into slabs by adding a vertical line at every point.</p>
<p>Then given a query point <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />, find the correct slab (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" />) then binary search by <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" /> (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" />).</p>
<dl>
<dt>Q</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /></p>
</dd>
<dt>S</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CTheta%28n%5E2%29" alt="\Theta(n^2)" title="\Theta(n^2)" /> (ew)</p>
</dd>
</dl>
<h4 id="ssub:less_space_through_persistent_data_structures">Less Space Through Persistent Data Structures</h4>
<p>Given that in one slab to the next, very few changes, we only need to make a BST for the leftmost slab and update for subsequent slabs.</p>
<p>The total number of updates to the BST is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" />, since every segment is inserted and deleted exactly once.</p>
<p>If we update a BST and search it in the past, this idea is called a “persistent data structure”.</p>
<dl>
<dt>Partial persistence</dt>
<dd><p>allows queries in the past and only the present be changed.</p>
</dd>
<dt>Full persistence</dt>
<dd><p>allows queries and changes at any point in time.</p>
</dd>
</dl>
<p>Using Driscoll, …, Tarjan `89, we can add partial persistence to any data structure.</p>
<p>This gives us a planar point location of:</p>
<dl>
<dt>P</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%29" alt="O(n \log n)" title="O(n \log n)" /></p>
</dd>
<dt>S</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /></p>
</dd>
<dt>Q</dt>
<dd><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /></p>
</dd>
</dl>
<p>In an awesome way, this runs in the same time as the initial 1D problem.</p>
<h1 id="cha:randomized_algorithms">Randomized Algorithms</h1>
<p>Algorithms that use random numbers have their and/or their depend on random numbers. This forces us to use amortized (expected) analysis.</p>
<p>Practicaly speaking, it gets us easier and faster algorithms. Theoretically speaking, it’s <span><span style="font-variant: small-caps;">open</span></span>whether randomization helps for <span><span style="font-variant: small-caps;">P</span></span>vs <span><span style="font-variant: small-caps;">NP</span></span>, but we’ll see an example where it’ll help a tiny bit.</p>
<p>In previous classes, we’ve seen QuickSort<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a> and SkipLists.</p>
<p>We define randomized algorithms as ones that execute either method <code>rand[1, ..., n]</code> or <code>rand[0, 1]</code>, both of which run in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281%29" alt="O(1)" title="O(1)" /> time<a href="#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a>.</p>
<p>Thus, the running time for fixed input depends on random numbers - i.e. a .</p>
<p>A few definitions are necessary:</p>
<dl>
<dt>Sample Space</dt>
<dd><p>is the space of all possible outcomes (for fixed input).</p>
</dd>
<dt>Random Variables</dt>
<dd><p>map the sample space to real numbers (at runtime).</p>
</dd>
</dl>
<p>We need to rely on some stats for the upcoming parts. See Section [sec:expected<sub>v</sub>alues<sub>s</sub>tatistics] for expected knowledge.</p>
<p>We set the function <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28I%29" alt="T(I)" title="T(I)" /> as the time it takes depending on the random variable <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=I" alt="I" title="I" />. Obviously, we set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E%28T%28I%29%29" alt="E(T(I))" title="E(T(I))" /> as the expected runtime across all possible values of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=I" alt="I" title="I" />.</p>
<p>We then say that the function<a href="#fn19" class="footnoteRef" id="fnref19"><sup>19</sup></a><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28n%29" alt="T(n)" title="T(n)" /> is the maximum of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E%28T%28I%29%29" alt="E(T(I))" title="E(T(I))" /> across all <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=I" alt="I" title="I" />’s.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T%28n%29%20%26%3D%20%5Cmax_%7B%7CI%7C%20%3D%20n%7D%20E%28T%28I%29%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                T(n) &amp;= \max_{|I| = n} E(T(I))
            \end{aligned}" title="\begin{aligned}
                T(n) &amp;= \max_{|I| = n} E(T(I))
            \end{aligned}" /><br /></p>
<h2 id="sec:selection">Selection</h2>
<p>Given a set of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> numbers <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" />, we’d like to return the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-th smallest element of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" />.</p>
<p>For example:</p>
<ul>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%3D%201" alt="k = 1" title="k = 1" /> is the min</p></li>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%3D%202" alt="k = 2" title="k = 2" /> is the 2nd min</p></li>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%3D%20n" alt="k = n" title="k = n" /> is the max</p></li>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%3D%20%7B%5Cleft%20%5Clfloor%20%5Cfrac%7Bn%7D%7B2%7D%20%5Cright%20%5Crfloor%20%7D" alt="k = {\left \lfloor \frac{n}{2} \right \rfloor }" title="k = {\left \lfloor \frac{n}{2} \right \rfloor }" /> is the median</p></li>
</ul>
<p>Let’s implement QuickSelect:</p>
<pre><code>    def QuickSelect(S, k):
        n = |S|
        if n &lt; constant
            Sort(S)
            return kth element
        i = rand(1...n)
        partion S into:
        L = {s : s &lt; S[i]}
        M = {s : s == S[i]}
        R = {s : s &gt; S[i]}
        if k &lt; |L| return QuickSelect(L, k)
        if k &lt;= |L| + m return s[i]
        return QuickSelect(B, k - (|L| + |M|))
                </code></pre>
<p>This is worst-case <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E2%29" alt="O(n^2)" title="O(n^2)" /> when pivot is always the min or the max, but it often isn’t the worst-case.</p>
<p>We can do more detailed analysis to find the expected time of finding it on a set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> of size <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />.</p>
<p>In other words, we want <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E%28T%28n%29%29" alt="E(T(n))" title="E(T(n))" />, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28n%29" alt="T(n)" title="T(n)" /> is a random variable runtime of QuickSelect on a set of size <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />.</p>
<p>We have recursive calls on sets of size <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cell" alt="\ell" title="\ell" /> or <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20-%20%5Cell" alt="n - \ell" title="n - \ell" />. For an upper bound, assume that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> lies in the larger (worse) half of the recursion. In other words, we assume that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%5Cle%20%5Cfrac%7Bn%7D%7B4%7D" alt="k \le \frac{n}{4}" title="k \le \frac{n}{4}" /> or <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%5Cge%20%5Cfrac%7B3n%7D%7B4%7D" alt="k \ge \frac{3n}{4}" title="k \ge \frac{3n}{4}" />. Thus the recursion is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20T%28%5Cfrac%7B3n%7D%7B4%7D%29" alt="\le T(\frac{3n}{4})" title="\le T(\frac{3n}{4})" />.</p>
<p>Assuming that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28i%29%20%5Cle%20T%28j%29" alt="T(i) \le T(j)" title="T(i) \le T(j)" /> for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cle%20j" alt="i \le j" title="i \le j" />, we get:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%28T%28n%29%29%20%26%5Cle%20%5Cfrac%7B1%7D%7B2%7DE%5Cleft%28T%5Cleft%28%5Cfrac%7B3n%7D%7B4%7D%5Cright%29%5Cright%29%20%2B%20%5Cfrac%7B1%7D%7B2%7DE%5Cleft%28T%5Cleft%28n%20-%201%5Cright%29%5Cright%29%20%2B%20O%28n%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20f%5Cleft%28n%5Cright%29%20%26%5Cle%20%5Cfrac%7B1%7D%7B2%7Df%5Cleft%28%5Cfrac%7B3n%7D%7B4%7D%5Cright%29%20%2B%20%5Cfrac%7B1%7D%7B2%7Df%5Cleft%28n%20-%201%5Cright%29%20%2B%20O%28n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    E(T(n)) &amp;\le \frac{1}{2}E\left(T\left(\frac{3n}{4}\right)\right) + \frac{1}{2}E\left(T\left(n - 1\right)\right) + O(n) \\
                    f\left(n\right) &amp;\le \frac{1}{2}f\left(\frac{3n}{4}\right) + \frac{1}{2}f\left(n - 1\right) + O(n)
                \end{aligned}" title="\begin{aligned}
                    E(T(n)) &amp;\le \frac{1}{2}E\left(T\left(\frac{3n}{4}\right)\right) + \frac{1}{2}E\left(T\left(n - 1\right)\right) + O(n) \\
                    f\left(n\right) &amp;\le \frac{1}{2}f\left(\frac{3n}{4}\right) + \frac{1}{2}f\left(n - 1\right) + O(n)
                \end{aligned}" /><br /></p>
<p>We can prove by induction that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f%28n%29%20%3D%20O%28n%29" alt="f(n) = O(n)" title="f(n) = O(n)" />.</p>
<h2 id="sec:random_v_s_non_randomized_algorithms">Random V.S. Non-Randomized Algorithms</h2>
<p>1960 Hoare QuickSelect has <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=3n%20%2B%20o%28n%29" alt="3n + o(n)" title="3n + o(n)" /> expected comparisons<br />1973 BFPRT created a non-randomized selection in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> time, with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=5.43n%20%2B%20o%28n%29" alt="5.43n + o(n)" title="5.43n + o(n)" /> comparisons. This is the same with respect to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" />, but different constant than randomized algorithms.<br />1975 Floyd Rivest created a randomized algorithm that takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1.5n%20%2B%20o%28n%29" alt="1.5n + o(n)" title="1.5n + o(n)" /> expected comparisons.<br />1989 Munro &amp; Cunto proved that any ralgorithm takes at least <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1.5n" alt="1.5n" title="1.5n" /> expected comparisons.<br />1985 [???] proved a lower bound of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2n" alt="2n" title="2n" /> comparisons for non-randomized algorithms. Randomization probably helps.<br /></p>
<p>Currently, our best non-randomized bounds are:</p>
<p>[h]</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Bound</th>
<th style="text-align: left;">Year</th>
<th style="text-align: left;"># comparisons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Upper Bound</td>
<td style="text-align: left;">1999</td>
<td style="text-align: left;">2.95n</td>
</tr>
<tr class="even">
<td style="text-align: left;">Lower Bound</td>
<td style="text-align: left;">2001</td>
<td style="text-align: left;"><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%282%20%2B%20%5Cvarepsilon%29%20n" alt="(2 + \varepsilon) n" title="(2 + \varepsilon) n" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvarepsilon%20%3D%202%5E%7B-80%7D" alt="\varepsilon = 2^{-80}" title="\varepsilon = 2^{-80}" /></td>
</tr>
</tbody>
</table>
<h2 id="sec:lower_bound_on_median">Lower Bound on Median</h2>
<p><strong>Theorem:</strong><a href="#fn20" class="footnoteRef" id="fnref20"><sup>20</sup></a> Finding the median of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> elements takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%201.5n" alt="\ge 1.5n" title="\ge 1.5n" /> comparisons in the worst case.</p>
<p><strong>Proof:</strong><a href="#fn21" class="footnoteRef" id="fnref21"><sup>21</sup></a></p>
<p>Let <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L%20%3D%20%5C%7B%5Ctext%7Belements%20%7D%20%3C%20m%5C%7D" alt="L = \{\text{elements } &lt; m\}" title="L = \{\text{elements } &lt; m\}" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M%20%3D%20%5C%7B%5Ctext%7Belements%20%7D%20%3E%20m%5C%7D" alt="M = \{\text{elements } &gt; m\}" title="M = \{\text{elements } &gt; m\}" />. So that each set has <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7Bn-1%7D%7B2%7D" alt="\frac{n-1}{2}" title="\frac{n-1}{2}" /> elements.</p>
<p>We claim that the number of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L" alt="L" title="L" /> vs <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=H" alt="H" title="H" /> comparisons must be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Cfrac%7Bn-1%7D%7B2%7D" alt="\ge \frac{n-1}{2}" title="\ge \frac{n-1}{2}" /> in the worst case.</p>
<p>We set it up so the adversary answers the comparisons that our algorithm queries. Our adversary consistently answers by “setting” elements to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L" alt="L" title="L" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=H" alt="H" title="H" /> at all times.<a href="#fn22" class="footnoteRef" id="fnref22"><sup>22</sup></a> We can now create an adversary strategy:</p>
<pre><code>def compare(x, y):
    if x and y have been seen before:
        return result of comparison
    if one of (x, y) have been seen:
        put the unseen one in the other set
    if neither are set:
        put x in L, y in H
                </code></pre>
<p>An adversary must stop when <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cmax%28%7CL%7C%2C%20%7CH%7C%29%20%3D%20%5Cfrac%7Bn-1%7D%7B2%7D" alt="\max(|L|, |H|) = \frac{n-1}{2}" title="\max(|L|, |H|) = \frac{n-1}{2}" />, so they can force at most <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7Bn-1%7D%7B2%7D" alt="\frac{n-1}{2}" title="\frac{n-1}{2}" /> comparisons.</p>
<p>Since there are always <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20n-1" alt="\ge n-1" title="\ge n-1" /> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L" alt="L" title="L" /> vs <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=H" alt="H" title="H" /> comparisons, and the adversary can force an additional <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Cfrac%7Bn-1%7D%7B2%7D" alt="\ge \frac{n-1}{2}" title="\ge \frac{n-1}{2}" /> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L" alt="L" title="L" /> vs <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=H" alt="H" title="H" /> comparisons, the overall algorithm must make <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%201.5n" alt="\ge 1.5n" title="\ge 1.5n" /> comparisons in the worst case.</p>
<h3 id="sub:on_non_randomized_selection_algorithm"><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> Non-Randomized Selection Algorithm</h3>
<p>The idea here is that we divide sets of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> elements into groups of 5, then find the median of each group. We then execute a recursive call to find a median of medians <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" />. This guarantees <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> between <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B3n%7D%7B10%7D" alt="\frac{3n}{10}" title="\frac{3n}{10}" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B7n%7D%7B10%7D" alt="\frac{7n}{10}" title="\frac{7n}{10}" /> in rank. We get the recurrence:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T%28n%29%20%26%3D%20T%5Cleft%28%5Cfrac%7Bn%7D%7B5%7D%5Cright%29%20%2B%20T%5Cleft%28%5Cfrac%7B7n%7D%7B10%7D%5Cright%29%20%2B%20O%28n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        T(n) &amp;= T\left(\frac{n}{5}\right) + T\left(\frac{7n}{10}\right) + O(n)
                    \end{aligned}" title="\begin{aligned}
                        T(n) &amp;= T\left(\frac{n}{5}\right) + T\left(\frac{7n}{10}\right) + O(n)
                    \end{aligned}" /><br /></p>
<p>We can prove that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28n%29%20%3D%20O%28n%29" alt="T(n) = O(n)" title="T(n) = O(n)" />.<a href="#fn23" class="footnoteRef" id="fnref23"><sup>23</sup></a></p>
<p>For more information, look up the <a href="https://en.wikipedia.org/wiki/Median_of_medians">“median of medians”</a> algorithm online.</p>
<h1 id="cha:primality_testing">Primality Testing</h1>
<h2 id="sec:randomized_algorithm_types">Randomized Algorithm Types</h2>
<p>There are two kinds of randomized algorithms:</p>
<h3 id="sub:las_vegas">Las Vegas Type Algorithms</h3>
<p>Las Vegas algorithms always return the correct output, and have good expected runtime. An example of this type of algorithm is quicksort.</p>
<p>We can convert Las Vegas to Monte Carlo algorithms by stopping after some time and outputting a junk answer.</p>
<h3 id="sub:monte_carlo_type">Monte Carlo Type Algorithms</h3>
<p>Monte Carlo algorithms are quick with a high probability of success, and have a good guaranteed runtime.</p>
<p>If we have a fast correctness test we can convert Monte Carlo algorithms to Las Vegas algorithms, repeating the algorithm if output isn’t correct.</p>
<h2 id="sec:primality_testing_using_a_monte_carlo_algorithm">Primality Testing Using a Monte Carlo Algorithm</h2>
<p>Given an odd number <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />, is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> composite?<a href="#fn24" class="footnoteRef" id="fnref24"><sup>24</sup></a> Phrased this way, we have a decision problem in <span><span style="font-variant: small-caps;">NP</span></span>, which is verifying <code>YES</code> answers.</p>
<p>It is important to know that while the input is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />, the input size is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%28n%29" alt="\log(n)" title="\log(n)" /> – the number of bits used expressing <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />. Thus trial division (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Csqrt%7Bn%7D%29" alt="O(\sqrt{n})" title="O(\sqrt{n})" /> time) is not poly-time.<a href="#fn25" class="footnoteRef" id="fnref25"><sup>25</sup></a></p>
<p>We use the following theorem to help us with our solutions:</p>
<h3 id="sub:fermat_s_little_theorem">Fermat’s Little Theorem</h3>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p" alt="p" title="p" /> is prime, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cforall%200%20%3C%20a%20%3C%20p" alt="\forall 0 &lt; a &lt; p" title="\forall 0 &lt; a &lt; p" />: <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a%5E%7Bp-1%7D%20%5Cequiv%201%20%5Cmod%20p" alt="a^{p-1} \equiv 1 \mod p" title="a^{p-1} \equiv 1 \mod p" />.</p>
<p>We can prove this by showing:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20a%5Ep%28p-1%29%21%20%5Cequiv%20%28p-1%29%21%20%5Cmod%20p%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20a%5Ep%20%5Cequiv%201%20%5Cmod%20p%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        a^p(p-1)! \equiv (p-1)! \mod p \\
                        a^p \equiv 1 \mod p
                    \end{aligned}" title="\begin{aligned}
                        a^p(p-1)! \equiv (p-1)! \mod p \\
                        a^p \equiv 1 \mod p
                    \end{aligned}" /><br /></p>
<p>The contrapositive<a href="#fn26" class="footnoteRef" id="fnref26"><sup>26</sup></a> states that whenever <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a%5E%7Bn-1%7D%20%5Cnot%20%5Cequiv%201%20%5Cmod%20n" alt="a^{n-1} \not \equiv 1 \mod n" title="a^{n-1} \not \equiv 1 \mod n" /> doesn’t hold for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0%20%3C%20a%20%3C%20n" alt="0 &lt; a &lt; n" title="0 &lt; a &lt; n" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a" alt="a" title="a" /> is a <em>Fermat Witness</em> to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> being composite.</p>
<h3 id="sub:prime_testing">Prime-Testing</h3>
<p>The idea is to test <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> being composite using randomly-generated <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a" alt="a" title="a" /> in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5B1%2C%20%5Cldots%2C%20n-1%5D" alt="[1, \ldots, n-1]" title="[1, \ldots, n-1]" /> for being a Fermat witness.</p>
<p>If it is, then <span style="font-variant: small-caps;">yes</span> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is composite. If it isn’t, then <span style="font-variant: small-caps;">maybe</span> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is prime.</p>
<p>The bad news is that there are composite numbers Fermat witnesses<a href="#fn27" class="footnoteRef" id="fnref27"><sup>27</sup></a>.</p>
<p>Where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n-1%20%3D%202%5Et%20u" alt="n-1 = 2^t u" title="n-1 = 2^t u" /> (for an odd <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" />), we need a that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is prime. We define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a%20%5Cin%20%5B1%2C%20n-1%5D" alt="a \in [1, n-1]" title="a \in [1, n-1]" /> as a strong witness of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> being composite if for some <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0%20%5Cle%20i%20%3C%20t" alt="0 \le i &lt; t" title="0 \le i &lt; t" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%3D%202%5Ei%20u" alt="k = 2^i u" title="k = 2^i u" />:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20a%5Ek%20%5Cnot%20%5Cequiv%201%20%2C%20-1%20%5Cmod%20n%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20a%5E%7B2k%7D%20%5Cequiv%201%20%5Cmod%20n%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        a^k \not \equiv 1 , -1 \mod n \\
                        a^{2k} \equiv 1 \mod n
                    \end{aligned}" title="\begin{aligned}
                        a^k \not \equiv 1 , -1 \mod n \\
                        a^{2k} \equiv 1 \mod n
                    \end{aligned}" /><br /></p>
<p>In CLRS, they prove that if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is prime, there are no strong witnesses; they also prove that if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is composite, there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Cfrac%7Bn-1%7D%7B2%7D" alt="\ge \frac{n-1}{2}" title="\ge \frac{n-1}{2}" /> strong witnesses.</p>
<h3 id="sub:implementation">Implementation</h3>
<pre><code>witness (a , n):
u = n - 1 % 2
t = log((n - 1) / u) // base 2
x[0] =  a ^ u mod n
for i = 1 ... t:
    x[i] = x[i-1]^2 mod n
    if (x[i] == 1 and x[i-1] != 1 and x[i-1] != n - 1):
        return true // a is a strong witness to n being composite
return x[t] != 1 // a is a Fermat witness to n being composite
                    </code></pre>
<p>The runtime of this algorithm is polynomial in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%20n" alt="\log n" title="\log n" />.</p>
<h3 id="sub:miller_rabin_algorithm">Miller-Rabin Algorithm</h3>
<p>The idea of this algorithm is to test <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s" alt="s" title="s" /> times that random numbers aren’t witnesses to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> being composite.</p>
<pre><code>isComposite(n):
    for i = 1 ... s:
        x = rand(1...n-1)
        if (witness(x, n)):
            return YES // n is composite
    return MAYBE // n is prime
                    </code></pre>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is prime, the algorithm is always correct. IF <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is composite however, we can tabulate the probability it is unsure:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Pr%5C%7B%20%5Ctext%7BAlg%20outputs%20%5Ctextsc%7Bmaybe%7D%7D%5C%7D%20%26%3D%20Pr%5Cleft%5C%7B%20%5Ccap_%7Bj%3D1%7D%5Es%20%5Cleft%5C%7B%5Ctext%7Bat%20trial%20%24j%24%2C%20%24x%24%20is%20not%20a%20strong%20witness%20%7D%20%5Cright%5C%7D%20%5Cright%5C%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B1%7D%7B2%5Es%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        Pr\{ \text{Alg outputs \textsc{maybe}}\} &amp;= Pr\left\{ \cap_{j=1}^s \left\{\text{at trial $j$, $x$ is not a strong witness } \right\} \right\} \\
                        &amp;= \frac{1}{2^s}
                    \end{aligned}" title="\begin{aligned}
                        Pr\{ \text{Alg outputs \textsc{maybe}}\} &amp;= Pr\left\{ \cap_{j=1}^s \left\{\text{at trial $j$, $x$ is not a strong witness } \right\} \right\} \\
                        &amp;= \frac{1}{2^s}
                    \end{aligned}" /><br /></p>
<p>This is a Monte-Carlo algorithm with a <a href="#fn28" class="footnoteRef" id="fnref28"><sup>28</sup></a>.</p>
<h2 id="sec:complexity_classes">Complexity Classes</h2>
<p>We can define a number of decision classes:</p>
<dl>
<dt><span><span style="font-variant: small-caps;">P</span></span></dt>
<dd><p>are the decision problems solvable in polynomial time. These are also known as the class of languages <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L" alt="L" title="L" /> accepted in polynomial time.</p>
</dd>
<dt><span><span style="font-variant: small-caps;">NP</span></span></dt>
<dd><p>are the class of languages <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L" alt="L" title="L" /> accepted in non-deterministic polynomial time. These are also known as the decision problems that can be in polynomial time<a href="#fn29" class="footnoteRef" id="fnref29"><sup>29</sup></a>.</p>
</dd>
</dl>
<p>There are a few<a href="#fn30" class="footnoteRef" id="fnref30"><sup>30</sup></a> <span><span style="font-variant: small-caps;">open</span></span>problems about this<a href="#fn31" class="footnoteRef" id="fnref31"><sup>31</sup></a>:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D%26%5Cstackrel%7B%3F%7D%7B%3D%7D%20%5Ctextsc%7Bco-np%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7BP%7D%5Cxspace%7D%26%5Cstackrel%7B%3F%7D%7B%3D%7D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7BP%7D%5Cxspace%7D%26%5Cstackrel%7B%3F%7D%7B%3D%7D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D%5Ccup%20%5Ctextsc%7Bco-np%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7BP%7D%5Cxspace%7D%26%5Cstackrel%7B%3F%7D%7B%3D%7D%20%5Ctextsc%7Brp%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctextsc%7Brp%7D%20%26%5Cstackrel%7B%3F%7D%7B%3D%7D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D%5Cend%7Baligned%7D" alt="\begin{aligned}
                    {\textsc{NP}\xspace}&amp;\stackrel{?}{=} \textsc{co-np} \\
                    {\textsc{P}\xspace}&amp;\stackrel{?}{=} {\textsc{NP}\xspace}\\
                    {\textsc{P}\xspace}&amp;\stackrel{?}{=} {\textsc{NP}\xspace}\cup \textsc{co-np} \\
                    {\textsc{P}\xspace}&amp;\stackrel{?}{=} \textsc{rp} \\
                    \textsc{rp} &amp;\stackrel{?}{=} {\textsc{NP}\xspace}\end{aligned}" title="\begin{aligned}
                    {\textsc{NP}\xspace}&amp;\stackrel{?}{=} \textsc{co-np} \\
                    {\textsc{P}\xspace}&amp;\stackrel{?}{=} {\textsc{NP}\xspace}\\
                    {\textsc{P}\xspace}&amp;\stackrel{?}{=} {\textsc{NP}\xspace}\cup \textsc{co-np} \\
                    {\textsc{P}\xspace}&amp;\stackrel{?}{=} \textsc{rp} \\
                    \textsc{rp} &amp;\stackrel{?}{=} {\textsc{NP}\xspace}\end{aligned}" /><br /></p>
<h3 id="sub:randomized_polynomial_time_one_sided_monte_carlo">Randomized Polynomial Time, One Sided Monte-Carlo</h3>
<p>The <span style="font-variant: small-caps;">rp</span> class of problems is the class of languages that have a randomized algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> running in worst-case polynomial time such that for any input <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20x%20%5Cin%20L%20%5Cimplies%20Pr%5B%5Ctext%7B%24A%28x%29%24%20accepts%7D%5D%20%26%20%5Cge%20%5Cfrac%7B1%7D%7B2%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20x%20%5Cnot%20%5Cin%20L%20%5Cimplies%20Pr%5B%5Ctext%7B%24A%28x%29%24%20accepts%7D%5D%20%26%20%3D%200%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        x \in L \implies Pr[\text{$A(x)$ accepts}] &amp; \ge \frac{1}{2} \\
                        x \not \in L \implies Pr[\text{$A(x)$ accepts}] &amp; = 0
                    \end{aligned}" title="\begin{aligned}
                        x \in L \implies Pr[\text{$A(x)$ accepts}] &amp; \ge \frac{1}{2} \\
                        x \not \in L \implies Pr[\text{$A(x)$ accepts}] &amp; = 0
                    \end{aligned}" /><br /></p>
<p>In other words, the algorithm always returns no for input <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> that don’t match, and <em>sometimes</em> returns yes for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> that match <a href="#fn32" class="footnoteRef" id="fnref32"><sup>32</sup></a>.</p>
<p>We know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%5Csubseteq%20%5Ctextsc%7Brp%7D" alt="{\textsc{P}\xspace}\subseteq \textsc{rp}" title="{\textsc{P}\xspace}\subseteq \textsc{rp}" />, since the probabilities that <span><span style="font-variant: small-caps;">P</span></span>problems will accept and decline are 0 and 1 respectively.</p>
<p>Supposing language <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L" alt="L" title="L" /> is in <span style="font-variant: small-caps;">rp</span>, i.e. there is a randomized algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> that fits the definitions of <span style="font-variant: small-caps;">rp</span>. <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> depends on <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> and random choices. If we think of the random choices as a string <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" /> of random bits, we write <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%28x%2C%20y%29" alt="A(x, y)" title="A(x, y)" /> as applying <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> on <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> with random bits <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" />. Since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> runs in polynomial with respect to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7Cx%7C" alt="|x|" title="|x|" /> (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%20%5Cin%20p%28%7Cx%7C%29" alt="A \in p(|x|)" title="A \in p(|x|)" />), we know that the string <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y%20%5Cin%20p%28%7Cx%7C%29" alt="y \in p(|x|)" title="y \in p(|x|)" />. Using <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> as the verification algorithm and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" /> as the certificate, we can show that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L" alt="L" title="L" /> is in <span><span style="font-variant: small-caps;">NP</span></span>.</p>
<h3 id="sub:zero_error_probabilistic_polynomial_time">Zero Error Probabilistic Polynomial Time</h3>
<p><span style="font-variant: small-caps;">zpp</span> is the class of languages accepted by Las Vegas algorithms with an expected polynomial runtime.</p>
<p>Note that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%5Csubseteq%20%5Ctextsc%7Bzpp%7D%20%5Csubseteq%20%5Ctextsc%7Brp%7D" alt="{\textsc{P}\xspace}\subseteq \textsc{zpp} \subseteq \textsc{rp}" title="{\textsc{P}\xspace}\subseteq \textsc{zpp} \subseteq \textsc{rp}" />.</p>
<p>An in-class quiz consisted in proving that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctextsc%7Bzpp%7D%20%3D%20%5Ctextsc%7Brp%7D%20%5Ccap%20%5Ctext%7Bco-%7D%5Ctextsc%7Brp%7D" alt="\textsc{zpp} = \textsc{rp} \cap \text{co-}\textsc{rp}" title="\textsc{zpp} = \textsc{rp} \cap \text{co-}\textsc{rp}" /> is true.</p>
<p>See <a href="https://en.wikipedia.org/wiki/RP_(complexity)">here for more details</a> on the co-<span style="font-variant: small-caps;">rp</span> complexity class.</p>
<h3 id="sub:open_questions">Open Questions</h3>
<p>It is <span><span style="font-variant: small-caps;">open</span></span>if these containments are proper, or if they can be made more precise:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7BP%7D%5Cxspace%7D%5Csubseteq%20%5Ctextsc%7Brp%7D%20%5Csubseteq%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D%5Cend%7Baligned%7D" alt="\begin{aligned}
                        {\textsc{P}\xspace}\subseteq \textsc{rp} \subseteq {\textsc{NP}\xspace}\end{aligned}" title="\begin{aligned}
                        {\textsc{P}\xspace}\subseteq \textsc{rp} \subseteq {\textsc{NP}\xspace}\end{aligned}" /><br /></p>
<h1 id="cha:finger_printing_for_pattern_matching_and_polynomial_identities">Finger-Printing - Pattern Matching and Polynomial Identities</h1>
<h2 id="sec:string_equality">String Equality</h2>
<p>It’s pretty expensive to compare strings, especially if they’re long, stored in separate locations, etc. We compare a smaller fingerprint <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> is an <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />-bit binary number (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%20%3C%202%5En" alt="x &lt; 2^n" title="x &lt; 2^n" />). For a randomly chosen <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p%20%5Cin%20%5C%7B%201%20%5Cldots%20M%20%5C%7D" alt="p \in \{ 1 \ldots M \}" title="p \in \{ 1 \ldots M \}" /><a href="#fn33" class="footnoteRef" id="fnref33"><sup>33</sup></a>, we can set:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20H_p%20%28x%29%20%26%3D%20x%20%5Cmod%20p%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    H_p (x) &amp;= x \mod p
                \end{aligned}" title="\begin{aligned}
                    H_p (x) &amp;= x \mod p
                \end{aligned}" /><br /></p>
<p>While <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%20%3D%20y" alt="x = y" title="x = y" /> implies <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=H_p%28x%29%20%3D%20H_p%28y%29" alt="H_p(x) = H_p(y)" title="H_p(x) = H_p(y)" />, this contrapositive doesn’t hold true if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p" alt="p" title="p" /> divides <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7Cx%20-%20y%7C" alt="|x - y|" title="|x - y|" />.</p>
<p>With repeated (in)equality testing of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=H_p%28x%29" alt="H_p(x)" title="H_p(x)" /> to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=H_p%28y%29" alt="H_p(y)" title="H_p(y)" />, we can build confidence about <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%20%5Cstackrel%7B%3F%7D%7B%3D%7D%20y" alt="x \stackrel{?}{=} y" title="x \stackrel{?}{=} y" />. Our algorithm will know for sure when <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%20%5Cne%20y" alt="x \ne y" title="x \ne y" />, but it can’t be sure they are equal. Thus this is a Monte-Carlo Algorithm.</p>
<p>To better analyze our algorithm, we want to define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Pr%5C%7B%5Ctext%7Bfailure%7D%5C%7D" alt="Pr\{\text{failure}\}" title="Pr\{\text{failure}\}" />. If we define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cpi%28n%29" alt="\pi(n)" title="\pi(n)" /> as the number of primes less than <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cpi%28n%29%20%5Capprox%20%5Cfrac%7Bn%7D%7B%5Cln%20n%7D" alt="\pi(n) \approx \frac{n}{\ln n}" title="\pi(n) \approx \frac{n}{\ln n}" /><a href="#fn34" class="footnoteRef" id="fnref34"><sup>34</sup></a>. Another result from number theory dictates that the number of prime divisors of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%20%3C%202%5En" alt="A &lt; 2^n" title="A &lt; 2^n" /> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cpi%28n%29" alt="\pi(n)" title="\pi(n)" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Pr%5C%7B%5Ctext%7Bfailure%7D%5C%7D%20%26%3D%20%5Cfrac%7B%5Ctext%7Bnumber%20of%20primes%20%24p%20%3C%20M%24%20and%20%24p%24%20divides%20%24%7Cx-y%7C%20%3C%202%5En%24%7D%7D%7B%5Cpi%28M%29%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B%5Cpi%28n%29%7D%7B%5Cpi%28M%29%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    Pr\{\text{failure}\} &amp;= \frac{\text{number of primes $p &lt; M$ and $p$ divides $|x-y| &lt; 2^n$}}{\pi(M)} \\
                    &amp;= \frac{\pi(n)}{\pi(M)}
                \end{aligned}" title="\begin{aligned}
                    Pr\{\text{failure}\} &amp;= \frac{\text{number of primes $p &lt; M$ and $p$ divides $|x-y| &lt; 2^n$}}{\pi(M)} \\
                    &amp;= \frac{\pi(n)}{\pi(M)}
                \end{aligned}" /><br /></p>
<p>If we pick <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M%20%3D%20n%5E2" alt="M = n^2" title="M = n^2" />, then we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Pr%5C%7B%5Ctext%7Bfailure%7D%5C%7D" alt="Pr\{\text{failure}\}" title="Pr\{\text{failure}\}" />:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Pr%5C%7B%5Ctext%7Bfailure%7D%5C%7D%20%26%3D%20%5Cfrac%7Bn%7D%7B%5Cln%20n%7D%20%5Cfrac%7B%5Cln%20n%5E2%7D%7Bn%5E2%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B2%7D%7Bn%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    Pr\{\text{failure}\} &amp;= \frac{n}{\ln n} \frac{\ln n^2}{n^2} \\
                    &amp;= \frac{2}{n}
                \end{aligned}" title="\begin{aligned}
                    Pr\{\text{failure}\} &amp;= \frac{n}{\ln n} \frac{\ln n^2}{n^2} \\
                    &amp;= \frac{2}{n}
                \end{aligned}" /><br /></p>
<h2 id="sec:pattern_matching">Pattern Matching</h2>
<p>We can use a similar idea as string matching for pattern matching:</p>
<p>Given a test string <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> and a pattern string <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> (where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CT%7C%20%3D%20n" alt="|T| = n" title="|T| = n" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CP%7C%20%3D%20m" alt="|P| = m" title="|P| = m" />), does <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> appear as a substring of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" />?</p>
<p>There’s a straightforward <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28nm%29" alt="O(nm)" title="O(nm)" /> solution<a href="#fn35" class="footnoteRef" id="fnref35"><sup>35</sup></a>.</p>
<h3 id="sub:rabin_karp_algorithm">Rabin-Karp Algorithm</h3>
<p><strong>Rabin-Karp</strong> supplies a simple and efficient randomized algorithm.</p>
<p>Suppose <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> are binary strings. We want to compare the fingerprint of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> to fingerprints of successive substrings of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" />.</p>
<p>Using a “rolling hash”, these fingerprints in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> can be computed very efficiently<a href="#fn36" class="footnoteRef" id="fnref36"><sup>36</sup></a>.</p>
<pre><code>def hasMatch(text T, text P):
    p = randomPrime(1 ... m)
    compute Hp(P)
    compute Hp(T[1 ... m])
    for i in range(1 ... n-m+1):
        if Hp(P) == Hp(T[i ... i+m-1])
            return PROBABLE_MATCH
    output NO_MATCH
                    </code></pre>
<p>We have the runtime of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%2B%20m%29" alt="O(n + m)" title="O(n + m)" /> arithmetic operations. We are more concerned about the failure rate - the probability that we output <span style="font-variant: small-caps;">Probable_Match</span> without there being a real match. Iff <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p" alt="p" title="p" /> divides<a href="#fn37" class="footnoteRef" id="fnref37"><sup>37</sup></a> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CP%20-%20T%5Bi%20%5Cldots%20i%2Bm%20-1%5D%7C" alt="|P - T[i \ldots i+m -1]|" title="|P - T[i \ldots i+m -1]|" /> for some <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p" alt="p" title="p" /> divides <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPi_i%20%7CP%20-%20T%5Bi%20%5Cldots%20i%2Bm%20-%201%5D%20%5Cle%202%5E%7Bnm%7D" alt="\Pi_i |P - T[i \ldots i+m - 1] \le 2^{nm}" title="\Pi_i |P - T[i \ldots i+m - 1] \le 2^{nm}" />.</p>
<p>Thus, the following of failure is: (and to recap...)</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%20%5Ctext%7B%24p%24%20divides%20%7D%20%7CP%20-%20T%5Bi%20%5Cldots%20i%20%2B%20m%20-%201%5D%20%5Ctext%7B%20for%20some%20%24i%24%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cimplies%20%26%20%5Ctext%7B%24p%24%20divides%20%7D%20%5CPi_i%20%7CP%20-%20T%5Bi%20%5Cldots%20i%20%2B%20m%20-%201%5D%7C%20%5Cle%202%5E%7Bnm%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cimplies%20%26%20Pr%5C%7B%20%5Ctext%7Bfailure%7D%20%5C%7D%20%5Cle%20%5Cfrac%7B%5Cpi%28nm%29%7D%7B%5Cpi%28M%29%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        &amp; \text{$p$ divides } |P - T[i \ldots i + m - 1] \text{ for some $i$} \\
                        \implies &amp; \text{$p$ divides } \Pi_i |P - T[i \ldots i + m - 1]| \le 2^{nm} \\
                        \implies &amp; Pr\{ \text{failure} \} \le \frac{\pi(nm)}{\pi(M)}
                    \end{aligned}" title="\begin{aligned}
                        &amp; \text{$p$ divides } |P - T[i \ldots i + m - 1] \text{ for some $i$} \\
                        \implies &amp; \text{$p$ divides } \Pi_i |P - T[i \ldots i + m - 1]| \le 2^{nm} \\
                        \implies &amp; Pr\{ \text{failure} \} \le \frac{\pi(nm)}{\pi(M)}
                    \end{aligned}" /><br /></p>
<p>Where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M" alt="M" title="M" /> is some number. We can choose <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M%20%3D%20n%5E2%20m" alt="M = n^2 m" title="M = n^2 m" />, then we have:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Pr%5C%7B%5Ctext%7Bfailure%7D%5C%7D%20%26%5Cle%20%5Cfrac%7Bnm%7D%7B%5Cln%20%28nm%29%7D%20%5Cfrac%7B%5Cln%28n%5E2%20m%29%7D%7Bn%5E2%20m%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3C%20%5Cfrac%7B2%7D%7Bn%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        Pr\{\text{failure}\} &amp;\le \frac{nm}{\ln (nm)} \frac{\ln(n^2 m)}{n^2 m} \\
                        &amp;&lt; \frac{2}{n}
                    \end{aligned}" title="\begin{aligned}
                        Pr\{\text{failure}\} &amp;\le \frac{nm}{\ln (nm)} \frac{\ln(n^2 m)}{n^2 m} \\
                        &amp;&lt; \frac{2}{n}
                    \end{aligned}" /><br /></p>
<p>i.e. if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%3D%204000%20%3C%202%5E%7B12%7D" alt="n = 4000 &lt; 2^{12}" title="n = 4000 &lt; 2^{12}" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20%3D%20250%20%3C%202%5E8" alt="m = 250 &lt; 2^8" title="m = 250 &lt; 2^8" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M%20%3D%20n%5E2%20m%20%3C%202%5E%7B32%7D" alt="M = n^2 m &lt; 2^{32}" title="M = n^2 m &lt; 2^{32}" />. We can use a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=32" alt="32" title="32" />-bit fingerprint prime, and the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Pr%5C%7B%5Ctext%7Berror%7D%5C%7D%20%3C%2010%5E%7B-3%7D" alt="Pr\{\text{error}\} &lt; 10^{-3}" title="Pr\{\text{error}\} &lt; 10^{-3}" />.</p>
<p>In practice this is slower than Boyer-Moore, but it’s better when you need to test multiple patterns in one string.</p>
<h3 id="sub:verifying_polynomial_identities">Verifying Polynomial Identities</h3>
<p>Given a Vandermonde matrix <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M" alt="M" title="M" />:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20M%20%26%3D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cleft%5B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cbegin%7Barray%7D%7Bccccc%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%201%20%26%20x_1%20%26%20x_1%5E2%20%26%20%5Cldots%20%26%20x_1%20%5E%7Bn-1%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%26%20%5Cvdots%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%201%20%26%20x_n%20%26%20x_n%5E2%20%26%20%5Cldots%20%26%20x_n%20%5E%7Bn-1%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Barray%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cright%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    M &amp;=
                    \left[
                        \begin{array}{ccccc}
                            1 &amp; x_1 &amp; x_1^2 &amp; \ldots &amp; x_1 ^{n-1} \\
                            \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
                            1 &amp; x_n &amp; x_n^2 &amp; \ldots &amp; x_n ^{n-1}
                        \end{array}
                    \right]
                \end{aligned}" title="\begin{aligned}
                    M &amp;=
                    \left[
                        \begin{array}{ccccc}
                            1 &amp; x_1 &amp; x_1^2 &amp; \ldots &amp; x_1 ^{n-1} \\
                            \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
                            1 &amp; x_n &amp; x_n^2 &amp; \ldots &amp; x_n ^{n-1}
                        \end{array}
                    \right]
                \end{aligned}" /><br /></p>
<p>There is the Vandermonde identity: <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cdet%28M%29%20%3D%20%5CPi_%7Bj%20%3C%20i%7D%20%28x_i%20-%20x_j%29" alt="\det(M) = \Pi_{j &lt; i} (x_i - x_j)" title="\det(M) = \Pi_{j &lt; i} (x_i - x_j)" />. We can <span>verify</span> this by substituting random values for variables<a href="#fn38" class="footnoteRef" id="fnref38"><sup>38</sup></a><a href="#fn39" class="footnoteRef" id="fnref39"><sup>39</sup></a><a href="#fn40" class="footnoteRef" id="fnref40"><sup>40</sup></a>.</p>
<h3 id="sub:verifying_polynomial_identities">Verifying Polynomial Identities</h3>
<p><span><strong>Theorem</strong></span>: let <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f%28x_1%20%5Cldots%20x_n%29" alt="f(x_1 \ldots x_n)" title="f(x_1 \ldots x_n)" /> be a multivariate polynomial of total degree<a href="#fn41" class="footnoteRef" id="fnref41"><sup>41</sup></a> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" />. If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f" alt="f" title="f" /> is not identically <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0" alt="0" title="0" /> and if we choose values <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a_1%20%5Cldots%20a_n" alt="a_1 \ldots a_n" title="a_1 \ldots a_n" /> for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_1%20%5Cldots%20x_n" alt="x_1 \ldots x_n" title="x_1 \ldots x_n" /> independently and uniformly from a finite set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" />, then we claim <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Pr%5C%7B%20f%28a_1%20%5Cldots%20a_n%29%20%3D%200%5C%7D%20%5Cle%20%5Cfrac%7Bd%7D%7B%7CS%7C%7D" alt="Pr\{ f(a_1 \ldots a_n) = 0\} \le \frac{d}{|S|}" title="Pr\{ f(a_1 \ldots a_n) = 0\} \le \frac{d}{|S|}" />.</p>
<p>For example, if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%20%3D%20%5C%7B%200%2C%20%5Cpm%201%2C%20%5Cpm%202%20%5Cldots%20%5Cpm%20d%5C%7D" alt="S = \{ 0, \pm 1, \pm 2 \ldots \pm d\}" title="S = \{ 0, \pm 1, \pm 2 \ldots \pm d\}" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Pr%5C%7Bf%28a_1%2C%20%5Cldots%20a_n%29%20%3D%200%20%5C%7D%20%5Cle%20%5Cfrac%7B1%7D%7B2%7D" alt="Pr\{f(a_1, \ldots a_n) = 0 \} \le \frac{1}{2}" title="Pr\{f(a_1, \ldots a_n) = 0 \} \le \frac{1}{2}" />.</p>
<p><span><strong>Proof</strong></span>: We can do this by induction on <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />:</p>
<p>The basic case is when <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%3D1" alt="n=1" title="n=1" /> single variable of degree <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" /> implies that there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20d" alt="\le d" title="\le d" /> roots and in general, we can substitute and evaluate..</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20f%28x_1%20%5Cldots%20x_n%29%20%26%3D%20%5Csum_%7Bt%3D0%7D%20x_1%5Et%20g%28x_2%20%5Cldots%20x_n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    f(x_1 \ldots x_n) &amp;= \sum_{t=0} x_1^t g(x_2 \ldots x_n)
                \end{aligned}" title="\begin{aligned}
                    f(x_1 \ldots x_n) &amp;= \sum_{t=0} x_1^t g(x_2 \ldots x_n)
                \end{aligned}" /><br /></p>
<h3 id="sub:verifying_matrix_multiplication">Verifying Matrix Multiplication</h3>
<p>Given three matrices <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B" alt="B" title="B" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" /> that are all <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%5Ctimes%20n" alt="n \times n" title="n \times n" /> in size. We want to verify that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=AB%20%3D%20C" alt="AB = C" title="AB = C" />.</p>
<p>While the naive matrix multiplication is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E3%29" alt="O(n^3)" title="O(n^3)" />, one of the faster multiplication algorithms is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E%7B2.376%7D%29" alt="O(n^{2.376})" title="O(n^{2.376})" /> by Coppersmith and Winograd in 1990<a href="#fn42" class="footnoteRef" id="fnref42"><sup>42</sup></a>. These are complicated to implement, and the chance of implementing buggy programs is very high.</p>
<p>The idea is that by choosing a vector <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%20%3D%20%5Bx_1%20%5Cldots%20x_n%5D" alt="x = [x_1 \ldots x_n]" title="x = [x_1 \ldots x_n]" />, we can quickly verify that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=ABx%20%3D%20Cx" alt="ABx = Cx" title="ABx = Cx" /> is correct<a href="#fn43" class="footnoteRef" id="fnref43"><sup>43</sup></a></p>
<pre><code>    choose each x[i] = rand(0, 1)
    if A(Bx) == C(x):
        return MAYBE
    return NO
                </code></pre>
<p>We can set the probability of error <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Pr%5C%7B%5Ctext%7Berror%7D%5C%7D%20%5Cle%20%5Cfrac%7Bd%7D%7B%7CS%7C%7D%20%3D%20%5Cfrac%7B1%7D%7B2%7D" alt="Pr\{\text{error}\} \le \frac{d}{|S|} = \frac{1}{2}" title="Pr\{\text{error}\} \le \frac{d}{|S|} = \frac{1}{2}" /> (since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%20%3D%20%5C%7B0%2C%201%5C%7D%20%5Cto%20%7CS%7C%20%3D%202" alt="S = \{0, 1\} \to |S| = 2" title="S = \{0, 1\} \to |S| = 2" />).</p>
<p>This runs in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E2%29" alt="O(n^2)" title="O(n^2)" /> time, and we can repeat it to reduce error.</p>
<h1 id="cha:linear_programming">Linear Programming in Low Dimension</h1>
<p>Linear programming is a math (and computational) method for achieving the best outcome given a model expressed as a series of linear relationships.</p>
<p>In other words, given a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d%20%5Ctimes%201" alt="d \times 1" title="d \times 1" />-vector <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7Bx%7D" alt="\vec{x}" title="\vec{x}" />, an <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%5Ctimes%20d" alt="n \times d" title="n \times d" /> matrix <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" />, a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1%20%5Ctimes%20d" alt="1 \times d" title="1 \times d" /> vector <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" />, and a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%5Ctimes%201" alt="n \times 1" title="n \times 1" /> vector <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=b" alt="b" title="b" />, maximize <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=cx" alt="cx" title="cx" /> while satisfying the constraint <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Ax%20%5Cle%20b" alt="Ax \le b" title="Ax \le b" />.</p>
<p>Expressed differently, we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" /> inequalities we need to satisfy, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> variables <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_i%20%3A%20i%20%5Cin%20%5C%7B%200%20%5Cldots%20n%20%5C%7D" alt="x_i : i \in \{ 0 \ldots n \}" title="x_i : i \in \{ 0 \ldots n \}" /> while we’re trying to maximize <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Csum%20c_i%20x_i" alt="\sum c_i x_i" title="\sum c_i x_i" />.</p>
<p>More in this section can be found on [MR section 9.10.1], or see Chapter 4 of the book Computational Geometry by de Berg, van Kreveld, Overmars and Schwarzkopf, Springer 2000.</p>
<h2 id="sec:naive_algorithm">Naive Algorithm</h2>
<p>In <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2" alt="2" title="2" />D, each constraint <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a_1%20x_1%20%2B%20a_2%20x_2%20%5Cle%20b" alt="a_1 x_1 + a_2 x_2 \le b" title="a_1 x_1 + a_2 x_2 \le b" /> is a half-space. As long as the feasible region is non-empty and is bounded by an inequality<a href="#fn44" class="footnoteRef" id="fnref44"><sup>44</sup></a>, an optimal solution is at a meeting point of at two lines - a vertex<a href="#fn45" class="footnoteRef" id="fnref45"><sup>45</sup></a>.</p>
<p>This gives us a stupid algorithm: try all <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7Bn%20%5Cchoose%20d%7D" alt="{n \choose d}" title="{n \choose d}" /> sets of vertexes, eliminate infeasible vertexes, then find the maximum objective value. This gives an <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%7Bn%20%5Cchoose%20d%7D%29%20%3D%20O%28n%5Ed%29" alt="O({n \choose d}) = O(n^d)" title="O({n \choose d}) = O(n^d)" /> algorithm.</p>
<h2 id="sec:applications_of_linear_programming">Applications of Linear Programming</h2>
<p>We can use this to plan menus. With <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> nutrients, we need <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=b_i" alt="b_i" title="b_i" /> of nutrient <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />. With <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" /> foods, each food <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j" alt="j" title="j" /> has a cost <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c_j" alt="c_j" title="c_j" /> and an amount <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a_%7Bi%2Cj%7D" alt="a_{i,j}" title="a_{i,j}" /> of nutrient <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />.</p>
<p>Defining <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_j" alt="x_j" title="x_j" /> as the volume of food <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j" alt="j" title="j" /> purchased, we want to minimize <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=cx" alt="cx" title="cx" /> while maintaining that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Ax%20%5Cge%20b" alt="Ax \ge b" title="Ax \ge b" />.</p>
<h2 id="sec:history_of_linear_programming">History of Linear Programming</h2>
<h3 id="sub:simplex_method">Simplex Method</h3>
<p><strong>Dantzig</strong> introduced the simplex method in the 1940s, spurring the development of computers. Geometrically, it walks from one vertex of a feasible region to an adjacent one according to a that dictates which inequality to remove and which to add. For almost all simplex pivot rules, we know examples taking exponential time.</p>
<p>The <em>Hirsch Conjecture</em> conjects that the diameter of a convex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" />-dimension polyhedron with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> inequalities is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20n%20-%20d" alt="\le n - d" title="\le n - d" />. Sadly, it was disproved in 2012.</p>
<p><span><span style="font-variant: small-caps;">open</span></span>: This doesn’t mean that there is no polynomial (or even linear) bound.</p>
<p>In general though, the simplex method is in practice.</p>
<h3 id="sub:other_algorithms">Other Algorithms</h3>
<p>There have been some polynomial-time algorithms for linear programming:</p>
<dl>
<dt>Katchian</dt>
<dd><p>discovered the ellipsoid method in 1980.</p>
</dd>
<dt>Karkarkar</dt>
<dd><p>discovered the interior point method in 1984 (it operates on bit representations of numbers).</p>
</dd>
</dl>
<p><span><span style="font-variant: small-caps;">open</span></span>: Is there an algorithm that uses the number of arithmetic operations polynomial in both <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" />?</p>
<p>The 1970s and 1980s saw linear programming being used in small (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d%3D2%2C%203" alt="d=2, 3" title="d=2, 3" />) dimensions.</p>
<p>Uses of this were finding the best line fitting points, and whether a cast can be removed from a mold<a href="#fn46" class="footnoteRef" id="fnref46"><sup>46</sup></a>.</p>
<p>Finally, <em>Megiddo</em> found an algorithm that runs in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> when <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" /> is fixed<a href="#fn47" class="footnoteRef" id="fnref47"><sup>47</sup></a>.</p>
<h2 id="sec:randomized_incremental_linear_programming_algorithm">Randomized Incremental Linear Programming Algorithm</h2>
<p>We’re going to examine Seidel’s Randomized Incremental Linear Programming Algorithm.</p>
<p>The idea is that we want to add half-planes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h_i" alt="h_i" title="h_i" /> one by one, updating the optimal solution vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> every time.</p>
<p>When we add <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h_i" alt="h_i" title="h_i" />, there are two cases:</p>
<ol>
<li><p>In the case that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v%20%5Cin%20h_i" alt="v \in h_i" title="v \in h_i" />, we have no work to do.</p></li>
<li><p>In the case that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v%20%5Cnot%20%5Cin%20h_i" alt="v \not \in h_i" title="v \not \in h_i" />, we need to find a new optimum. We know that the new optimum will line on <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cell_i" alt="\ell_i" title="\ell_i" />, a line the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h_i" alt="h_i" title="h_i" /> plane. So we solve the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1" alt="1" title="1" />-dimensional LP problem along line <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cell_i" alt="\ell_i" title="\ell_i" />.</p>
<p>The 1D LP (<span style="font-variant: small-caps;">lp1</span>) algorithm runs as follows: (Where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=L" alt="L" title="L" /> is a set of rays in 1D)</p>
<pre><code>LP_1(L):
    find and return lowest upper bound on x
                    </code></pre>
<p><span style="font-variant: small-caps;">lp_1</span> runs in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%7CL%7C%29" alt="O(|L|)" title="O(|L|)" />.</p>
<p>Then, we can implement <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=LP_2%28H%29" alt="LP_2(H)" title="LP_2(H)" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=H%20%3D%20%5C%7Bh_1%20%5Cldots%20h_n%5C%7D" alt="H = \{h_1 \ldots h_n\}" title="H = \{h_1 \ldots h_n\}" /> as follows:</p>
<pre><code>LP_2(H):
    shuffle H
    v = point at infinity
    for i = 1 ... n: // add H[i]
        if v is not in H[i]:
            v = LP_1(intersect(H[1 ... i-1]), L[i])
                    </code></pre>
<p>Since <span style="font-variant: small-caps;">lp_1</span><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3D%20O%28i%29" alt="= O(i)" title="= O(i)" /> in this implementation, then it runs in worst-case <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E2%29" alt="O(n^2)" title="O(n^2)" />.</p>
<p>We can calculate the expected runtime using <strong>backwards analysis</strong><a href="#fn48" class="footnoteRef" id="fnref48"><sup>48</sup></a>:</p>
<p>After adding <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h_i" alt="h_i" title="h_i" />, suppose the new optimum is vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v%27" alt="v&#39;" title="v&#39;" /> is at the intersection of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h%27" alt="h&#39;" title="h&#39;" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h%27%27" alt="h&#39;&#39;" title="h&#39;&#39;" />.</p>
<p>Given that we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> lines, halfplane <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h_i" alt="h_i" title="h_i" /> is equally likely to be any one of them.</p>
<p>We did work for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h_i" alt="h_i" title="h_i" /> when we call <span style="font-variant: small-caps;">lp_1</span>, but only if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h_i%20%3D%20h%27" alt="h_i = h&#39;" title="h_i = h&#39;" /> or <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h_i%20%3D%20h%27%27" alt="h_i = h&#39;&#39;" title="h_i = h&#39;&#39;" />. Since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=h_i" alt="h_i" title="h_i" /> is equally likely to be any of them, we know:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Pr%5C%7B%20h_i%20%5Cin%20%5C%7Bh%27%2C%20h%27%27%5C%7D%20%5C%7D%20%26%3D%20%5Cfrac%7B2%7D%7Bi%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        Pr\{ h_i \in \{h&#39;, h&#39;&#39;\} \} &amp;= \frac{2}{i}
                    \end{aligned}" title="\begin{aligned}
                        Pr\{ h_i \in \{h&#39;, h&#39;&#39;\} \} &amp;= \frac{2}{i}
                    \end{aligned}" /><br /></p>
<p>Thus we know that the expected total work when calling <span style="font-variant: small-caps;">lp_1</span> is:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Csum_%7Bi%3D1%7D%5En%20%5Cfrac%7B2%7D%7Bi%7D%20O%28i%29%20%26%3D%20O%28n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \sum_{i=1}^n \frac{2}{i} O(i) &amp;= O(n)
                    \end{aligned}" title="\begin{aligned}
                        \sum_{i=1}^n \frac{2}{i} O(i) &amp;= O(n)
                    \end{aligned}" /><br /></p>
<p>In higher dimensions, the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B2%7D%7Bi%7D" alt="\frac{2}{i}" title="\frac{2}{i}" /> becomes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7Bd%7D%7Bi%7D" alt="\frac{d}{i}" title="\frac{d}{i}" />, since it takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" /> hyperplanes to specify a vertex. Thus, we have the recurrence relation:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T_d%28n%29%20%26%3D%20T_d%28n-1%29%20%2B%20%5Cfrac%7Bd%7D%7Bn%7D%20O%20%5Cleft%28T_%7Bd-1%7D%28n%29%20%5Cright%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T_d%28n%29%20%26%3D%20O%28d%21%20n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        T_d(n) &amp;= T_d(n-1) + \frac{d}{n} O \left(T_{d-1}(n) \right) \\
                        T_d(n) &amp;= O(d! n)
                    \end{aligned}" title="\begin{aligned}
                        T_d(n) &amp;= T_d(n-1) + \frac{d}{n} O \left(T_{d-1}(n) \right) \\
                        T_d(n) &amp;= O(d! n)
                    \end{aligned}" /><br /></p>
<p>I think she mentioned in class that we can solve this recurrence by proving with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T_2%28n%29" alt="T_2(n)" title="T_2(n)" /> by induction, then proving <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T_d%28n%29" alt="T_d(n)" title="T_d(n)" /> by induction.</p></li>
</ol>
<h2 id="sec:randomized_incremental_disc_fitting">Randomized Incremental Disc Fitting</h2>
<p>We can use a similar approach to find the smallest enclosing disk for a set of points:</p>
<p>Given points <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_1%20%5Cldots%20p_n%20%5Cin%20%5Cmathbf%7BR%7D%5Ed" alt="p_1 \ldots p_n \in \mathbf{R}^d" title="p_1 \ldots p_n \in \mathbf{R}^d" />, find the smallest radius disc enclosing all points.</p>
<p>This is not linear programming (since it involves quadratics), but Megiddo’s approach still works, so there is an <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> non-randomized algorithm<a href="#fn49" class="footnoteRef" id="fnref49"><sup>49</sup></a>.</p>
<p>We can create a <em>randomized-incremental</em> approach as follows:</p>
<p>Given a disc <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_%7Bi-1%7D" alt="S_{i-1}" title="S_{i-1}" /> for a solution to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i-1" alt="i-1" title="i-1" /> points, add a new point <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" />.</p>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" /> is contained in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_%7Bi-1%7D" alt="S_{i-1}" title="S_{i-1}" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i%20%3D%20S_%7Bi-1%7D" alt="S_i = S_{i-1}" title="S_i = S_{i-1}" />.</p>
<p>If not, we know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i" alt="S_i" title="S_i" /> goes through <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" />.</p>
<p>Thus, we have a <em>easier</em> (or <em>smaller</em>) problem: given some points and a special point <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" />, find the smallest disc containing all points and with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" /> on a boundary. The trick for this question is realizing that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i" alt="S_i" title="S_i" /> goes through both <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_%7B%5Ctext%7Bprevious%20max%7D%7D" alt="p_{\text{previous max}}" title="p_{\text{previous max}}" />. Once we have three fixed points on a disc, we have a unique solution.</p>
<p><img src="images/smallest_disc.png" title="fig:" alt="Smallest Disc" /> [fig:smallest<sub>d</sub>isc]</p>
<p>Using this principle leads to an expected<a href="#fn50" class="footnoteRef" id="fnref50"><sup>50</sup></a> runtime of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" />.</p>
<h1 id="cha:randomized_algorithms_for_satisfiability_">Randomized Algorithms for Satisfiability (<span style="font-variant: small-caps;">sat</span>)</h1>
<p>Generally, satisfiability is the question that asks that given a boolean formula with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> variables and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> clauses when expressed in CNF, can we assign <span style="font-variant: small-caps;">truth</span> or <span style="font-variant: small-caps;">false</span> values to the formula. In the example below with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E" alt="E" title="E" />, assigning <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_1" alt="x_1" title="x_1" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_2" alt="x_2" title="x_2" /> satisfies the formula:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%20%26%3D%20%28x_1%20%5Clor%20x_2%20%5Clor%20x_3%29%20%5Cland%20%28x_1%20%5Clor%20%5Clnot%20x_2%29%20%5Cland%20%28%5Clnot%20x_1%20%5Clor%20%5Clnot%20x_2%20%5Clor%20%5Clnot%20x_3%29%20%5Cland%20%28x_2%20%5Clor%20%5Clnot%20x_3%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20x_1%20%26%3D%20%5Ctext%7B%5Ctextsc%7Btrue%7D%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20x_3%20%26%3D%20%5Ctext%7B%5Ctextsc%7Bfalse%7D%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                E &amp;= (x_1 \lor x_2 \lor x_3) \land (x_1 \lor \lnot x_2) \land (\lnot x_1 \lor \lnot x_2 \lor \lnot x_3) \land (x_2 \lor \lnot x_3) \\
                x_1 &amp;= \text{\textsc{true}} \\
                x_3 &amp;= \text{\textsc{false}}
            \end{aligned}" title="\begin{aligned}
                E &amp;= (x_1 \lor x_2 \lor x_3) \land (x_1 \lor \lnot x_2) \land (\lnot x_1 \lor \lnot x_2 \lor \lnot x_3) \land (x_2 \lor \lnot x_3) \\
                x_1 &amp;= \text{\textsc{true}} \\
                x_3 &amp;= \text{\textsc{false}}
            \end{aligned}" /><br /></p>
<p>The <span style="font-variant: small-caps;">3-sat</span> algorithm is an <span><span style="font-variant: small-caps;">NP</span></span>-variant where all clauses have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=3" alt="3" title="3" /> distinct literals. The <span style="font-variant: small-caps;">2-sat</span> algorithm can be solved in polynomial time (in fact, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" /> time).</p>
<p>We can apply this to everything, as it helps with quantified boolean formulae. <span style="font-variant: small-caps;">sat</span> is a case of one (implicit) <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cexists" alt="\exists" title="\exists" /> quantifier.</p>
<h2 id="sec:techniques_for_sat">Techniques for <span style="font-variant: small-caps;">sat</span></h2>
<p>There are heuristics that help us “resolve” different clauses. In fact, we can solve 3-SAT (in a non-obvious way) in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281.5%5En%29" alt="O(1.5^n)" title="O(1.5^n)" /> time using deterministic algorithms instead of the obvious <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%282%5En%20%5Ctext%7Bpoly%7D%28n%2C%20m%29%29" alt="O(2^n \text{poly}(n, m))" title="O(2^n \text{poly}(n, m))" />.</p>
<p>Using randomized algorithms, we’re going to get better than <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%281.5%5En%29" alt="O(1.5^n)" title="O(1.5^n)" /> for 3-SAT<a href="#fn51" class="footnoteRef" id="fnref51"><sup>51</sup></a>.</p>
<p>We are unlikely to get randomized polynomial time algorithms, since this implies randomized poly-time for all problems in <span><span style="font-variant: small-caps;">NP</span></span>. (eek)</p>
<h2 id="sec:randomized_sat_solving">Randomized SAT Solving</h2>
<p>The idea is that we’re going to be given an input <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E" alt="E" title="E" /> in CNF, then we’re going to “hill climb” to better values. This algorithm is called Papadimitrion’s algorithm (`91).</p>
<pre><code>    randomly assign T/F assignment A
    for i = 1...t:
        if A satisfies E return YES
        pick a random unsatisfied clause C
        randomly pick a literal x in C
        flip x&#39;s value
    return NO (maybe)
                </code></pre>
<p>We want to choose <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" /> and determine the error probability.</p>
<p>Errors occur when <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E" alt="E" title="E" /> is satisfiable and we return <span style="font-variant: small-caps;">no</span>.</p>
<p>Suppose <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%5E%2A" alt="A^*" title="A^*" /> is a truth value assignment that satisfies <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E" alt="E" title="E" />. For <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> as the number of variables with same value in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%5E%2A" alt="A^*" title="A^*" />, we can say that if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> reaches <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%20%3D%20A%5E%2A" alt="A = A^*" title="A = A^*" /> and the algorithm outputs <span style="font-variant: small-caps;">YES</span>.</p>
<p>When we re-assign the value of the variable, we know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> goes up or down by <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1" alt="1" title="1" />.</p>
<h3 id="sub:randomized_walk_on_a_line">Randomized Walk on a Line</h3>
<p>To do this analysis, we need to know about random walks on lines.</p>
<p>Start at a randomly chosen <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />, each step moves right (<code>i++</code>) with probability <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B2%7D" alt="\frac{1}{2}" title="\frac{1}{2}" /> and left (<code>i--</code>) with probability <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B2%7D" alt="\frac{1}{2}" title="\frac{1}{2}" />. When <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%3D0" alt="i=0" title="i=0" />, we always go right. When <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%3Dn" alt="i=n" title="i=n" />, we terminate.</p>
<p>The question can now be phrased as: What are the expected number of steps to get to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />?</p>
<p>Alternatively, we can analyze this as a Markov chain, or a finite automaton with probabilistic state movements.</p>
<p>We’re now looking for the expected number of steps to get from <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> - denoted <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t_i" alt="t_i" title="t_i" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20t_n%20%26%3D%200%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20t_0%20%26%3D%201%20%2B%20t_1%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20t_i%20%26%3D%201%20%2B%20t_%7Bi-1%7D%20%5Cfrac%7B1%7D%7B2%7D%20%2B%20t_%7Bi%2B1%7D%20%5Cfrac%7B1%7D%7B2%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        t_n &amp;= 0 \\
                        t_0 &amp;= 1 + t_1 \\
                        t_i &amp;= 1 + t_{i-1} \frac{1}{2} + t_{i+1} \frac{1}{2}
                    \end{aligned}" title="\begin{aligned}
                        t_n &amp;= 0 \\
                        t_0 &amp;= 1 + t_1 \\
                        t_i &amp;= 1 + t_{i-1} \frac{1}{2} + t_{i+1} \frac{1}{2}
                    \end{aligned}" /><br /></p>
<p>This is awkward for induction, but if we rearrange it, it’s pretty smooth:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20t_i%20%2B%20t_%7Bi%2B1%7D%20%26%3D%202%20%28t_%7Bi-1%7D%20-%20t_%7Bi%7D%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20d_i%20%26%3D%20t_i%20%2B%20t_%7Bi%2B1%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20d_0%20%26%3D%20t_0%20-%20t_1%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%201%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20d_i%20%26%3D%202%20%2B%20d_%7Bi%20-%201%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%201%20%2B%202i%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        t_i + t_{i+1} &amp;= 2 (t_{i-1} - t_{i}) \\
                        d_i &amp;= t_i + t_{i+1} \\
                        d_0 &amp;= t_0 - t_1 \\
                        &amp;= 1 \\
                        d_i &amp;= 2 + d_{i - 1} \\
                        &amp;= 1 + 2i
                    \end{aligned}" title="\begin{aligned}
                        t_i + t_{i+1} &amp;= 2 (t_{i-1} - t_{i}) \\
                        d_i &amp;= t_i + t_{i+1} \\
                        d_0 &amp;= t_0 - t_1 \\
                        &amp;= 1 \\
                        d_i &amp;= 2 + d_{i - 1} \\
                        &amp;= 1 + 2i
                    \end{aligned}" /><br /></p>
<p>If we substitute this for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t_i" alt="t_i" title="t_i" />, we get:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20t_i%20%26%3D%20d_i%20%2B%20t_%7Bi%20%2B%201%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20t_n%20%26%3D%200%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20t_i%20%26%3D%20%5Csum_%7Bj%3D1%7D%5E%7Bn-1%7D%20d_J%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Csum_%7Bj%3D1%7D%5E%7Bn-1%7D%20%281%20%2B%202j%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20n-1%20%2B%20%5Csum_%7Bj%3D1%7D%5E%7Bn-1%7D%20j%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%28n%20-%20i%29%20%2B%20n%28n-1%29%20-%20i%20%28i%20-%201%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20n%5E2%20-%20i%5E2%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        t_i &amp;= d_i + t_{i + 1} \\
                        t_n &amp;= 0 \\
                        t_i &amp;= \sum_{j=1}^{n-1} d_J \\
                        &amp;= \sum_{j=1}^{n-1} (1 + 2j) \\
                        &amp;= n-1 + \sum_{j=1}^{n-1} j \\
                        &amp;= (n - i) + n(n-1) - i (i - 1) \\
                        &amp;= n^2 - i^2
                    \end{aligned}" title="\begin{aligned}
                        t_i &amp;= d_i + t_{i + 1} \\
                        t_n &amp;= 0 \\
                        t_i &amp;= \sum_{j=1}^{n-1} d_J \\
                        &amp;= \sum_{j=1}^{n-1} (1 + 2j) \\
                        &amp;= n-1 + \sum_{j=1}^{n-1} j \\
                        &amp;= (n - i) + n(n-1) - i (i - 1) \\
                        &amp;= n^2 - i^2
                    \end{aligned}" /><br /></p>
<p>The maximum is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t_0%20%3D%20n%5E2" alt="t_0 = n^2" title="t_0 = n^2" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t_i%20%5Cle%20n%5E2" alt="t_i \le n^2" title="t_i \le n^2" />.</p>
<h3 id="sub:finding_error_in_our_approximation">Finding Error in our Approximation</h3>
<p>For Papadimitrion’s solution to 2-<span style="font-variant: small-caps;">sat</span>, we can model the number of steps as a random walk on a line. In this representation, we say <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t_i" alt="t_i" title="t_i" /> is a state where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> variables are “set correctly”, and assume the worst case scenario of only one assignment being correct.</p>
<p>In a clause <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C%20%3D%20%28%5Calpha%20%5Clor%20%5Cbeta%29" alt="C = (\alpha \lor \beta)" title="C = (\alpha \lor \beta)" /> being modified was not satisfied, then one of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Calpha" alt="\alpha" title="\alpha" /> or <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbeta" alt="\beta" title="\beta" /> must be true in the optimal solution. If only one needs to be inverted, we pick the correct one <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B2%7D" alt="\frac{1}{2}" title="\frac{1}{2}" /> the time. If both need to be inverted, we pick the correct one every time. So we can say that the probability that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> increases is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Cfrac%7B1%7D%7B2%7D" alt="\ge \frac{1}{2}" title="\ge \frac{1}{2}" />.</p>
<p>By strategically picking the value of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" />, we can easily determine the expected number of repeats. Using Markov’s inequality (which can be found in Section [sec:markov<sub>si</sub>nequality]):</p>
<p>Supposing <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X%20%5Cge%200" alt="X \ge 0" title="X \ge 0" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E%28X%29%20%3D%20%5Cmu" alt="E(X) = \mu" title="E(X) = \mu" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%5C%7B%20X%20%5Cge%20c%20%5Cmu%5C%7D%20%5Cle%20%5Cfrac%7B1%7D%7Bc%7D" alt="\Pr\{ X \ge c \mu\} \le \frac{1}{c}" title="\Pr\{ X \ge c \mu\} \le \frac{1}{c}" /> for a constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" />. In our case, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cmu%20%3D%20n%5E2" alt="\mu = n^2" title="\mu = n^2" />, so we choose <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%20%3D%202" alt="c = 2" title="c = 2" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CPr%20%5C%7B%20%5Ctext%7B%5C%23%20steps%7D%20%3E%202n%5E2%20%5C%7D%20%26%3C%20%5Cfrac%7B1%7D%7B2%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \Pr \{ \text{\# steps} &gt; 2n^2 \} &amp;&lt; \frac{1}{2}
                    \end{aligned}" title="\begin{aligned}
                        \Pr \{ \text{\# steps} &gt; 2n^2 \} &amp;&lt; \frac{1}{2}
                    \end{aligned}" /><br /></p>
<p>So set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t%20%3D%202n%5E2" alt="t = 2n^2" title="t = 2n^2" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%5C%7B%5Ctext%7Berror%7D%5C%7D%20%3C%20%5Cfrac%7B1%7D%7B2%7D" alt="\Pr\{\text{error}\} &lt; \frac{1}{2}" title="\Pr\{\text{error}\} &lt; \frac{1}{2}" />.</p>
<p>From this we know that the runtime is not <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E2%29" alt="O(n^2)" title="O(n^2)" />, but it actually is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E2%20%5Ccdot%20poly%28n%2C%20m%29%29" alt="O(n^2 \cdot poly(n, m))" title="O(n^2 \cdot poly(n, m))" /> time.</p>
<h3 id="sub:papadimitrion_s_algorithm_in_higher_dimensions">Papadimitrion’s Algorithm in Higher Dimensions</h3>
<p>For a given clause <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C%20%3D%20%28%5Calpha%20%5Clor%20%5Cbeta%20%5Clor%20%5Cgamma%29" alt="C = (\alpha \lor \beta \lor \gamma)" title="C = (\alpha \lor \beta \lor \gamma)" />, if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> does not satisfy <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" />, but <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%5E%2A" alt="A^*" title="A^*" /> does with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Calpha%20%3D%20T" alt="\alpha = T" title="\alpha = T" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CPr%28%5Ctext%7BAlgorithm%20flips%20%24%5Calpha%24%7D%29%20%26%3D%20%5Cfrac%7B1%7D%7B3%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CPr%28%5Ctext%7B%24i%24%20increases%7D%29%20%26%5Cge%20%5Cfrac%7B1%7D%7B3%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \Pr(\text{Algorithm flips $\alpha$}) &amp;= \frac{1}{3} \\
                        \Pr(\text{$i$ increases}) &amp;\ge \frac{1}{3}
                    \end{aligned}" title="\begin{aligned}
                        \Pr(\text{Algorithm flips $\alpha$}) &amp;= \frac{1}{3} \\
                        \Pr(\text{$i$ increases}) &amp;\ge \frac{1}{3}
                    \end{aligned}" /><br /></p>
<p>So we analyze a random walk on a line:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CPr%28%5Ctext%7Bi%20goes%20to%20%24i%2B1%24%7D%29%20%26%3D%20%5Cfrac%7B1%7D%7B3%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CPr%28%5Ctext%7Bi%20goes%20to%20%24i-1%24%7D%29%20%26%3D%20%5Cfrac%7B1%7D%7B3%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \Pr(\text{i goes to $i+1$}) &amp;= \frac{1}{3} \\
                        \Pr(\text{i goes to $i-1$}) &amp;= \frac{1}{3}
                    \end{aligned}" title="\begin{aligned}
                        \Pr(\text{i goes to $i+1$}) &amp;= \frac{1}{3} \\
                        \Pr(\text{i goes to $i-1$}) &amp;= \frac{1}{3}
                    \end{aligned}" /><br /></p>
<p>Using Markov’s inequality as before, we are expected to take <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Capprox%202%5En" alt="\approx 2^n" title="\approx 2^n" /> steps to get to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />, the final value<a href="#fn52" class="footnoteRef" id="fnref52"><sup>52</sup></a>.</p>
<h3 id="sub:sch_ning_s_algorithm">Schöning’s Algorithm</h3>
<p>Schöning (`99) gives two improvements to the algorithm:</p>
<ul>
<li><p>Start with a random assignment <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /></p></li>
<li><p>An increasing number of trials is not helpful if we’ve taken many steps without reaching <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%5E%2A" alt="A^*" title="A^*" />. We’re probably stuck near or at <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0" alt="0" title="0" />, so lets pick a “new” random <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" />.</p></li>
</ul>
<pre><code>schoning(E):
    for i = 1...s:
        randomly pick A
        repeat t = 1...3n:
            if A satisfies E output YES
            else
                pick unsatisfied clause C
                randomly flip a variable in C
    output NO-MAYBE
                    </code></pre>
<p>In the inner loop, the probability of error is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%28%5Ctext%7Berror%7D%29%20%5Clesssim%201%20-%20%5Cleft%28%20%5Cfrac%7B3%7D%7B4%7D%20%5Cright%29%5En" alt="\Pr(\text{error}) \lesssim 1 - \left( \frac{3}{4} \right)^n" title="\Pr(\text{error}) \lesssim 1 - \left( \frac{3}{4} \right)^n" />.</p>
<p>When we set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%20%3D%20c%20%5Cleft%28%20%5Cfrac%7B3%7D%7B4%7D%20%5Cright%29%5En" alt="S = c \left( \frac{3}{4} \right)^n" title="S = c \left( \frac{3}{4} \right)^n" />, the probability of error <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%28%5Ctext%7Berror%7D%29%20%5Clesssim%20%281%20-%20%5Cleft%28%20%5Cfrac%7B3%7D%7B4%7D%20%5Cright%29%5En%29%5E%7Bc%20%5Cleft%28%5Cfrac%7B4%7D%7B3%7D%20%5Cright%29%5En%7D" alt="\Pr(\text{error}) \lesssim (1 - \left( \frac{3}{4} \right)^n)^{c \left(\frac{4}{3} \right)^n}" title="\Pr(\text{error}) \lesssim (1 - \left( \frac{3}{4} \right)^n)^{c \left(\frac{4}{3} \right)^n}" />.</p>
<p>From calculus, we know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cleft%28%201%20-%20%5Cfrac%7B1%7D%7Ba%7D%20%5Cright%29%5Ea%20%5Cle%20%5Cfrac%7B1%7D%7Be%7D" alt="\left( 1 - \frac{1}{a} \right)^a \le \frac{1}{e}" title="\left( 1 - \frac{1}{a} \right)^a \le \frac{1}{e}" />, so the probability of error is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%28%5Ctext%7Berror%7D%29%20%5Clesssim%20%5Cfrac%7B1%7D%7Be%5Ec%7D" alt="\Pr(\text{error}) \lesssim \frac{1}{e^c}" title="\Pr(\text{error}) \lesssim \frac{1}{e^c}" />.</p>
<p>The bottom line is that we get <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%28%5Ctext%7Berror%7D%29%20%5Cle%20%5Cfrac%7B1%7D%7B2%7D" alt="\Pr(\text{error}) \le \frac{1}{2}" title="\Pr(\text{error}) \le \frac{1}{2}" />, with runtime <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%5Cleft%28%20%5Cleft%28%5Cfrac%7B4%7D%7B3%7D%20%5Cright%29%5En%20n%20%5Cright%29" alt="O\left( \left(\frac{4}{3} \right)^n n \right)" title="O\left( \left(\frac{4}{3} \right)^n n \right)" />. While this is exponential, it does beat the best known non-randomized algorithm that we know.</p>
<h1 id="cha:minimum_spanning_trees">Minimum Spanning Trees</h1>
<p>The problem <span style="font-variant: small-caps;">mst</span> can be expressed as follows:</p>
<blockquote>
<p>Given an undirected graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G%20%3D%20%28V%2C%20E%29" alt="G = (V, E)" title="G = (V, E)" /> with edge weights <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=w%20%3A%20E%20%5Cto%20%5Cmathbf%7BR%7D%5E%2B" alt="w : E \to \mathbf{R}^+" title="w : E \to \mathbf{R}^+" />, find a minimum-weight spanning tree.</p>
</blockquote>
<p>In other words, find the tree on the graph that reaches all vertexes such that has the minimal total of edge weight in the tree.</p>
<p>Let’s assume that edge weights are distinct<a href="#fn53" class="footnoteRef" id="fnref53"><sup>53</sup></a>.</p>
<p>We can generate this problem to a spanning forest of disconnected graph<a href="#fn54" class="footnoteRef" id="fnref54"><sup>54</sup></a> There are two basic rules:</p>
<dl>
<dt>Inclusion Rule</dt>
<dd><p>The inclusion rule dictates that for a given vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" />, if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" />’s minimum weight incident edge<a href="#fn55" class="footnoteRef" id="fnref55"><sup>55</sup></a> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%20%3D%20vu" alt="e = vu" title="e = vu" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=vu%20%5Cin%20%5Ctextsc%7Bmst%7D%28G%29" alt="vu \in \textsc{mst}(G)" title="vu \in \textsc{mst}(G)" />. Since we know this, we can the vertexes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" /> into each other creating a vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v%27" alt="v&#39;" title="v&#39;" />, and continue the process with a smaller graph. For every vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r" alt="r" title="r" /> which has an edge to both <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" />, we just add the smaller of the two edges to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v%27" alt="v&#39;" title="v&#39;" />.</p>
</dd>
<dt>Exclusion Rule</dt>
<dd><p>The exclusion rule dictates that for a given cycle <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" /> with maximum weight edge <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%20%5Cnot%20%5Cin%20%5Ctextsc%7Bmst%7D%28G%29" alt="e \not \in \textsc{mst}(G)" title="e \not \in \textsc{mst}(G)" />. We may delete <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> and continue.</p>
</dd>
</dl>
<p>While basically all <span style="font-variant: small-caps;">mst</span> algorithms work under these rules, we can’t get the MST without contraction.</p>
<p>In this analysis, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is the number of vertexes, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> is the number of edges.</p>
<h2 id="sec:kruskal_s_algorithm_">Kruskal’s Algorithm (`56)</h2>
<p>Kruskal’s Algorithm uses the inclusion rule.</p>
<pre><code>    mst(G)
        repeat:
            e = (u, v) = minimumWeightEdge(G)
            T += uv
            contract(G, e)
        end
                </code></pre>
<p>By sorting edges by weight, then using union-find to find the new vertexes connected to edges after contraction, this algorithm takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%5Clog%20n%29" alt="O(m \log n)" title="O(m \log n)" /> time.</p>
<h2 id="sec:prim_s_algorithm_57">Prim’s Algorithm (`57)</h2>
<pre><code>    mst(G):
        S = randomVertexFrom(G.V)
        repeat:
            e = minimumWeightEdgeFrom(S)
            T += e
            contract(G, e)
            S.put(e.from)
            S.put(e.to)
                </code></pre>
<p>Implementing with a heap takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%5Clog%20n%29" alt="O(m \log n)" title="O(m \log n)" /> time. Implementing with a Fibonacci Heap takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%20%2B%20m%29" alt="O(n \log n + m)" title="O(n \log n + m)" /> time, which is linear when <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20%3E%20n%20%5Clog%20n" alt="m &gt; n \log n" title="m &gt; n \log n" />.</p>
<h2 id="sec:borukva_s_algorithm_26">Borvka’s Algorithm (`26)</h2>
<p>The idea is that we want to apply the inclusion rule to all vertexes at once. We’ll actually just apply it until every vertex is a contracted one, and the resultant number of vertexes is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Cfrac%7Bn%7D%7B2%7D" alt="\le \frac{n}{2}" title="\le \frac{n}{2}" />.</p>
<h3 id="sub:baruvka_step">Borvka Step</h3>
<p>The is that we want to ensure every vertex is part of at least one merge.</p>
<pre><code>    baruvka(G):
        unmark all vertexes
        for each v in V:
            if v is unmarked:
                find minimum weight edge e=vu
                add e to T, contract v to u
                mark u
        return T
                    </code></pre>
<p>For each vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" />, the Borvka Step checks <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" />’s minimum weight edge, and contracts <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v%20%5Cto%20u" alt="v \to u" title="v \to u" />, which takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Ctext%7Bdeg%7D%28v%29%29" alt="O(\text{deg}(v))" title="O(\text{deg}(v))" /> time. Thus, the entire step takes:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20O%5Cleft%28%5Csum_v%20%5Ctext%7Bdeg%7D%28v%29%20%5Cright%29%20%26%3D%20O%28m%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        O\left(\sum_v \text{deg}(v) \right) &amp;= O(m)
                    \end{aligned}" title="\begin{aligned}
                        O\left(\sum_v \text{deg}(v) \right) &amp;= O(m)
                    \end{aligned}" /><br /></p>
<p>The step reduces the graph to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Cfrac%7Bn%7D%7B2%7D" alt="\le \frac{n}{2}" title="\le \frac{n}{2}" /> vertexes.</p>
<h3 id="sub:baruvka_s_algorithm">Borvka’s Algorithm</h3>
<p>The idea is to repeat the Borvka Step until only one vertex is left.</p>
<p>Since there are going to be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> reductions, the total time is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%5Clog%20n%29" alt="O(m \log n)" title="O(m \log n)" />. This isn’t as fast in practice as Prim, but it’s much simpler to implement.</p>
<h2 id="sec:history_of_mst_algorithms">History of MST Algorithms</h2>
<ul>
<li><p>In `75, Yao, Cheriton, and Tarjan found a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%5Clog%20%5Clog%20n%29" alt="O(m \log \log n)" title="O(m \log \log n)" /> algorithm.</p></li>
<li><p>In `85, Fredman and Tarjan found a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%5Clog%5E%2A%20n%29" alt="O(m \log^* n)" title="O(m \log^* n)" /> algorithm.</p></li>
<li><p>In `87, Chazelle found an <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%5Calpha%28n%29%29" alt="O(m \alpha(n))" title="O(m \alpha(n))" /> algorithm.</p></li>
</ul>
<p><span><span style="font-variant: small-caps;">open</span></span>: Is there a linear time (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%2B%20m%29" alt="O(n + m)" title="O(n + m)" />) algorithm?</p>
<h2 id="sec:karger_s_algorithm_">Karger’s Algorithm (`93)</h2>
<p>Karger gave a Las-Vegas MST algorithm with linear expected run time. The idea of his algorithm is to use random sampling, the exclusion rule, and recursion.</p>
<p>We want the algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctextsc%7Bmst%7D%28E%29" alt="\textsc{mst}(E)" title="\textsc{mst}(E)" /> to return the <span style="font-variant: small-caps;">mst</span> of each connected component of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G%3D%28V%2C%20E%29" alt="G=(V, E)" title="G=(V, E)" />.</p>
<pre><code>    MST(E):
        take a random subset R &lt;= E of size |R| = r // chosen later: r=2n
        T = MST(R)
        for each edge uv in E, do:
            if uv is not in T and uv is heavier than all edges in the uv path in T:
                classify uv as heavy
            else:
                classify uv as light and replace uv with e in T
        E = E - heavy edges
        return MST(E)
                </code></pre>
<p>This is correct by the exclusion rule. If we added a new edge <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%20%3D%20uv" alt="e = uv" title="e = uv" /> to the sample <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R" alt="R" title="R" />:</p>
<ul>
<li><p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> is heavy, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> does not change.</p></li>
<li><p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> is light, we would’ve updated <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> to use <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=uv" alt="uv" title="uv" />.</p></li>
</ul>
<p>Additionally <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> is the <span style="font-variant: small-caps;">mst</span> of the entire graph iff all edges not in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> are heavy.</p>
<p>We can classify edges and verify if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> is a <span style="font-variant: small-caps;">mst</span> of the entire graph in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%29" alt="O(m)" title="O(m)" /> time<a href="#fn56" class="footnoteRef" id="fnref56"><sup>56</sup></a>.</p>
<h3 id="sub:sampling_lemma">Sampling Lemma</h3>
<p>We propose that the number of light edges <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E%28%5Ctext%7B%5C%23%20light%20edges%7D%29%20%5Cle%20%5Cfrac%7Bmn%7D%7Br%7D" alt="E(\text{\# light edges}) \le \frac{mn}{r}" title="E(\text{\# light edges}) \le \frac{mn}{r}" />. Since there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> edges, this is enough to show that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%28%5Ctext%7Be%20is%20light%7D%29%20%5Cle%5Cfrac%7Bn%7D%7Br%7D" alt="\Pr(\text{e is light}) \le\frac{n}{r}" title="\Pr(\text{e is light}) \le\frac{n}{r}" />.</p>
<p>We can prove this by working backwards: Consider <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R%27%20%3D%20R%20%5Ccup%20%5C%7Be%5C%7D" alt="R&#39; = R \cup \{e\}" title="R&#39; = R \cup \{e\}" />, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> is a random element of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R%27" alt="R&#39;" title="R&#39;" />. By the notes above, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> is light with respect to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R" alt="R" title="R" /> if and only if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> is in the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctextsc%7Bmst%7D%28R%27%29" alt="\textsc{mst}(R&#39;)" title="\textsc{mst}(R&#39;)" /> (which has <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20n-1" alt="\le n-1" title="\le n-1" /> edges). So <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%28%5Ctext%7B" alt="\Pr(\text{" title="\Pr(\text{" />e<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%20is%20light%7D%29%20%5Cle%20%5Cfrac%7Bn-1%7D%7B%7CR%27%7C%7D%20%3C%20%5Cfrac%7Bn%7D%7Br%7D" alt=" is light}) \le \frac{n-1}{|R&#39;|} &lt; \frac{n}{r}" title=" is light}) \le \frac{n-1}{|R&#39;|} &lt; \frac{n}{r}" />.</p>
<h3 id="sub:analysis_of_expected_runtime">Analysis of Expected Runtime</h3>
<p>We have the following recursion:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T%28m%2C%20n%29%20%26%3D%20%5Ctext%7Brecursive%20call%20on%20%24R%24%7D%20%2B%20%5Ctext%7Btime%20to%20classify%7D%20%2B%20%5Ctext%7Brecursive%20call%20to%20find%20the%20MST%20of%20%24E%24-heavy%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T%28m%2C%20n%29%20%26%3D%20T%28r%2C%20n%29%20%2B%20O%28m%20%2B%20n%29%20%2B%20T%5Cleft%28%5Cfrac%7Bmn%7D%7Br%7D%2C%20n%5Cright%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        T(m, n) &amp;= \text{recursive call on $R$} + \text{time to classify} + \text{recursive call to find the MST of $E$-heavy} \\
                        T(m, n) &amp;= T(r, n) + O(m + n) + T\left(\frac{mn}{r}, n\right)
                    \end{aligned}" title="\begin{aligned}
                        T(m, n) &amp;= \text{recursive call on $R$} + \text{time to classify} + \text{recursive call to find the MST of $E$-heavy} \\
                        T(m, n) &amp;= T(r, n) + O(m + n) + T\left(\frac{mn}{r}, n\right)
                    \end{aligned}" /><br /></p>
<p>With <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r%20%3D%202n" alt="r = 2n" title="r = 2n" />, this becomes:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T%28m%2C%20n%29%20%26%3D%20T%282n%2C%20n%29%20%2B%20O%28m%20%2B%20n%29%20%2B%20T%5Cleft%28%5Cfrac%7Bmn%7D%7B2n%7D%2C%20n%5Cright%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T%28m%2C%20n%29%20%26%3D%20T%282n%2C%20n%29%20%2B%20T%5Cleft%28%5Cfrac%7Bm%7D%7B2%7D%2C%20n%5Cright%29%20%2B%20O%28m%20%2B%20n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        T(m, n) &amp;= T(2n, n) + O(m + n) + T\left(\frac{mn}{2n}, n\right) \\
                        T(m, n) &amp;= T(2n, n) + T\left(\frac{m}{2}, n\right) + O(m + n)
                    \end{aligned}" title="\begin{aligned}
                        T(m, n) &amp;= T(2n, n) + O(m + n) + T\left(\frac{mn}{2n}, n\right) \\
                        T(m, n) &amp;= T(2n, n) + T\left(\frac{m}{2}, n\right) + O(m + n)
                    \end{aligned}" /><br /></p>
<p>The final idea, (attributed to Karger, Klein, and Tarjan in `94) is on each recursive call to do 3 Borvka steps first. This reduces <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7B%5C%23%20vertexes%7D%20%5Cle%20%5Cfrac%7Bn%7D%7B8%7D" alt="\text{\# vertexes} \le \frac{n}{8}" title="\text{\# vertexes} \le \frac{n}{8}" /> with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%2B%20m%29" alt="O(n + m)" title="O(n + m)" /> work. For some constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" />, we have:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T%28m%2C%20n%29%20%5Cle%20T%5Cleft%28%5Cfrac%7Bn%7D%7B4%7D%2C%20%5Cfrac%7Bn%7D%7B8%7D%5Cright%29%20%2B%20T%5Cleft%28%5Cfrac%7Bm%7D%7B2%7D%2C%20%5Cfrac%7Bn%7D%7B8%7D%5Cright%29%20%2B%20d%28m%2Bn%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        T(m, n) \le T\left(\frac{n}{4}, \frac{n}{8}\right) + T\left(\frac{m}{2}, \frac{n}{8}\right) + d(m+n)
                    \end{aligned}" title="\begin{aligned}
                        T(m, n) \le T\left(\frac{n}{4}, \frac{n}{8}\right) + T\left(\frac{m}{2}, \frac{n}{8}\right) + d(m+n)
                    \end{aligned}" /><br /></p>
<p>Proving that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28m%2C%20n%29%20%5Cle%20c%28m%20%2B%20n%29" alt="T(m, n) \le c(m + n)" title="T(m, n) \le c(m + n)" /> for some constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" /> is sufficient to prove <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28m%2C%20n%29%20%5Cin%20O%28n%20%2B%20m%29" alt="T(m, n) \in O(n + m)" title="T(m, n) \in O(n + m)" />. We implicitly assume that the base case has been proven, and prove the inductive step:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T%28m%2C%20n%29%20%26%5Cle%20c%5Cleft%28%5Cfrac%7Bn%7D%7B4%7D%20%2B%20%5Cfrac%7Bn%7D%7B8%7D%5Cright%29%20%2B%20c%5Cleft%28%5Cfrac%7Bm%7D%7B2%7D%20%2B%20%5Cfrac%7Bn%7D%7B8%7D%5Cright%29%20%2B%20d%5Cleft%28m%20%2B%20n%5Cright%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cleft%28%5Cfrac%7Bc%7D%7B2%7D%20%2B%20d%5Cright%29%20n%20%2B%20%5Cleft%28%5Cfrac%7Bc%7D%7B2%7D%20%2B%20d%20%5Cright%29%20m%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20c%28n%2Bm%29%20%5Ctext%7B%20as%20long%20as%20%24%5Cfrac%7Bc%7D%7B2%7D%20%2B%20d%20%5Cle%20c%24%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        T(m, n) &amp;\le c\left(\frac{n}{4} + \frac{n}{8}\right) + c\left(\frac{m}{2} + \frac{n}{8}\right) + d\left(m + n\right) \\
                                &amp;= \left(\frac{c}{2} + d\right) n + \left(\frac{c}{2} + d \right) m \\
                                &amp;\le c(n+m) \text{ as long as $\frac{c}{2} + d \le c$}
                    \end{aligned}" title="\begin{aligned}
                        T(m, n) &amp;\le c\left(\frac{n}{4} + \frac{n}{8}\right) + c\left(\frac{m}{2} + \frac{n}{8}\right) + d\left(m + n\right) \\
                                &amp;= \left(\frac{c}{2} + d\right) n + \left(\frac{c}{2} + d \right) m \\
                                &amp;\le c(n+m) \text{ as long as $\frac{c}{2} + d \le c$}
                    \end{aligned}" /><br /></p>
<p>So the expected runtime is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%2Bn%29" alt="O(m+n)" title="O(m+n)" />.</p>
<h1 id="cha:approximation_algorithms">Approximation Algorithms</h1>
<p>Recall <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%5Cstackrel%7B%3F%7D%7B%3D%7D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}\stackrel{?}{=} {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}\stackrel{?}{=} {\textsc{NP}\xspace}" />.</p>
<p>We have a set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%5Csubseteq%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}\subseteq {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}\subseteq {\textsc{NP}\xspace}" />, and another set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BNP-complete%7D%5Cxspace%7D%5Csubseteq%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{NP-complete}\xspace}\subseteq {\textsc{NP}\xspace}" title="{\textsc{NP-complete}\xspace}\subseteq {\textsc{NP}\xspace}" />, where <span><span style="font-variant: small-caps;">NP-complete</span></span>are the hardest problems in <span><span style="font-variant: small-caps;">NP</span></span>. There are a few problems in <span><span style="font-variant: small-caps;">NP</span></span>that are not in <span><span style="font-variant: small-caps;">P</span></span>and not known to be in <span><span style="font-variant: small-caps;">NP-complete</span></span>(factoring, graph isomorphism, etc).</p>
<p>It is <span><span style="font-variant: small-caps;">open</span></span>if there exist poly-time correct algorithms to solve <span><span style="font-variant: small-caps;">NP-complete</span></span>problems.</p>
<p>Ladner proved that:</p>
<blockquote>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%5Cnot%20%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}\not = {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}\not = {\textsc{NP}\xspace}" />, then there are infinitely many problems in the space between <span><span style="font-variant: small-caps;">P</span></span>and <span><span style="font-variant: small-caps;">NP-complete</span></span>.</p>
</blockquote>
<p>It seems like we must either give up correctness, or speed.</p>
<p>And thus, approximation algorithms are born. For optimization problems, these algorithms guarantee that their result is <em>close to</em> the optimal solution.</p>
<h2 id="sec:concerning_approximation_algorithms">Concerning Approximation Algorithms</h2>
<p>An algorithm finds in polynomial-time a solution that is close to the optimal, either in terms of ratio or in constant difference.</p>
<h4 id="ssub:edge_coloring_in_a_graph">Edge-Coloring in a Graph</h4>
<p>Given a graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G" alt="G" title="G" />, color the edges such that if two edges are incident<a href="#fn57" class="footnoteRef" id="fnref57"><sup>57</sup></a>, they have different colors.</p>
<p>A variant of this problem is <span><span style="font-variant: small-caps;">NP-complete</span></span>:</p>
<blockquote>
<p>Given <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G" alt="G" title="G" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%5Cin%20%5Cmathbf%7BN%7D" alt="k \in \mathbf{N}" title="k \in \mathbf{N}" />, can you edge color <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G" alt="G" title="G" /> with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> colors?</p>
</blockquote>
<p>Vizing’s Theorem states that for the maximum degree across all vertexes in a graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CDelta" alt="\Delta" title="\Delta" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CDelta%20%5Cle%20%5Ctext%7Bminimum%20number%20of%20colors%7D%20%5Cle%20%5CDelta%20%2B1%20" alt="\Delta \le \text{minimum number of colors} \le \Delta +1 " title="\Delta \le \text{minimum number of colors} \le \Delta +1 " />.</p>
<p>Furthermore, there exists a polynomial-time algorithm to color any graph with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CDelta%2B1" alt="\Delta+1" title="\Delta+1" /> colors.</p>
<p>Since the algorithm exists, we can approximate within <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%2B1" alt="+1" title="+1" /> of the <span><span style="font-variant: small-caps;">opt</span></span>solution.</p>
<p>This type of approximation (constant additive) is rare, since we usually get a good ratio of <span><span style="font-variant: small-caps;">approx</span></span>to <span><span style="font-variant: small-caps;">opt</span></span>.</p>
<h4 id="ssub:vertex_cover">Vertex Cover</h4>
<p>Given a graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G%20%3D%20%28V%2C%20E%29" alt="G = (V, E)" title="G = (V, E)" />, find a minimum-size - a set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=U%20%5Csubseteq%20V" alt="U \subseteq V" title="U \subseteq V" /> such that every edge has at least one endpoint in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=U" alt="U" title="U" />.</p>
<p>We can use this kind of algorithm to monitor all links in a network.</p>
<p>The decision version of Vertex-Cover is <span><span style="font-variant: small-caps;">NP-complete</span></span>. Where Independent set is the question to find the maximum set of vertexes where no two are joined by an edge, there is a reduction this way:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctextsc%7B3sat%7D%20%5Cle_p%20%5Ctext%7Bindependent%20set%7D%20%5Cle_p%20%5Ctext%7Bvertex%20cover%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \textsc{3sat} \le_p \text{independent set} \le_p \text{vertex cover}
                    \end{aligned}" title="\begin{aligned}
                        \textsc{3sat} \le_p \text{independent set} \le_p \text{vertex cover}
                    \end{aligned}" /><br /></p>
<p>The argument for reduction between vertex cover and independent set is that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=U%20%5Csubseteq%20V" alt="U \subseteq V" title="U \subseteq V" /> is a minimum vertex cover if and only if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V%20-%20U" alt="V - U" title="V - U" /> is a maximum independent set.</p>
<p>The existence of an approximation algorithm for vertex cover that’s good within an additive constant (as for edge coloring) implies <span><span style="font-variant: small-caps;">P</span></span>= <span><span style="font-variant: small-caps;">NP</span></span>.</p>
<h2 id="sec:greedy_algorithm_for_max_vertex_cover">Greedy Algorithm for Max Vertex Cover</h2>
<pre><code>maxCover(V):
    C = [];
    while true:
        if no edges remain: break;
        C.append(vertex of max degree)
        remove covered edges
                </code></pre>
<p>We will show that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CC%7C%20%5Cle%20O%28%5Clog%20n%29%20%7C%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7C" alt="|C| \le O(\log n) |{\textsc{opt}\xspace}|" title="|C| \le O(\log n) |{\textsc{opt}\xspace}|" />.</p>
<p>Exercise for reader (not in notes): Show that the greedy algorithm can give <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B%7CC%7C%7D%7B%7C%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7C%7D%20%5Cin%20%5COmega%20%28%5Clog%20n%29" alt="\frac{|C|}{|{\textsc{opt}\xspace}|} \in \Omega (\log n)" title="\frac{|C|}{|{\textsc{opt}\xspace}|} \in \Omega (\log n)" />.</p>
<h2 id="sec:set_cover_problem">Set Cover Problem</h2>
<p>The max vertex problem is a subset of the Set Cover problem.</p>
<p>Given a collection of sets <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_1%2C%20S_2%2C%20%5Cldots%2C%20S_k" alt="S_1, S_2, \ldots, S_k" title="S_1, S_2, \ldots, S_k" /> where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i%20%5Csubseteq%20%5B1%2C%20n%5D" alt="S_i \subseteq [1, n]" title="S_i \subseteq [1, n]" />. Find a minimum sized set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C%20%5Csubseteq%20%5B1%2C%20n%5D" alt="C \subseteq [1, n]" title="C \subseteq [1, n]" /> such that for all <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cin%20%5B1%2C%20n%5D" alt="i \in [1, n]" title="i \in [1, n]" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cin%20S_j" alt="i \in S_j" title="i \in S_j" /> for some <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j%20%5Cin%20C" alt="j \in C" title="j \in C" />.</p>
<p>In the real world, this works as follows:</p>
<blockquote>
<p>Where sets <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i" alt="S_i" title="S_i" /> are a type of pizza, and set elements <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> are individual people. An element <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%20%5Cin%20S_i" alt="e \in S_i" title="e \in S_i" /> means that the person eats that type of pizza. We want to find the minimum number of pizza types to feed all people.</p>
</blockquote>
<h3 id="sub:vertex_vs_set_cover">Vertex vs Set Cover</h3>
<p>We can show that vertex cover is a special case of Set Cover: Elements <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> of our sets are edges in the graph, and sets correspond to vertexes in our graph.</p>
<p>Since every element in our vertex cover is in exactly two of our sets, a A Set Cover that every element is in exactly two of our sets allows us to transform our Set Cover problem into a vertex cover.</p>
<h3 id="sub:greedy_approximation_algorithm_for_set_cover">Greedy Approximation Algorithm for Set Cover</h3>
<p>The idea is to iteratively choose the set that has the most yet uncovered elements.</p>
<pre><code>setCover(S[] s):
    C = []
    while there are uncovered elements:
        S[i] = a set that covers the max number of uncovered elements
        C.append(i)
                    </code></pre>
<p>We claim that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CC%7C%20%3D%20%7B%5Ctextsc%7Bapprox%7D%5Cxspace%7D%5Cle%20O%28%5Clog%20n%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="|C| = {\textsc{approx}\xspace}\le O(\log n) {\textsc{opt}\xspace}" title="|C| = {\textsc{approx}\xspace}\le O(\log n) {\textsc{opt}\xspace}" />, where <span><span style="font-variant: small-caps;">opt</span></span>is the minimum number of sets to cover all elements.</p>
<p>This proof is taken from Vazirani’s book<a href="#fn58" class="footnoteRef" id="fnref58"><sup>58</sup></a>, which is a simpler proof than the one presented in CLRS.</p>
<p>We distribute the cost (1) of choosing a set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i" alt="S_i" title="S_i" /> over the newly covered elements. Let <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%28e%29" alt="c(e)" title="c(e)" /> represent the cost of adding element <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" />.</p>
<p>We define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> as the maximum size set, since it is the first one chosen. For a defined element <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%20%5Cin%20S" alt="e \in S" title="e \in S" />, we define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%28e%29%20%3D%20%5Cfrac%7B1%7D%7B%7CS%7C%7D" alt="c(e) = \frac{1}{|S|}" title="c(e) = \frac{1}{|S|}" />. We know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CS%7C%20%3E%20" alt="|S| &gt; " title="|S| &gt; " /> the average number of elements per set in the <span><span style="font-variant: small-caps;">opt</span></span>solution. We also know that the average number of elements <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> per set in the <span><span style="font-variant: small-caps;">opt</span></span>solution is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Cfrac%7Bn%7D%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D" alt="\ge \frac{n}{{\textsc{opt}\xspace}}" title="\ge \frac{n}{{\textsc{opt}\xspace}}" />. This implies that for the first set we have:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20c%28e%29%20%26%5Cle%20%5Cfrac%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D%7Bn%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        c(e) &amp;\le \frac{{\textsc{opt}\xspace}}{n}
                    \end{aligned}" title="\begin{aligned}
                        c(e) &amp;\le \frac{{\textsc{opt}\xspace}}{n}
                    \end{aligned}" /><br /></p>
<p>More generally, let the ordering <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e_1%2C%20e_2%2C%20%5Cldots%2C%20e_i%2C%20%5Cldots%20e_n" alt="e_1, e_2, \ldots, e_i, \ldots e_n" title="e_1, e_2, \ldots, e_i, \ldots e_n" /> be an ordering of elements as they are covered (we expect many ties).</p>
<p>We define that the number elements newly covered by <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%27" alt="S&#39;" title="S&#39;" /> as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />. For a given <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e_i%20%5Cin%20S%27" alt="e_i \in S&#39;" title="e_i \in S&#39;" />, we know that the number of elements uncovered prior to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%27" alt="S&#39;" title="S&#39;" /> being chosen must be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20n%20-%20i%20%2B%201" alt="\ge n - i + 1" title="\ge n - i + 1" />.</p>
<p>Since the set picked is the one with the maximal <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />, we know that it must be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Ctextsc%7Bavg%7D" alt="\ge \textsc{avg}" title="\ge \textsc{avg}" /> on the range <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j%20%5Cge%20i" alt="j \ge i" title="j \ge i" /> covered by <span><span style="font-variant: small-caps;">opt</span></span>. We know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctextsc%7Bavg%7D%20%5Cge%20%5Cfrac%7Bn-i%2B1%7D%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D" alt="\textsc{avg} \ge \frac{n-i+1}{{\textsc{opt}\xspace}}" title="\textsc{avg} \ge \frac{n-i+1}{{\textsc{opt}\xspace}}" />, since any lower would mean that there are more than <span><span style="font-variant: small-caps;">opt</span></span>sets chosen in the <span><span style="font-variant: small-caps;">opt</span></span>solution. Thus, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%5Cge%20%5Cfrac%7Bn-i%2B1%7D%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D" alt="k \ge \frac{n-i+1}{{\textsc{opt}\xspace}}" title="k \ge \frac{n-i+1}{{\textsc{opt}\xspace}}" />, which implies that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%28e_i%29%20%5Cle%20%5Cfrac%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D%7Bn-i%2B1%7D" alt="c(e_i) \le \frac{{\textsc{opt}\xspace}}{n-i+1}" title="c(e_i) \le \frac{{\textsc{opt}\xspace}}{n-i+1}" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7Bnumber%20of%20sets%20chosen%20by%20greedy%7D%20%26%3D%20%5Csum_%7Bi%3D1%7D%5En%20c%28e_i%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cin%20O%28%5Clog%20n%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \text{number of sets chosen by greedy} &amp;= \sum_{i=1}^n c(e_i) \\
                        &amp;\in O(\log n) {\textsc{opt}\xspace}\end{aligned}" title="\begin{aligned}
                        \text{number of sets chosen by greedy} &amp;= \sum_{i=1}^n c(e_i) \\
                        &amp;\in O(\log n) {\textsc{opt}\xspace}\end{aligned}" /><br /></p>
<p>Thus, the number of sets chosen by the greedy is within a factor of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="O(\log n) {\textsc{opt}\xspace}" title="O(\log n) {\textsc{opt}\xspace}" />.</p>
<h1 id="cha:linear_programs_and_randomization">Linear Programs and Randomization</h1>
<h2 id="sec:vertex_cover">Vertex Cover</h2>
<p>Please recall the definition of the vertex cover problem on page , and the approximation within <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="O(\log n) {\textsc{opt}\xspace}" title="O(\log n) {\textsc{opt}\xspace}" /> presented on page .</p>
<h3 id="sub:constant_factor_approximation_for_vertex_cover">Constant-Factor Approximation for Vertex Cover</h3>
<p>There’s a “stupid” approximation algorithm for vertex cover that’s better than the greedy algorithm.</p>
<pre><code>vertex_cover(E, V):
    C = {}
    while E != {}:
        (u, v) = E.remove_random()
        e = {u, v}
        C.append(e)
        E.remove_connected_to([u, v])
    return C
                    </code></pre>
<p>Since we pick the set of edges is a matching<a href="#fn59" class="footnoteRef" id="fnref59"><sup>59</sup></a>. Where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M" alt="M" title="M" /> is the set of edges we pick, we know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CC%7C%20%3D%202%7CM%7C" alt="|C| = 2|M|" title="|C| = 2|M|" />. We also know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CM%7C%20%5Cle%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="|M| \le {\textsc{opt}\xspace}" title="|M| \le {\textsc{opt}\xspace}" />, since every matching edge needs its own vertex in the <span><span style="font-variant: small-caps;">opt</span></span>vertex cover.</p>
<p>Thus, our “stupid” greedy algorithm has <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CC%7C%20%3D%202%7CM%7C%20%5Cle%202%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="|C| = 2|M| \le 2 {\textsc{opt}\xspace}" title="|C| = 2|M| \le 2 {\textsc{opt}\xspace}" />, and thus gives us an approximation factor of 2.</p>
<h4 id="ssub:best_approximation_factor_known_for_vertex_cover">Best Approximation Factor Known for Vertex Cover</h4>
<p>The best approximation factor known for the Vertex Cover problem is 2.</p>
<h4 id="ssub:weighted_vertex_cover">Weighted Vertex Cover</h4>
<blockquote>
<p>Given weights on vertices <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=w%20%3A%20V%20%5Cto%20%5Cmathbf%7BR%7D%5E%2B" alt="w : V \to \mathbf{R}^+" title="w : V \to \mathbf{R}^+" />, find the vertex cover <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" /> of minimum weight <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Csum_%7Bv%20%5Cin%20C%7D%20w%28v%29" alt="\sum_{v \in C} w(v)" title="\sum_{v \in C} w(v)" />.</p>
</blockquote>
<p>In fact, we can express this as an integer linear program.</p>
<p>Create a variable <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%28v%29" alt="x(v)" title="x(v)" /> for each <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v%20%5Cin%20V" alt="v \in V" title="v \in V" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20x%28v%29%20%3D%20%5Cleft%5C%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cbegin%7Barray%7D%7Blr%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%201%20%26%20%3A%20v%20%5Cin%20C%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%200%20%26%20%3A%20v%20%5Cnotin%20C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Barray%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cright.%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        x(v) = \left\{
                            \begin{array}{lr}
                                1 &amp; : v \in C \\
                                0 &amp; : v \notin C
                            \end{array}
                        \right.
                    \end{aligned}" title="\begin{aligned}
                        x(v) = \left\{
                            \begin{array}{lr}
                                1 &amp; : v \in C \\
                                0 &amp; : v \notin C
                            \end{array}
                        \right.
                    \end{aligned}" /><br /></p>
<p>Now we’re trying to find the solution to the following linear program:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cmin%20%5Csum_%7Bv%20%5Cin%20V%7D%20w%28v%29%20x%28v%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \min \sum_{v \in V} w(v) x(v)
                    \end{aligned}" title="\begin{aligned}
                        \min \sum_{v \in V} w(v) x(v)
                    \end{aligned}" /><br /></p>
<p>Given the constraints that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cforall%20e%20%5Cin%20E%20%3A%20e%20%3D%20%28u%2C%20v%29%20%3A%20x%28u%29%20%2B%20x%28v%29%20%5Cge%201" alt="\forall e \in E : e = (u, v) : x(u) + x(v) \ge 1" title="\forall e \in E : e = (u, v) : x(u) + x(v) \ge 1" />, and bounding the values of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%28%29" alt="x()" title="x()" /> to be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%28v%29%20%5Cin%20%5C%7B0%2C%201%5C%7D" alt="x(v) \in \{0, 1\}" title="x(v) \in \{0, 1\}" />.</p>
<p>The solutions to this integer linear program are exactly minimum-weight vertex covers. While Integer Linear Programs (<span style="font-variant: small-caps;">ILP</span>) are <span><span style="font-variant: small-caps;">NP-complete</span></span><a href="#fn60" class="footnoteRef" id="fnref60"><sup>60</sup></a>, relaxing the constraints to be non-integer Linear Program (<span style="font-variant: small-caps;">LP</span>) allows us to use the simplex method (Refex to Subsection [sub:simplex<sub>m</sub>ethod]). To use simplex, we can relax <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%28v%29%20%5Cin%20%5C%7B0%2C%201%5C%7D" alt="x(v) \in \{0, 1\}" title="x(v) \in \{0, 1\}" /> to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x%28v%29%20%5Cin%20%5B0%2C%201%5D" alt="x(v) \in [0, 1]" title="x(v) \in [0, 1]" />.</p>
<p>Suppose that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbar%7Bx%7D" alt="\bar{x}" title="\bar{x}" /> is an optional solution to the linear program. Let <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C_%7B%5Ctextsc%7BLP%7D%7D%20%3D%20%5C%7B%20v%20%5Cin%20V%20%3A%20%5Cbar%7Bx%7D%28v%29%20%5Cge%20%5Cfrac%7B1%7D%7B2%7D%20%5C%7D" alt="C_{\textsc{LP}} = \{ v \in V : \bar{x}(v) \ge \frac{1}{2} \}" title="C_{\textsc{LP}} = \{ v \in V : \bar{x}(v) \ge \frac{1}{2} \}" />. Our linear program guarantees that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbar%7Bx%7D%28u%29%20%2B%20%5Cbar%7Bx%7D%28v%29%20%5Cge%201" alt="\bar{x}(u) + \bar{x}(v) \ge 1" title="\bar{x}(u) + \bar{x}(v) \ge 1" />, so at least one of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u%2C%20v" alt="u, v" title="u, v" /> has <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbar%7Bx%7D%28-%29%20%5Cge%20%5Cfrac%7B1%7D%7B2%7D" alt="\bar{x}(-) \ge \frac{1}{2}" title="\bar{x}(-) \ge \frac{1}{2}" />, and that vertex is definitely in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C_%7B%5Ctextsc%7BLP%7D%7D" alt="C_{\textsc{LP}}" title="C_{\textsc{LP}}" />. Then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C_%7B%5Ctextsc%7BLP%7D%7D" alt="C_{\textsc{LP}}" title="C_{\textsc{LP}}" /> is a vertex cover.</p>
<p>Starting with the premise that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Ctext%7B%20to%20%7D%20%5Ctextsc%7BILP%7D%20%5Cge%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Ctext%7B%20to%20%7D%20%5Ctextsc%7BLP%7D" alt="{\textsc{opt}\xspace}= {\textsc{opt}\xspace}\text{ to } \textsc{ILP} \ge {\textsc{opt}\xspace}\text{ to } \textsc{LP}" title="{\textsc{opt}\xspace}= {\textsc{opt}\xspace}\text{ to } \textsc{ILP} \ge {\textsc{opt}\xspace}\text{ to } \textsc{LP}" />, since the <span style="font-variant: small-caps;">lp</span> allows more solutions, so the <span><span style="font-variant: small-caps;">opt</span></span>decreases. Given that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbar%7Bx%7D%28-%29" alt="\bar{x}(-)" title="\bar{x}(-)" /> is the <span><span style="font-variant: small-caps;">opt</span></span>solution to the <span style="font-variant: small-caps;">LP</span>, we have:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%26%3D%20%5Csum%20w%28v%29%20%5Cbar%7Bx%7D%28v%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%5Csum_%7Bv%20%5Cin%20V%20%3A%20%5Cbar%7Bx%7D%28v%29%20%5Cge%200.5%7D%20w%28v%29%20%5Cbar%7Bx%7D%28v%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%5Csum_%7Bv%20%5Cin%20V%20%3A%20%5Cbar%7Bx%7D%28v%29%20%5Cge%200.5%7D%20w%28v%29%20%5Cfrac%7B1%7D%7B2%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bv%20%5Cin%20V%20%3A%20%5Cbar%7Bx%7D%28v%29%20%5Cge%200.5%7D%20w%28v%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B1%7D%7B2%7D%20w%28C_%7B%5Ctextsc%7BLP%7D%7D%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        {\textsc{opt}\xspace}&amp;= \sum w(v) \bar{x}(v) \\
                        &amp;\ge \sum_{v \in V : \bar{x}(v) \ge 0.5} w(v) \bar{x}(v) \\
                        &amp;\ge \sum_{v \in V : \bar{x}(v) \ge 0.5} w(v) \frac{1}{2} \\
                        &amp;= \frac{1}{2} \sum_{v \in V : \bar{x}(v) \ge 0.5} w(v) \\
                        &amp;= \frac{1}{2} w(C_{\textsc{LP}})
                    \end{aligned}" title="\begin{aligned}
                        {\textsc{opt}\xspace}&amp;= \sum w(v) \bar{x}(v) \\
                        &amp;\ge \sum_{v \in V : \bar{x}(v) \ge 0.5} w(v) \bar{x}(v) \\
                        &amp;\ge \sum_{v \in V : \bar{x}(v) \ge 0.5} w(v) \frac{1}{2} \\
                        &amp;= \frac{1}{2} \sum_{v \in V : \bar{x}(v) \ge 0.5} w(v) \\
                        &amp;= \frac{1}{2} w(C_{\textsc{LP}})
                    \end{aligned}" /><br /></p>
<p>So <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Cge%20%5Cfrac%7B1%7D%7B2%7D%20w%28C_%7B%5Ctextsc%7BLP%7D%7D%29" alt="{\textsc{opt}\xspace}\ge \frac{1}{2} w(C_{\textsc{LP}})" title="{\textsc{opt}\xspace}\ge \frac{1}{2} w(C_{\textsc{LP}})" /> or <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=w%28C_%7B%5Ctextsc%7BLP%7D%7D%29%20%5Cle%202%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="w(C_{\textsc{LP}}) \le 2 {\textsc{opt}\xspace}" title="w(C_{\textsc{LP}}) \le 2 {\textsc{opt}\xspace}" />.</p>
<h2 id="sec:set_cover_problem">Set Cover Problem</h2>
<blockquote>
<p>Given a collection of sets <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_1%2C%20S_2%2C%20%5Cldots%20S_k" alt="S_1, S_2, \ldots S_k" title="S_1, S_2, \ldots S_k" />, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i%20%5Csubseteq%20%5C%7B1%2C%20%5Cldots%2C%20n%20%5C%7D" alt="S_i \subseteq \{1, \ldots, n \}" title="S_i \subseteq \{1, \ldots, n \}" />, find a minimum size set of sets such that every element is covered.</p>
</blockquote>
<p>In other words, find <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C%20%5Csubseteq%20%5C%7B%201%2C%20%5Cldots%2C%20k%5C%7D" alt="C \subseteq \{ 1, \ldots, k\}" title="C \subseteq \{ 1, \ldots, k\}" /> such that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cforall%20i%20%5Cin%20%5C%7B1%2C%20%5Cldots%2C%20n%5C%7D" alt="\forall i \in \{1, \ldots, n\}" title="\forall i \in \{1, \ldots, n\}" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cin%20S_j" alt="i \in S_j" title="i \in S_j" /> for some <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j%20%5Cin%20C" alt="j \in C" title="j \in C" />.</p>
<p>For a Set Cover, the greedy algorithm gives <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20O%28%5Clog%20n%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="\le O(\log n) {\textsc{opt}\xspace}" title="\le O(\log n) {\textsc{opt}\xspace}" /> (refer to Subsection [sub:greedy<sub>a</sub>pproximation<sub>a</sub>lgorithm<sub>f</sub>or<sub>s</sub>et<sub>c</sub>over]).</p>
<p>There’s something that’s marginally better. Define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f" alt="f" title="f" /> as the maximum number of sets any single element <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e" alt="e" title="e" /> is contained in. For vertex cover, the elements are edges, and the sets are edges incident to a vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" />. <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f" alt="f" title="f" /> for vertex cover is 2, so it is a special case of Set Cover.</p>
<p>There is a polynomial time approximation algorithm using linear programming and duality for Set Cover that gives a solution of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20f%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="\le f {\textsc{opt}\xspace}" title="\le f {\textsc{opt}\xspace}" />, which is an approximation factor <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f" alt="f" title="f" />.</p>
<p>Depending on the difference between <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%20n" alt="\log n" title="\log n" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f" alt="f" title="f" />, one may be factor.</p>
<p>Later, we will prove that Set Cover has no constant factor approximation in polynomial time unless <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />.</p>
<h4 id="ssub:approximation_for_minimization_and_maximization_problems">Approximation For Minimization and Maximization Problems</h4>
<p>A <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crho" alt="\rho" title="\rho" />-approximization algorithm for a minimization problem guarantees that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%28I%29%20%5Cle%20%5Crho%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28I%29" alt="A(I) \le \rho {\textsc{opt}\xspace}(I)" title="A(I) \le \rho {\textsc{opt}\xspace}(I)" />, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crho%20%5Cge%201" alt="\rho \ge 1" title="\rho \ge 1" />.</p>
<p>A <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crho" alt="\rho" title="\rho" />-approximization algorithm for a maximization problem guarantees that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%28I%29%20%5Cge%20%5Crho%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28I%29" alt="A(I) \ge \rho {\textsc{opt}\xspace}(I)" title="A(I) \ge \rho {\textsc{opt}\xspace}(I)" />, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Crho%20%5Cle%201" alt="\rho \le 1" title="\rho \le 1" />.</p>
<p>Some texts use <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B%5Crho%7D" alt="\frac{1}{\rho}" title="\frac{1}{\rho}" /> for maximization problems. CLRS doesn’t do max, and Vazirani uses the convention here.</p>
<h4 id="ssub:max_cut_problem">Max-Cut Problem</h4>
<p>The Max Cut problem is a sub-type of the Set Cover problem.</p>
<blockquote>
<p>Given a graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G%20%3D%20%28V%2C%20E%29" alt="G = (V, E)" title="G = (V, E)" />, partition <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> into <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V%20-%20S" alt="V - S" title="V - S" /> to maximize the number of edges with one end in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> and another end in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" />.</p>
</blockquote>
<p>We define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%28S%29" alt="c(S)" title="c(S)" /> as the size of cut<a href="#fn61" class="footnoteRef" id="fnref61"><sup>61</sup></a> for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V%20-%20S" alt="V - S" title="V - S" />.</p>
<p>Without proof, the (decision version of the) Max-Cut problem is <span><span style="font-variant: small-caps;">NP-complete</span></span>, but the minimum cut can be found in polynomial time.</p>
<p>An approximation for Max Cut is as follows:</p>
<pre><code>max_cut(G):
    S = V.any_subset()
    while vertexes can be moved to increse c(S):
        move a vertex to increase c(S)
                    </code></pre>
<p>Given that we can increase <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%28S%29" alt="c(S)" title="c(S)" /> at most <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> times<a href="#fn62" class="footnoteRef" id="fnref62"><sup>62</sup></a>, we must have a polynomial time algorithm.</p>
<p>Define the number of edges inside <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%28s%29" alt="e(s)" title="e(s)" />, and the number of edges from <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d_S%28v%29" alt="d_S(v)" title="d_S(v)" />, and the number of edges from <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V-S" alt="V-S" title="V-S" /> as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d_%7BV-S%7D%28v%29" alt="d_{V-S}(v)" title="d_{V-S}(v)" />. At the end of the algorithm, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cforall%20v%20%5Cin%20S" alt="\forall v \in S" title="\forall v \in S" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d_S%28v%29%20%5Cle%20d_%7BV-S%7D%28v%29" alt="d_S(v) \le d_{V-S}(v)" title="d_S(v) \le d_{V-S}(v)" />, otherwise we would move it.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Csum_%7Bv%20%5Cin%20S%7D%20d_%7BV%20-%20S%7D%28v%29%20%26%5Cge%20%5Csum_%7Bv%20%5Cin%20S%7D%20d_S%28v%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cimplies%202e%28S%29%20%26%5Cle%20c%28S%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \sum_{v \in S} d_{V - S}(v) &amp;\ge \sum_{v \in S} d_S(v) \\
                        \implies 2e(S) &amp;\le c(S) \\
                    \end{aligned}" title="\begin{aligned}
                        \sum_{v \in S} d_{V - S}(v) &amp;\ge \sum_{v \in S} d_S(v) \\
                        \implies 2e(S) &amp;\le c(S) \\
                    \end{aligned}" /><br /></p>
<p>Similarly <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cforall%20v%20%5Cin%20V-S" alt="\forall v \in V-S" title="\forall v \in V-S" />: Thus:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20d_%7BV-S%7D%28v%29%20%26%5Cle%20d_%7BS%7D%28v%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Csum_%7Bv%20%5Cin%20V-S%7D%20d_%7BV-S%7D%28v%29%20%26%5Cle%20%5Csum_%7Bv%20%5Cin%20V-S%7D%20d_S%28v%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cimplies%202e%28V-S%29%20%26%5Cle%20c%28S%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        d_{V-S}(v) &amp;\le d_{S}(v) \\
                        \sum_{v \in V-S} d_{V-S}(v) &amp;\le \sum_{v \in V-S} d_S(v) \\
                        \implies 2e(V-S) &amp;\le c(S)
                    \end{aligned}" title="\begin{aligned}
                        d_{V-S}(v) &amp;\le d_{S}(v) \\
                        \sum_{v \in V-S} d_{V-S}(v) &amp;\le \sum_{v \in V-S} d_S(v) \\
                        \implies 2e(V-S) &amp;\le c(S)
                    \end{aligned}" /><br /></p>
<p>Since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20%3D%20e%28S%29%20%2B%20e%28V-S%29%20%2B%20c%28S%29" alt="m = e(S) + e(V-S) + c(S)" title="m = e(S) + e(V-S) + c(S)" />, we can say:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20m%20%26%3D%20e%28S%29%20%2B%20e%28V-S%29%20%2B%20c%28S%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%202m%20%26%3D%202e%28S%29%20%2B%202e%28V-S%29%20%2B%202c%28S%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20c%28S%29%20%2B%20c%28S%29%20%2B%202c%28S%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%204c%28S%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        m &amp;= e(S) + e(V-S) + c(S) \\
                        2m &amp;= 2e(S) + 2e(V-S) + 2c(S) \\
                        &amp;\le c(S) + c(S) + 2c(S) \\
                        &amp;= 4c(S)
                    \end{aligned}" title="\begin{aligned}
                        m &amp;= e(S) + e(V-S) + c(S) \\
                        2m &amp;= 2e(S) + 2e(V-S) + 2c(S) \\
                        &amp;\le c(S) + c(S) + 2c(S) \\
                        &amp;= 4c(S)
                    \end{aligned}" /><br /></p>
<p>Thus <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20%5Cle%202%20c%28S%29" alt="m \le 2 c(S)" title="m \le 2 c(S)" />, which means we have an approximation factor of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B2%7D" alt="\frac{1}{2}" title="\frac{1}{2}" />.</p>
<h4 id="ssub:random_algorithm_for_max_cut_problem">Random Algorithm for Max Cut Problem</h4>
<pre><code>max_cut(G):
    pick S at random
                    </code></pre>
<p>We can do this analysis:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%5Bc%28S%29%5D%20%26%3D%20E%5Cleft%5B%20%5Csum_%7Be%20%5Cin%20E%7D%20%5Csigma%28e%29%20%5Cright%5D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Csigma%28e%29%20%26%3D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cleft%5C%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cbegin%7Barray%7D%7Blr%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%201%20%3A%26%20%5Ctext%7B%20if%20%24e%24%20in%20cut%20%7D%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%200%20%3A%26%20%5Ctext%7B%20otherwise%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Barray%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cright.%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%5Bc%28S%29%5D%20%26%3D%20%5Csum_%7Be%20%5Cin%20E%7D%20E%5B%5Csigma%28e%29%5D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Csum_%7Be%20%5Cin%20E%7D%20%5Cfrac%7B1%7D%7B2%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7Bm%7D%7B2%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        E[c(S)] &amp;= E\left[ \sum_{e \in E} \sigma(e) \right] \\
                        \sigma(e) &amp;=
                            \left\{
                                \begin{array}{lr}
                                    1 :&amp; \text{ if $e$ in cut }\\
                                    0 :&amp; \text{ otherwise }
                                \end{array}
                            \right. \\
                        E[c(S)] &amp;= \sum_{e \in E} E[\sigma(e)] \\
                        &amp;= \sum_{e \in E} \frac{1}{2} \\
                        &amp;= \frac{m}{2}
                    \end{aligned}" title="\begin{aligned}
                        E[c(S)] &amp;= E\left[ \sum_{e \in E} \sigma(e) \right] \\
                        \sigma(e) &amp;=
                            \left\{
                                \begin{array}{lr}
                                    1 :&amp; \text{ if $e$ in cut }\\
                                    0 :&amp; \text{ otherwise }
                                \end{array}
                            \right. \\
                        E[c(S)] &amp;= \sum_{e \in E} E[\sigma(e)] \\
                        &amp;= \sum_{e \in E} \frac{1}{2} \\
                        &amp;= \frac{m}{2}
                    \end{aligned}" /><br /></p>
<p>By doing this repeatedly, we can get a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%29" alt="O(n)" title="O(n)" />-time algorithm with a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B2%7D" alt="\frac{1}{2}" title="\frac{1}{2}" /> approximation factor.</p>
<h4 id="ssub:state_of_the_art_in_max_cut">State of the Art in Max Cut</h4>
<p>The best known approximation factor for Max Cut is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0.878" alt="0.878" title="0.878" /> (unattributed).</p>
<h1 id="cha:max_sat">Max SAT</h1>
<blockquote>
<p>Given a set of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> clauses in <span style="font-variant: small-caps;">CNF</span> in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> boolean variables <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X%20%3D%20%5C%7Bx_1%2C%20%5Cldots%2C%20x_n%5C%7D" alt="X = \{x_1, \ldots, x_n\}" title="X = \{x_1, \ldots, x_n\}" />, find a boolean assignment to variables to make a maximum number of clauses true.</p>
</blockquote>
<p>The decision version of this problem is <span><span style="font-variant: small-caps;">NP-complete</span></span>, since it’s just the usual <span style="font-variant: small-caps;">sat</span> problem. For clauses of size <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%202" alt="\le 2" title="\le 2" />, it is still <span><span style="font-variant: small-caps;">NP-complete</span></span>. For problems with clauses are size 2, deciding if can be satisfied is in <span><span style="font-variant: small-caps;">P</span></span><a href="#fn63" class="footnoteRef" id="fnref63"><sup>63</sup></a>.</p>
<h2 id="sec:algorithm_for_max_sat">Algorithm for Max-<span style="font-variant: small-caps;">SAT</span></h2>
<p>The algorithm is to pick the truth assignment at random.</p>
<p>We know that for any clause <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" /> containing <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" /> different variables, we want to determine the probability that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" /> is satisfied:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctextsc%7BPr%7D%28%5Ctext%7B%24c%24%20is%20satisfied%7D%29%20%26%3D%201%20-%20%5Ctextsc%7BPr%7D%7B%5Ctext%7B%24c%24%20is%20not%20satisfied%7D%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%201%20-%20%5Cfrac%7B1%7D%7B2%5Et%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%281%20-%20%5Cfrac%7B1%7D%7B2%7D%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B1%7D%7B2%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    \textsc{Pr}(\text{$c$ is satisfied}) &amp;= 1 - \textsc{Pr}{\text{$c$ is not satisfied}} \\
                    &amp;= 1 - \frac{1}{2^t} \\
                    &amp;\ge (1 - \frac{1}{2}) \\
                    &amp;= \frac{1}{2}
                \end{aligned}" title="\begin{aligned}
                    \textsc{Pr}(\text{$c$ is satisfied}) &amp;= 1 - \textsc{Pr}{\text{$c$ is not satisfied}} \\
                    &amp;= 1 - \frac{1}{2^t} \\
                    &amp;\ge (1 - \frac{1}{2}) \\
                    &amp;= \frac{1}{2}
                \end{aligned}" /><br /></p>
<p>Thus the expected number of clauses satisfied is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Cfrac%7B1%7D%7B2%7D%20m" alt="\ge \frac{1}{2} m" title="\ge \frac{1}{2} m" />.</p>
<p>We know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Cle%20m" alt="{\textsc{opt}\xspace}\le m" title="{\textsc{opt}\xspace}\le m" />, so the expected <span><span style="font-variant: small-caps;">approx</span></span>factor is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B2%7D" alt="\frac{1}{2}" title="\frac{1}{2}" />.</p>
<h2 id="sec:facts_about_the_max_sat_problem">Facts about the Max-<span style="font-variant: small-caps;">SAT</span> problem</h2>
<p>By the probabilistic method<a href="#fn64" class="footnoteRef" id="fnref64"><sup>64</sup></a>, there always exists a truth value assignment that satisfies at least half the clauses.</p>
<p>The proof is essentially that since the expected value of a random variable is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Calpha" alt="\alpha" title="\alpha" />, then there is at least one value for the variable that has value <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Calpha" alt="\ge \alpha" title="\ge \alpha" />.</p>
<h2 id="sec:improved_approximation_algorithm_for_the_max_sat">Improved Algorithm for Max-<span style="font-variant: small-caps;">Sat</span></h2>
<p>By formulating this as an ILP problem, we can solve this using a LP relaxation (Similar to the Weighted Vertex Cover solution on Page ) and “randomized rounding” techniques.</p>
<p>Make variables <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_i" alt="x_i" title="x_i" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cin%20%5B1%2C%20n%5D" alt="i \in [1, n]" title="i \in [1, n]" /> for each boolean variable <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=a_i" alt="a_i" title="a_i" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y_i" alt="y_i" title="y_i" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cin%20%5B1%2C%20m%5D" alt="i \in [1, m]" title="i \in [1, m]" /> for each clause.</p>
<p>We want to maximize <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Csum_i%20y_i" alt="\sum_i y_i" title="\sum_i y_i" />.</p>
<p>We have one constraint per clause:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20c_1%20%3D%20%28%5Cbar%7Ba_1%7D%20%5Clor%20a_2%29%20%26%5Cto%20y_1%20%5Cle%20%281%20-%20x_1%29%20%2B%20x_2%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    c_1 = (\bar{a_1} \lor a_2) &amp;\to y_1 \le (1 - x_1) + x_2
                \end{aligned}" title="\begin{aligned}
                    c_1 = (\bar{a_1} \lor a_2) &amp;\to y_1 \le (1 - x_1) + x_2
                \end{aligned}" /><br /></p>
<p>And we have the LP relaxation constraints:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%200%20%5Cle%20%26x_i%20%5Cle%201%20%3A%20i%20%5Cin%20%5B1%2C%20n%5D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%200%20%5Cle%20%26y_i%20%5Cle%201%20%3A%20i%20%5Cin%20%5B1%2C%20m%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    0 \le &amp;x_i \le 1 : i \in [1, n] \\
                    0 \le &amp;y_i \le 1 : i \in [1, m]
                \end{aligned}" title="\begin{aligned}
                    0 \le &amp;x_i \le 1 : i \in [1, n] \\
                    0 \le &amp;y_i \le 1 : i \in [1, m]
                \end{aligned}" /><br /></p>
<p>Using the <span><span style="font-variant: small-caps;">P</span></span>LP approximation, we solve for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" />’s.</p>
<p>Then, we set our truth values <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%20%3D%20%5C%7B%20a_0%2C%20%5Cldots%2C%20a_n%5C%7D" alt="A = \{ a_0, \ldots, a_n\}" title="A = \{ a_0, \ldots, a_n\}" /> as follows:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20a_i%20%26%3D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cleft%5C%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cbegin%7Barray%7D%7Blr%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%201%20%3A%26%20%5Ctext%7B%20with%20probability%20%24x_i%24%20%7D%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%200%20%3A%26%20%5Ctext%7B%20otherwise%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Barray%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cright.%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    a_i &amp;=
                        \left\{
                            \begin{array}{lr}
                                1 :&amp; \text{ with probability $x_i$ }\\
                                0 :&amp; \text{ otherwise }
                            \end{array}
                        \right.
                \end{aligned}" title="\begin{aligned}
                    a_i &amp;=
                        \left\{
                            \begin{array}{lr}
                                1 :&amp; \text{ with probability $x_i$ }\\
                                0 :&amp; \text{ otherwise }
                            \end{array}
                        \right.
                \end{aligned}" /><br /></p>
<h4 id="ssub:analysis_of_randomized_max_2_sat">Analysis of Randomized Max 2-<span style="font-variant: small-caps;">sat</span></h4>
<p>We have a given <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c_2%20%3D%20%28a_1%20%5Clor%20a_2%29" alt="c_2 = (a_1 \lor a_2)" title="c_2 = (a_1 \lor a_2)" />. In a LP solution, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y%20%5Cle%20x_1%20%2B%20x_2" alt="y \le x_1 + x_2" title="y \le x_1 + x_2" />. Then we have:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7BPr%7D%28%5Ctext%7B%24c_2%24%20is%20satisfied%7D%29%20%26%3D%20%5Ctext%7BPr%7D%28a_1%20%3D%201%20%5Clor%20a_2%20%3D%201%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20x_1%20%2B%20x_2%20-%20x_1%20x_2%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20x_1%20%2B%20x_2%20-%20%5Cleft%28%20%5Cfrac%7Bx_1%20%2B%20x_2%7D%7B2%7D%20%5Cright%29%5E2%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20y_2%20-%20%5Cfrac%7By_2%5E2%7D%7B4%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20y_2%20-%20%5Cfrac%7By_2%7D%7B4%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B3%7D%7B4%7D%20y_2%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7BPr%7D%28%5Ctext%7B%24c_2%24%20is%20satisfied%7D%29%20%26%5Cge%20%5Cfrac%7B3%7D%7B4%7D%20y_2%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%5B%5Ctextsc%7Bnum%20of%20clauses%20satisfied%7D%5D%20%26%5Cge%20%5Cfrac%7B3%7D%7B4%7D%20%5Csum_i%20y_i%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B3%7D%7B4%7D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%7B%5Ctextsc%7Blp%7D%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cge%20%5Cfrac%7B3%7D%7B4%7D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%7B%5Ctextsc%7Bilp%7D%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cge%20%5Cfrac%7B3%7D%7B4%7D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%7B%5Ctextsc%7BMAX%20SAT%7D%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \text{Pr}(\text{$c_2$ is satisfied}) &amp;= \text{Pr}(a_1 = 1 \lor a_2 = 1) \\
                        &amp;= x_1 + x_2 - x_1 x_2 \\
                        &amp;\ge x_1 + x_2 - \left( \frac{x_1 + x_2}{2} \right)^2 \\
                        &amp;\ge y_2 - \frac{y_2^2}{4} \\
                        &amp;\ge y_2 - \frac{y_2}{4} \\
                        &amp;= \frac{3}{4} y_2 \\
                        \text{Pr}(\text{$c_2$ is satisfied}) &amp;\ge \frac{3}{4} y_2 \\
                        E[\textsc{num of clauses satisfied}] &amp;\ge \frac{3}{4} \sum_i y_i \\
                        &amp;= \frac{3}{4} {\textsc{opt}\xspace}_{\textsc{lp}}
                        \ge \frac{3}{4} {\textsc{opt}\xspace}_{\textsc{ilp}}
                        \ge \frac{3}{4} {\textsc{opt}\xspace}_{\textsc{MAX SAT}} \\
                    \end{aligned}" title="\begin{aligned}
                        \text{Pr}(\text{$c_2$ is satisfied}) &amp;= \text{Pr}(a_1 = 1 \lor a_2 = 1) \\
                        &amp;= x_1 + x_2 - x_1 x_2 \\
                        &amp;\ge x_1 + x_2 - \left( \frac{x_1 + x_2}{2} \right)^2 \\
                        &amp;\ge y_2 - \frac{y_2^2}{4} \\
                        &amp;\ge y_2 - \frac{y_2}{4} \\
                        &amp;= \frac{3}{4} y_2 \\
                        \text{Pr}(\text{$c_2$ is satisfied}) &amp;\ge \frac{3}{4} y_2 \\
                        E[\textsc{num of clauses satisfied}] &amp;\ge \frac{3}{4} \sum_i y_i \\
                        &amp;= \frac{3}{4} {\textsc{opt}\xspace}_{\textsc{lp}}
                        \ge \frac{3}{4} {\textsc{opt}\xspace}_{\textsc{ilp}}
                        \ge \frac{3}{4} {\textsc{opt}\xspace}_{\textsc{MAX SAT}} \\
                    \end{aligned}" /><br /></p>
<p>Thus, we expect the number of clauses satisfied to be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Cfrac%7B3%7D%7B4%7D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="\ge \frac{3}{4} {\textsc{opt}\xspace}" title="\ge \frac{3}{4} {\textsc{opt}\xspace}" />.</p>
<h4 id="ssub:analysis_of_randomized_max_sat">Analysis of Randomized Max SAT</h4>
<p>We won’t do the analysis, but it shows that this method is better for small clauses, and the algorithm described in Section [sec:algorithm<sub>f</sub>or<sub>m</sub>ax<sub>s</sub>at] is better for large clauses.</p>
<h2 id="sec:max_sat_retrospective">Max-Sat Retrospective</h2>
<p>The best-known max-<span style="font-variant: small-caps;">sat</span> algorithm is by Goemans &amp; Williamson `94, and is a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0.878" alt="0.878" title="0.878" /> approximation factor<a href="#fn65" class="footnoteRef" id="fnref65"><sup>65</sup></a>.</p>
<p>We also know that there is no approximation factor <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%200.942" alt="\ge 0.942" title="\ge 0.942" />, unless <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />.</p>
<p>So far, we’ve seen:</p>
<ul>
<li><p>metricTSP - Saw a 2-approximation, but know of a 1.5-approximation</p></li>
<li><p>Vertex Cover - 2-approximation</p></li>
<li><p>Set Cover - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /></p></li>
<li><p>Max cut - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B2%7D" alt="\frac{1}{2}" title="\frac{1}{2}" /></p></li>
<li><p>Max SAT - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B3%7D%7B2%7D" alt="\frac{3}{2}" title="\frac{3}{2}" /></p></li>
</ul>
<h2 id="sec:polynomial_time_approximation_scheme">Polynomial-Time Approximation Scheme</h2>
<p>These types of algorithms are ones where we can get arbitrarily close to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1" alt="1" title="1" />.</p>
<p>Though most of the details on these are in the next lesson (Chapter 16), we will go into a few proofs now.</p>
<p>Without proof, it is presented that:</p>
<blockquote>
<p>Polynomial-time <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Calpha" alt="\alpha" title="\alpha" />-approximation for the Independent set problem implies a polynomial-time <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Calpha" alt="\alpha" title="\alpha" />-approximation for Max 3-<span style="font-variant: small-caps;">sat</span>.</p>
</blockquote>
<h3 id="sub:reduction_preserving_constant_factor_approximation">Reduction Preserving Constant Factor Approximation</h3>
<p>In `92, this breakthrough result was published:</p>
<blockquote>
<p>If Max 3-<span style="font-variant: small-caps;">sat</span> has a <span><span style="font-variant: small-caps;">ptas</span></span>, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />.</p>
</blockquote>
<p>Joined with the previous theorem, then there is no <span><span style="font-variant: small-caps;">ptas</span></span>for the independent set unless <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />.</p>
<p>Proving this:</p>
<p>Given a Max 3-SAT formula <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=F" alt="F" title="F" />, we want to transform it into an independent set problem as a polynomial-time reduction <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7BMax%20%7D%203-%5Ctextsc%7Bsat%7D%20%5Cle_p%20%5Ctext%7BIndependent%20Set%7D" alt="\text{Max } 3-\textsc{sat} \le_p \text{Independent Set}" title="\text{Max } 3-\textsc{sat} \le_p \text{Independent Set}" />. While doing this, we want to preserve the approximation factor.</p>
<p>A clause <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%20%3D%20%28x_1%20%5Clor%20%5Cbar%7Bx_2%7D%20%5Clor%20x_3%29" alt="c = (x_1 \lor \bar{x_2} \lor x_3)" title="c = (x_1 \lor \bar{x_2} \lor x_3)" /> becomes a triangle, and an edge between <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28x_i%2C%20%5Cbar%7Bx_i%7D%29" alt="(x_i, \bar{x_i})" title="(x_i, \bar{x_i})" /> for all occurences of the inversion in the SAT problem. This can be seen in Figure [fig:indep<sub>s</sub>et<sub>t</sub>raingle].</p>
<p><img src="images/indep_set_traingle.png" title="fig:" alt="Independent Set from a Triangle" /> [fig:indep<sub>s</sub>et<sub>t</sub>raingle]</p>
<p>There truth value assignment that satisfies all <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> clauses iff there is an independent set of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> vertices.</p>
<p>In particular, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctext%7BMax%203-%5Ctextsc%7Bsat%7D%7D%28F%29%20%3D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctext%7BInd.%20Set%7D%20%28G%29" alt="{\textsc{opt}\xspace}_\text{Max 3-\textsc{sat}}(F) = {\textsc{opt}\xspace}_\text{Ind. Set} (G)" title="{\textsc{opt}\xspace}_\text{Max 3-\textsc{sat}}(F) = {\textsc{opt}\xspace}_\text{Ind. Set} (G)" />, and a polynomial time approximation for algorithm for Ind. Set that gives <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A_%5Ctext%7BInd.%20Set%7D%28G%29%20%5Cge%20%5Calpha%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctext%7BInd.%20Set%7D%28G%29" alt="A_\text{Ind. Set}(G) \ge \alpha {\textsc{opt}\xspace}_\text{Ind. Set}(G)" title="A_\text{Ind. Set}(G) \ge \alpha {\textsc{opt}\xspace}_\text{Ind. Set}(G)" /> implies a polynomial-time approximation algorithm for the max-<span style="font-variant: small-caps;">sat</span> that gives <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A_%5Ctext%7BMax%203-%5Ctextsc%7Bsat%7D%7D%28F%29%20%5Cge%20%5Calpha%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctext%7BMax%203-%5Ctextsc%7Bsat%7D%7D%28F%29" alt="A_\text{Max 3-\textsc{sat}}(F) \ge \alpha {\textsc{opt}\xspace}_\text{Max 3-\textsc{sat}}(F)" title="A_\text{Max 3-\textsc{sat}}(F) \ge \alpha {\textsc{opt}\xspace}_\text{Max 3-\textsc{sat}}(F)" />.</p>
<h3 id="sub:reduction_preserving_constant_factor_approximation_with_a_different_constant">Reduction Preserving Constant Factor Approximation, With a Different Constant</h3>
<p>We give an example where a reduction provides constant-factor approximation, but not the same constant.</p>
<p>We allude that the example here is a “gap-preserving reduction”, but we won’t learn more about it in this course.</p>
<p>We’d like to show how a polynomial-time <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%281%20%2B%20%5Cvarepsilon%29" alt="(1 + \varepsilon)" title="(1 + \varepsilon)" />-approximation for Vertex Cover implies a polynomial-time <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%281%20-%205%20%5Cvarepsilon%29" alt="(1 - 5 \varepsilon)" title="(1 - 5 \varepsilon)" />-approximation for Max 3-<span style="font-variant: small-caps;">sat</span>.</p>
<p>From this, we make the observations:</p>
<ul>
<li><p>With the breakthrough result from earlier, we now know that there’s no <span><span style="font-variant: small-caps;">ptas</span></span>for vertex cover (unless <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />).</p></li>
<li><p>We have a 2-approximation for Vertex Cover, but this promises us a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%281-5%29" alt="(1-5)" title="(1-5)" />-approximation, which is vacuous (and therefor it doesn’t apply).</p></li>
</ul>
<p>To prove our theorem, we need a reduction Max 3-<span style="font-variant: small-caps;">sat</span> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle" alt="\le" title="\le" /> vertex cover with a good approximation factor preservation.</p>
<p>Using the above, we can reduce Max 3-<span style="font-variant: small-caps;">sat</span> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle" alt="\le" title="\le" /> Ind. Set, plus the idea that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=U" alt="U" title="U" /> is an Ind. Set iff <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V-U" alt="V-U" title="V-U" /> is a vertex cover.</p>
<p>While this idea doesn’t give a good approximation factor in general, but we only need it for graphs that come from Max 3-<span style="font-variant: small-caps;">sat</span>. From earlier, picking random truth values for Max 3-<span style="font-variant: small-caps;">sat</span>, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%7B%5Ctextsc%7Bsat%7D%7D%20%5Cge%20%5Cfrac%7B1%7D%7B2%7Dm" alt="{\textsc{opt}\xspace}_{\textsc{sat}} \ge \frac{1}{2}m" title="{\textsc{opt}\xspace}_{\textsc{sat}} \ge \frac{1}{2}m" />.</p>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A_%5Ctextsc%7Bvc%7D%20%5Cle%20%281%20%2B%20%5Cvarepsilon%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bvc%7D" alt="A_\textsc{vc} \le (1 + \varepsilon) {\textsc{opt}\xspace}_\textsc{vc}" title="A_\textsc{vc} \le (1 + \varepsilon) {\textsc{opt}\xspace}_\textsc{vc}" /> by assumption.</p>
<p>By reduction, we get the approximate polynomial-time for Max 3-<span style="font-variant: small-caps;">sat</span> “<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A_%5Ctextsc%7Bsat%7D" alt="A_\textsc{sat}" title="A_\textsc{sat}" />”.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20A_%5Ctextsc%7Bsat%7D%20%26%3D%203m%20-%20A_%5Ctextsc%7Bvc%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bsat%7D%20%26%3D%203m%20-%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bvc%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        A_\textsc{sat} &amp;= 3m - A_\textsc{vc} \\
                        {\textsc{opt}\xspace}_\textsc{sat} &amp;= 3m - {\textsc{opt}\xspace}_\textsc{vc}
                    \end{aligned}" title="\begin{aligned}
                        A_\textsc{sat} &amp;= 3m - A_\textsc{vc} \\
                        {\textsc{opt}\xspace}_\textsc{sat} &amp;= 3m - {\textsc{opt}\xspace}_\textsc{vc}
                    \end{aligned}" /><br /></p>
<p>We want to prove that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A_%5Ctextsc%7Bsat%7D%20%5Cge%20%281%20-%205%20%5Cvarepsilon%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bsat%7D" alt="A_\textsc{sat} \ge (1 - 5 \varepsilon) {\textsc{opt}\xspace}_\textsc{sat}" title="A_\textsc{sat} \ge (1 - 5 \varepsilon) {\textsc{opt}\xspace}_\textsc{sat}" />.</p>
<p>From the above, we can reduce:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20A_%5Ctextsc%7Bsat%7D%20%26%3D%203m%20-%20A_%5Ctextsc%7Bvc%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%203m%20-%20%281%20%2B%20%5Cvarepsilon%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bvc%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%203m%20-%20%281%2B%20%5Cvarepsilon%29%283m%20-%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bsat%7D%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bsat%7D%20-%20%5Cvarepsilon%20m%20%2B%20%5Cvarepsilon%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bsat%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bsat%7D%20-%20%5Cvarepsilon%206%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bsat%7D%20%2B%20%5Cvarepsilon%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bsat%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D_%5Ctextsc%7Bsat%7D%20%281%20-%205%20%5Cvarepsilon%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        A_\textsc{sat} &amp;= 3m - A_\textsc{vc} \\
                        &amp;\ge 3m - (1 + \varepsilon) {\textsc{opt}\xspace}_\textsc{vc} \\
                        &amp;= 3m - (1+ \varepsilon)(3m - {\textsc{opt}\xspace}_\textsc{sat}) \\
                        &amp;= {\textsc{opt}\xspace}_\textsc{sat} - \varepsilon m + \varepsilon {\textsc{opt}\xspace}_\textsc{sat} \\
                        &amp;\ge {\textsc{opt}\xspace}_\textsc{sat} - \varepsilon 6 {\textsc{opt}\xspace}_\textsc{sat} + \varepsilon {\textsc{opt}\xspace}_\textsc{sat} \\
                        &amp;= {\textsc{opt}\xspace}_\textsc{sat} (1 - 5 \varepsilon)
                    \end{aligned}" title="\begin{aligned}
                        A_\textsc{sat} &amp;= 3m - A_\textsc{vc} \\
                        &amp;\ge 3m - (1 + \varepsilon) {\textsc{opt}\xspace}_\textsc{vc} \\
                        &amp;= 3m - (1+ \varepsilon)(3m - {\textsc{opt}\xspace}_\textsc{sat}) \\
                        &amp;= {\textsc{opt}\xspace}_\textsc{sat} - \varepsilon m + \varepsilon {\textsc{opt}\xspace}_\textsc{sat} \\
                        &amp;\ge {\textsc{opt}\xspace}_\textsc{sat} - \varepsilon 6 {\textsc{opt}\xspace}_\textsc{sat} + \varepsilon {\textsc{opt}\xspace}_\textsc{sat} \\
                        &amp;= {\textsc{opt}\xspace}_\textsc{sat} (1 - 5 \varepsilon)
                    \end{aligned}" /><br /></p>
<h1 id="cha:geometric_packing_ptas">Geometric Packing PTAS</h1>
<p>We’re going to look at packing problems.</p>
<h2 id="sec:set_packing">Set Packing</h2>
<p>We can express set packing through the following statement:</p>
<blockquote>
<p>Given elements <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5C%7B1%2C%20%5Cldots%2C%20n%5C%7D" alt="\{1, \ldots, n\}" title="\{1, \ldots, n\}" /> and sets <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5C%7BS_1%2C%20%5Cldots%2C%20S_k%5C%7D" alt="\{S_1, \ldots, S_k\}" title="\{S_1, \ldots, S_k\}" />, with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i%20%5Csubseteq%20%5B1%2C%20n%5D" alt="S_i \subseteq [1, n]" title="S_i \subseteq [1, n]" />. Find the maximum set of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i" alt="S_i" title="S_i" /> such that no two sets intersect.</p>
</blockquote>
<p>There’s a graph version of the same problem:</p>
<blockquote>
<p>Given a graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G%20%3D%20%28V%2C%20E%29" alt="G = (V, E)" title="G = (V, E)" />, find a maximum size subset <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=U%20%5Csubseteq%20V" alt="U \subseteq V" title="U \subseteq V" /> such that no edge <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%20%3D%20%28u%2C%20v%29" alt="e = (u, v)" title="e = (u, v)" /> has both endpoints in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=U" alt="U" title="U" />.</p>
</blockquote>
<p>The largest Indep. Set (See the definition of this problem inside Section [sec:vertex<sub>c</sub>over]) is a special case of set packing, where all edges incident to vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v_i" alt="v_i" title="v_i" /> is the set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S_i" alt="S_i" title="S_i" />.</p>
<p>The independent set problem is <span><span style="font-variant: small-caps;">NP-complete</span></span>, and we can turn general set packing into the independent set problem, therefore set packing is <span><span style="font-variant: small-caps;">NP-complete</span></span>.</p>
<p>In fact, there is no <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%5E%7B1-%5Cvarepsilon%7D" alt="n^{1-\varepsilon}" title="n^{1-\varepsilon}" />-approximation ratio for independent set, unless <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />.</p>
<h2 id="sec:geometric_set_packing_with_squares">Geometric Set Packing With Squares</h2>
<blockquote>
<p>Given <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> unit squares in the plane. Find the maximum number of squares such that no two intersect.</p>
</blockquote>
<h3 id="sub:simple_constant_factor_approximation_for_packing_unit_squares">Simple Constant Factor Approximation For Packing Unit Squares</h3>
<pre><code>pick_non_intersecting(S[] squares):
    ans = []
    while (|S| != 0):
        sq = s.random()
        s.remove_intersecting(sq)
        ans.append(sq)
    return ans
                    </code></pre>
<p>This is a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B4%7D" alt="\frac{1}{4}" title="\frac{1}{4}" />-approximation algorithm because at one square chosen by <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> intersects at most four squares in <span><span style="font-variant: small-caps;">opt</span></span>.</p>
<p>Thus, each square of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> intersects <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%204" alt="\le 4" title="\le 4" /> squares of <span><span style="font-variant: small-caps;">opt</span></span>. Therefore <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Cle%204%20A" alt="{\textsc{opt}\xspace}\le 4 A" title="{\textsc{opt}\xspace}\le 4 A" />.</p>
<h3 id="sub:grid_approximation_algorithm">Grid Approximation Algorithm</h3>
<p>If we represent squares by their center points, and put down a unit grid with the “even” squares, we can get the set of points from each of the shaded squares.</p>
<p>Let <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R_0" alt="R_0" title="R_0" /> be the set of shaded squares. In fact, we can define:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20R_0%20%26%3D%20%5C%7B%20%28x%2C%20y%29%20%3A%20%7B%5Cleft%20%5Clfloor%20x%20%5Cright%20%5Crfloor%20%7D%20%5Ctext%7B%20is%20even%7D%2C%20%7B%5Cleft%20%5Clfloor%20y%20%5Cright%20%5Crfloor%20%7D%20%5Ctext%7B%20is%20even%7D%5C%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20R_1%20%26%3D%20%5C%7B%20%28x%2C%20y%29%20%3A%20%7B%5Cleft%20%5Clfloor%20x%20%5Cright%20%5Crfloor%20%7D%20%5Ctext%7B%20is%20odd%7D%2C%20%7B%5Cleft%20%5Clfloor%20y%20%5Cright%20%5Crfloor%20%7D%20%5Ctext%7B%20is%20even%7D%5C%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20R_2%20%26%3D%20%5C%7B%20%28x%2C%20y%29%20%3A%20%7B%5Cleft%20%5Clfloor%20x%20%5Cright%20%5Crfloor%20%7D%20%5Ctext%7B%20is%20even%7D%2C%20%7B%5Cleft%20%5Clfloor%20y%20%5Cright%20%5Crfloor%20%7D%20%5Ctext%7B%20is%20odd%7D%5C%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20R_3%20%26%3D%20%5C%7B%20%28x%2C%20y%29%20%3A%20%7B%5Cleft%20%5Clfloor%20x%20%5Cright%20%5Crfloor%20%7D%20%5Ctext%7B%20is%20odd%7D%2C%20%7B%5Cleft%20%5Clfloor%20y%20%5Cright%20%5Crfloor%20%7D%20%5Ctext%7B%20is%20odd%7D%5C%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        R_0 &amp;= \{ (x, y) : {\left \lfloor x \right \rfloor } \text{ is even}, {\left \lfloor y \right \rfloor } \text{ is even}\} \\
                        R_1 &amp;= \{ (x, y) : {\left \lfloor x \right \rfloor } \text{ is odd}, {\left \lfloor y \right \rfloor } \text{ is even}\} \\
                        R_2 &amp;= \{ (x, y) : {\left \lfloor x \right \rfloor } \text{ is even}, {\left \lfloor y \right \rfloor } \text{ is odd}\} \\
                        R_3 &amp;= \{ (x, y) : {\left \lfloor x \right \rfloor } \text{ is odd}, {\left \lfloor y \right \rfloor } \text{ is odd}\}
                    \end{aligned}" title="\begin{aligned}
                        R_0 &amp;= \{ (x, y) : {\left \lfloor x \right \rfloor } \text{ is even}, {\left \lfloor y \right \rfloor } \text{ is even}\} \\
                        R_1 &amp;= \{ (x, y) : {\left \lfloor x \right \rfloor } \text{ is odd}, {\left \lfloor y \right \rfloor } \text{ is even}\} \\
                        R_2 &amp;= \{ (x, y) : {\left \lfloor x \right \rfloor } \text{ is even}, {\left \lfloor y \right \rfloor } \text{ is odd}\} \\
                        R_3 &amp;= \{ (x, y) : {\left \lfloor x \right \rfloor } \text{ is odd}, {\left \lfloor y \right \rfloor } \text{ is odd}\}
                    \end{aligned}" /><br /></p>
<p>The best way to show this is through a figure. Refer to Figure [fig:grid<sub>a</sub>pprox<sub>a</sub>lg] for a pictorial example.</p>
<p><img src="images/grid_approx_alg.png" title="fig:" alt="Grid Approximation Algorithm" /> [fig:grid<sub>a</sub>pprox<sub>a</sub>lg]</p>
<p>The algorithm is to take one point from each shaded square <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R_0%20%5Ccap%20P" alt="R_0 \cap P" title="R_0 \cap P" />, if there is one.</p>
<pre><code>grid_approx_alg(P Point[]):
    for i = 0...3:
        Q[i] = opt solution R_i.intersect(P)
    return max(Q)
                    </code></pre>
<p>We know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CQ%7C%20%5Cge%20%5Cfrac%7B1%7D%7B4%7D%20%5Csum%20%7CQ_i%7C" alt="|Q| \ge \frac{1}{4} \sum |Q_i|" title="|Q| \ge \frac{1}{4} \sum |Q_i|" />, since we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cmax%20%5Cge%20%5Ctext%7Bavg%7D" alt="\max \ge \text{avg}" title="\max \ge \text{avg}" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%26%3D%20%5Csum_%7Bi%3D0%7D%5E3%20%7C%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Ccap%20R_i%7C%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%5Csum_%7Bi%3D0%7D%5E3%20%7CQ_i%7C%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%204%7CQ%7C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        {\textsc{opt}\xspace}&amp;= \sum_{i=0}^3 | {\textsc{opt}\xspace}\cap R_i| \\
                        &amp;\le \sum_{i=0}^3 |Q_i| \\
                        &amp;\le 4|Q|
                    \end{aligned}" title="\begin{aligned}
                        {\textsc{opt}\xspace}&amp;= \sum_{i=0}^3 | {\textsc{opt}\xspace}\cap R_i| \\
                        &amp;\le \sum_{i=0}^3 |Q_i| \\
                        &amp;\le 4|Q|
                    \end{aligned}" /><br /></p>
<p>Thus, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CQ%7C%20%5Cge%20%5Cfrac%7B1%7D%7B4%7D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="|Q| \ge \frac{1}{4} {\textsc{opt}\xspace}" title="|Q| \ge \frac{1}{4} {\textsc{opt}\xspace}" />.</p>
<h3 id="sub:arbitrary_grid_approximation_algorithm">Arbitrary Grid Approximation Algorithm</h3>
<p>It turns out that we can get arbitrarily close to an approximation factor of 1, using a “shifting grid” approach<a href="#fn66" class="footnoteRef" id="fnref66"><sup>66</sup></a></p>
<p>We pick a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%5Cge%202" alt="k \ge 2" title="k \ge 2" />, and let <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R_%7Bi%2C%20j%7D" alt="R_{i, j}" title="R_{i, j}" /> be defined as:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20R_%7Bi%2C%20j%7D%20%26%3D%20%5C%7B%20%28x%2C%20y%29%3A%20%7B%5Cleft%20%5Clfloor%20x%20%5Cright%20%5Crfloor%20%7D%20%5C%25%20k%20%5Cnot%20%3D%20i%2C%20%7B%5Cleft%20%5Clfloor%20y%20%5Cright%20%5Crfloor%20%7D%20%5C%25%20k%20%5Cnot%20%3D%20j%20%5C%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        R_{i, j} &amp;= \{ (x, y): {\left \lfloor x \right \rfloor } \% k \not = i, {\left \lfloor y \right \rfloor } \% k \not = j \}
                    \end{aligned}" title="\begin{aligned}
                        R_{i, j} &amp;= \{ (x, y): {\left \lfloor x \right \rfloor } \% k \not = i, {\left \lfloor y \right \rfloor } \% k \not = j \}
                    \end{aligned}" /><br /></p>
<p>Over <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cin%20%5B0%2C%20k-1%5D" alt="i \in [0, k-1]" title="i \in [0, k-1]" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j%20%5Cin%20%5B0%2C%20k-1%5D" alt="j \in [0, k-1]" title="j \in [0, k-1]" />. Refer to Figure [] for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%3D3" alt="k=3" title="k=3" />.</p>
<p><img src="images/arbitrary_grid_approx_alg.png" title="fig:" alt="Arbitrary Grid Approximation Algorithm" /> [fig:arbitrary<sub>g</sub>rid<sub>a</sub>pprox<sub>a</sub>lg]</p>
<p>Note that our points lie in a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%5Ccdot%20n" alt="n\cdot n" title="n\cdot n" /> square without loss of generality.</p>
<p>For a given <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />, the number of black squares is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Cfrac%7Bn%7D%7Bk%7D%20%5Ccdot%20%5Cfrac%7Bn%7D%7Bk%7D%20%3D%20%5Cfrac%7Bn%5E2%7D%7Bk%5E2%7D" alt="\le \frac{n}{k} \cdot \frac{n}{k} = \frac{n^2}{k^2}" title="\le \frac{n}{k} \cdot \frac{n}{k} = \frac{n^2}{k^2}" />.</p>
<p>Also, the number of points we can choose in a single black square is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%28k%20-%201%29%5E2" alt="\le (k - 1)^2" title="\le (k - 1)^2" />.</p>
<p>Since each set of black squares is independent, we can solve the problem optimally for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R_%7Bi%2Cj%7D%20%5Ccap%20P" alt="R_{i,j} \cap P" title="R_{i,j} \cap P" /> in polynomial time by trying all possible subsets of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%28k-1%29%5E2" alt="\le (k-1)^2" title="\le (k-1)^2" /> points. There are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E%7B%28k-1%29%5E2%7D%29" alt="O(n^{(k-1)^2})" title="O(n^{(k-1)^2})" /> possible subsets per square.</p>
<p>The algorithm is as follows:</p>
<pre><code>arbitrary_grid_approximation_algorithm(P, k):
    for i=[0, k-1]:
        for j=[0, k-1]:
            Q[i][j] = R[i][j].intersect(P)
    return max(Q)
                    </code></pre>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cmax%20%26%5Cge%20%5Ctext%7Bavg%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cimplies%20%7CQ%7C%20%5Cge%20%5Cfrac%7B1%7D%7Bk%5E2%7D%20%5Csum_%7Bi%2Cj%3D0%7D%5E%7Bk-1%7D%20Q_%7Bi%2C%20j%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \max &amp;\ge \text{avg} \\
                        \implies |Q| \ge \frac{1}{k^2} \sum_{i,j=0}^{k-1} Q_{i, j}
                    \end{aligned}" title="\begin{aligned}
                        \max &amp;\ge \text{avg} \\
                        \implies |Q| \ge \frac{1}{k^2} \sum_{i,j=0}^{k-1} Q_{i, j}
                    \end{aligned}" /><br /></p>
<p>Since each point is in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28k-1%29%5E2" alt="(k-1)^2" title="(k-1)^2" /> of the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=R_%7Bi%2Cj%7D" alt="R_{i,j}" title="R_{i,j}" />’s, then we have:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%28k-1%29%5E2%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%26%3D%20%5Csum_%7Bi%2Cj%7D%20%7C%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Ccap%20R_%7Bi%2C%20j%7D%20%7C%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%5Csum_%7Bi%2C%20j%7D%20%7C%20Q_%7Bi%2C%20j%7D%20%7C%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20k%5E2%20%7C%20Q%20%7C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        (k-1)^2 {\textsc{opt}\xspace}&amp;= \sum_{i,j} | {\textsc{opt}\xspace}\cap R_{i, j} | \\
                        &amp;\le \sum_{i, j} | Q_{i, j} | \\
                        &amp;\le k^2 | Q |
                    \end{aligned}" title="\begin{aligned}
                        (k-1)^2 {\textsc{opt}\xspace}&amp;= \sum_{i,j} | {\textsc{opt}\xspace}\cap R_{i, j} | \\
                        &amp;\le \sum_{i, j} | Q_{i, j} | \\
                        &amp;\le k^2 | Q |
                    \end{aligned}" /><br /></p>
<p>So we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CQ%7C%20%5Cge%20%5Cfrac%7B%28k-1%29%5E2%7D%7Bk%5E2%7D%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="|Q| \ge \frac{(k-1)^2}{k^2}{\textsc{opt}\xspace}" title="|Q| \ge \frac{(k-1)^2}{k^2}{\textsc{opt}\xspace}" /> with a runtime <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28k%5E2%20n%5E%7B%28k-1%29%5E2%7D%29" alt="O(k^2 n^{(k-1)^2})" title="O(k^2 n^{(k-1)^2})" />.</p>
<h2 id="sec:ptas_like_definitions">PTAS-like Definitions</h2>
<p>You’d think that using these for so long, we would’ve defined this stuff already:</p>
<dl>
<dt>Approximation Scheme</dt>
<dd><p>an algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" />, input <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=I" alt="I" title="I" /> and parameter <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvarepsilon" alt="\varepsilon" title="\varepsilon" />.</p>
<ul>
<li><p>For min problem: <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%28I%2C%20%5Cvarepsilon%29%20%5Cle%20%281%20%2B%20%5Cvarepsilon%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28I%29" alt="A(I, \varepsilon) \le (1 + \varepsilon) {\textsc{opt}\xspace}(I)" title="A(I, \varepsilon) \le (1 + \varepsilon) {\textsc{opt}\xspace}(I)" /></p></li>
<li><p>For max problem: <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%28I%2C%20%5Cvarepsilon%29%20%5Cge%20%281%20-%20%5Cvarepsilon%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28I%29" alt="A(I, \varepsilon) \ge (1 - \varepsilon) {\textsc{opt}\xspace}(I)" title="A(I, \varepsilon) \ge (1 - \varepsilon) {\textsc{opt}\xspace}(I)" /></p></li>
</ul>
</dd>
<dt>Polynomial Time Approximation Scheme (PTAS)</dt>
<dd><p>an algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> that for each fixed <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvarepsilon" alt="\varepsilon" title="\varepsilon" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> runs in <span><span style="font-variant: small-caps;">P</span></span>time in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%3D%20%7CI%7C" alt="n = |I|" title="n = |I|" />. e.g. <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E%5Cfrac%7B1%7D%7B%5Cvarepsilon%7D%29" alt="O(n^\frac{1}{\varepsilon})" title="O(n^\frac{1}{\varepsilon})" />.</p>
</dd>
<dt>Fully Polynomial Time Approximation Scheme (FPTAS)</dt>
<dd><p>an algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> that runs in <span><span style="font-variant: small-caps;">P</span></span>time in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%3D%20%7CI%7C" alt="n = |I|" title="n = |I|" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B%5Cvarepsilon%7D" alt="\frac{1}{\varepsilon}" title="\frac{1}{\varepsilon}" />. e.g. <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Cfrac%7B1%7D%7B%5Cvarepsilon%7D%5E2%20n%5E3%29" alt="O(\frac{1}{\varepsilon}^2 n^3)" title="O(\frac{1}{\varepsilon}^2 n^3)" />.</p>
</dd>
</dl>
<p>For the algorithm described in Subsection [sub:arbitrary<sub>g</sub>rid<sub>a</sub>pproximation<sub>a</sub>lgorithm], the approximation factor <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B%28k-1%29%5E2%7D%7Bk%5E2%7D%20%3D%201%20-%20%5Cfrac%7B2k%20-%201%7D%7Bk%5E2%7D" alt="\frac{(k-1)^2}{k^2} = 1 - \frac{2k - 1}{k^2}" title="\frac{(k-1)^2}{k^2} = 1 - \frac{2k - 1}{k^2}" />, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvarepsilon%20%3D%20%5Cfrac%7B2k%20-%201%7D%7Bk%5E2%7D" alt="\varepsilon = \frac{2k - 1}{k^2}" title="\varepsilon = \frac{2k - 1}{k^2}" />.</p>
<p>The runtime is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28k%5E2%20n%5E%7B%28k-1%29%5E2%7D%29" alt="O(k^2 n^{(k-1)^2})" title="O(k^2 n^{(k-1)^2})" />. We have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvarepsilon%20%3C%20%5Cfrac%7B2k%7D%7Bk%7D%20%3D%20%5Cfrac%7B2%7D%7Bk%7D" alt="\varepsilon &lt; \frac{2k}{k} = \frac{2}{k}" title="\varepsilon &lt; \frac{2k}{k} = \frac{2}{k}" />, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%3C%20%5Cfrac%7B2%7D%7B%5Cvarepsilon%7D" alt="k &lt; \frac{2}{\varepsilon}" title="k &lt; \frac{2}{\varepsilon}" />. Also we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28k-1%29%5E2%20%3C%20k%5E2%20%3C%20%5Cfrac%7B4%7D%7B%5Cvarepsilon%5E2%7D" alt="(k-1)^2 &lt; k^2 &lt; \frac{4}{\varepsilon^2}" title="(k-1)^2 &lt; k^2 &lt; \frac{4}{\varepsilon^2}" />. So we have the overall runtime in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Cfrac%7B1%7D%7B%5Cvarepsilon%5E2%7D%20n%20%5E%7B%5Cfrac%7B4%7D%7B%5Cvarepsilon%5E2%7D%7D%29" alt="O(\frac{1}{\varepsilon^2} n ^{\frac{4}{\varepsilon^2}})" title="O(\frac{1}{\varepsilon^2} n ^{\frac{4}{\varepsilon^2}})" />. Thus this is a <span><span style="font-variant: small-caps;">ptas</span></span>but not a <span><span style="font-variant: small-caps;">fptas</span></span>.</p>
<h1 id="cha:bin_packing_ptas">Bin Packing PTAS</h1>
<p>Bin packing is a cool problem.</p>
<h2 id="sec:bin_packing_description_and_variants">Bin Packing Description and Variants</h2>
<blockquote>
<p>Given <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> numbers<a href="#fn67" class="footnoteRef" id="fnref67"><sup>67</sup></a> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%20%3D%20%5C%7Bs_1%2C%20%5Cldots%2C%20s_n%5C%7D" alt="S = \{s_1, \ldots, s_n\}" title="S = \{s_1, \ldots, s_n\}" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_i%20%5Cin%20%5B0%2C%201%5D" alt="s_i \in [0, 1]" title="s_i \in [0, 1]" />. Pack <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> into the minimal number of unit bins possible.</p>
</blockquote>
<p>This problem is <span><span style="font-variant: small-caps;">NP-hard</span></span>, since it generalizes the <span style="font-variant: small-caps;">partition</span> problem:</p>
<blockquote>
<p>Given <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> as above, we can we split <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> into two bins <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=U" alt="U" title="U" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S-U" alt="S-U" title="S-U" /> such that:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Csum_%7Bs%20%5Cin%20U%7D%20s%20%26%3D%20%5Csum_%7Bs%20%5Cin%20S-U%7D%20s%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \sum_{s \in U} s &amp;= \sum_{s \in S-U} s
                    \end{aligned}" title="\begin{aligned}
                        \sum_{s \in U} s &amp;= \sum_{s \in S-U} s
                    \end{aligned}" /><br /></p>
</blockquote>
<p>There are two variants to this problem:</p>
<dl>
<dt>Online</dt>
<dd><p>numbers in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> arrive one at a time and must be inserted to bins immediately.</p>
</dd>
<dt>Offline</dt>
<dd><p>all numbers in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> arrive simultaneously.</p>
</dd>
</dl>
<h2 id="sec:first_fit_bin_packing">First-Fit Bin Packing</h2>
<p>The first-fit algorithm is really simple:</p>
<blockquote>
<p>Insert the element into the first bin that fits it.</p>
</blockquote>
<p>Due to the algorithm’s simplicity, this can be done online.</p>
<p>Let <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> be the number of bins used by first fit. Since no two bins are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Cfrac%7B1%7D%7B2%7D" alt="\le \frac{1}{2}" title="\le \frac{1}{2}" /> full, then at least <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20-%201" alt="m - 1" title="m - 1" /> bins are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3E%20%5Cfrac%7B1%7D%7B2%7D" alt="&gt; \frac{1}{2}" title="&gt; \frac{1}{2}" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cfrac%7B1%7D%7B2%7D%20%28m-1%29%20%3C%20%5Csum%20s_i%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20m%20%26%3C%202%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%2B%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    \frac{1}{2} (m-1) &lt; \sum s_i \\
                    &amp;\le {\textsc{opt}\xspace}\\
                    m &amp;&lt; 2{\textsc{opt}\xspace}+ 1
                \end{aligned}" title="\begin{aligned}
                    \frac{1}{2} (m-1) &lt; \sum s_i \\
                    &amp;\le {\textsc{opt}\xspace}\\
                    m &amp;&lt; 2{\textsc{opt}\xspace}+ 1
                \end{aligned}" /><br /></p>
<p>So <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20%5Cle%202%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="m \le 2 {\textsc{opt}\xspace}" title="m \le 2 {\textsc{opt}\xspace}" />.</p>
<p>We state without proof that the first fit algorithm uses <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%201.7%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%2B%201" alt="\le 1.7 {\textsc{opt}\xspace}+ 1" title="\le 1.7 {\textsc{opt}\xspace}+ 1" /> bins, and this is tight<a href="#fn68" class="footnoteRef" id="fnref68"><sup>68</sup></a>.</p>
<h2 id="sec:first_fit_decreasing_bin_packing">First Fit Decreasing Bin Packing</h2>
<p>An off-line algorithm allows us to sort our input in a decreasing order.</p>
<p>First-fit decreasing sorts <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" /> descending, then applies the first fit algorithm.</p>
<p>We have the asymptotic ration of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B11%7D%7B9%7D%20%3D%201.22" alt="\frac{11}{9} = 1.22" title="\frac{11}{9} = 1.22" />, which is tight.</p>
<h2 id="sec:ptas_for_offline_bin_packing">PTAS for offline Bin Packing</h2>
<p>For any constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvarepsilon%20%3E%200" alt="\varepsilon &gt; 0" title="\varepsilon &gt; 0" />, there is a polynomial-time algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%27" alt="A&#39;" title="A&#39;" />that uses <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%281%20%2B%20%5Cvarepsilon%29%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%2B%201" alt="\le (1 + \varepsilon){\textsc{opt}\xspace}+ 1" title="\le (1 + \varepsilon){\textsc{opt}\xspace}+ 1" /> bins.</p>
<p>The “<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%2B1" alt="+1" title="+1" /> bins” is crucial:</p>
<blockquote>
<p>Prove that 2 bins there is no <span><span style="font-variant: small-caps;">P</span></span>time approximation algorithm with an approximation factor of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3C%201.5" alt="&lt; 1.5" title="&lt; 1.5" /> (unless <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />).</p>
</blockquote>
<p>The algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%27" alt="A&#39;" title="A&#39;" /> is built from two cases:</p>
<ol>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cforall%20i%3A%20s_i%20%5Cge%20%5Cdelta" alt="\forall i: s_i \ge \delta" title="\forall i: s_i \ge \delta" />, and there are only <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> possible values of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_i" alt="s_i" title="s_i" /> for constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cdelta" alt="\delta" title="\delta" />.</p>
<p>We can solve exactly through brute force enumeration.</p>
<p>There are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Cfrac%7B1%7D%7B%5Cdelta%7D" alt="\le \frac{1}{\delta}" title="\le \frac{1}{\delta}" /> items in each bin, so there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%5E%5Cfrac%7B1%7D%7B%5Cdelta%7D" alt="k^\frac{1}{\delta}" title="k^\frac{1}{\delta}" /> ways to fill each bin. Given that there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20n" alt="\le n" title="\le n" /> bins, where each bin has <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%5E%5Cfrac%7B1%7D%7B%5Cdelta%7D" alt="k^\frac{1}{\delta}" title="k^\frac{1}{\delta}" /> choices. Overall, we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E%7Bk%5E%5Cfrac%7B1%7D%7B%5Cdelta%7D%7D%29" alt="O(n^{k^\frac{1}{\delta}})" title="O(n^{k^\frac{1}{\delta}})" />, which is polynomial for fixed <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cdelta" alt="\delta" title="\delta" />, but huge.</p>
<p>Apparently we can do better with ILP algorithms.</p></li>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cforall%20i%3A%20s_i%20%5Cge%20%5Cdelta" alt="\forall i: s_i \ge \delta" title="\forall i: s_i \ge \delta" /> for some constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cdelta" alt="\delta" title="\delta" />.</p>
<p>We convert this to the first case by rounding.</p>
<p>Sort values of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_i" alt="s_i" title="s_i" /> ascending, and chop every <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> values of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_i" alt="s_i" title="s_i" /> (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> is chosen later).</p>
<p>Create a set with modified input rounded up to the nearest <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_%7B%5Cfrac%7Bni%7D%7Bk%7D%7D" alt="s_{\frac{ni}{k}}" title="s_{\frac{ni}{k}}" />:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20S%5E%2B%20%26%3D%20%5C%7B%20s_%7B%5Cfrac%7Bn%7D%7Bk%7D%7D%2C%20%5Cldots%20s_%5Cfrac%7Bn%7D%7Bk%7D%2C%20s_%7B%5Cfrac%7B2n%7D%7Bk%7D%7D%2C%20%5Cldots%20s_%5Cfrac%7B2n%7D%7Bk%7D%2C%20%5Cldots%20s_%7Bn%7D%2C%20%5Cldots%20s_n%20%5C%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                            S^+ &amp;= \{ s_{\frac{n}{k}}, \ldots s_\frac{n}{k}, s_{\frac{2n}{k}}, \ldots s_\frac{2n}{k}, \ldots s_{n}, \ldots s_n \}
                        \end{aligned}" title="\begin{aligned}
                            S^+ &amp;= \{ s_{\frac{n}{k}}, \ldots s_\frac{n}{k}, s_{\frac{2n}{k}}, \ldots s_\frac{2n}{k}, \ldots s_{n}, \ldots s_n \}
                        \end{aligned}" /><br /></p>
<p>In other words, there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7Bn%7D%7Bk%7D" alt="\frac{n}{k}" title="\frac{n}{k}" /> of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_%7B%5Cfrac%7Bn%7D%7Bk%7D%7D" alt="s_{\frac{n}{k}}" title="s_{\frac{n}{k}}" />.</p>
<p>We then apply part 1 to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%5E%2B" alt="S^+" title="S^+" />.</p>
<p>If we define <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%5E-" alt="S^-" title="S^-" /> similarly to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%5E%2B" alt="S^+" title="S^+" /> but instead rounding down instead of up, then we have:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%5E-%29%20%26%5Cle%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%5E%2B%29%20%26%5Cle%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%5E-%29%20%2B%20%5Cfrac%7Bn%7D%7Bk%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29%20%2B%20%5Cfrac%7Bn%7D%7Bk%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                            {\textsc{opt}\xspace}(S^-) &amp;\le {\textsc{opt}\xspace}(S) \\
                            {\textsc{opt}\xspace}(S^+) &amp;\le {\textsc{opt}\xspace}(S^-) + \frac{n}{k} \\
                            &amp;\le {\textsc{opt}\xspace}(S) + \frac{n}{k}
                        \end{aligned}" title="\begin{aligned}
                            {\textsc{opt}\xspace}(S^-) &amp;\le {\textsc{opt}\xspace}(S) \\
                            {\textsc{opt}\xspace}(S^+) &amp;\le {\textsc{opt}\xspace}(S^-) + \frac{n}{k} \\
                            &amp;\le {\textsc{opt}\xspace}(S) + \frac{n}{k}
                        \end{aligned}" /><br /></p>
<p>Now <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%5Cdelta%20%5Cle%20%5Csum%20s_i%20%5Cle%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29" alt="n \delta \le \sum s_i \le {\textsc{opt}\xspace}(S)" title="n \delta \le \sum s_i \le {\textsc{opt}\xspace}(S)" />, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%5Cle%20%5Cfrac%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29%7D%7B%5Cdelta%7D" alt="n \le \frac{{\textsc{opt}\xspace}(S)}{\delta}" title="n \le \frac{{\textsc{opt}\xspace}(S)}{\delta}" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%5E%2B%29%20%26%5Cle%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29%20%2B%20%5Cfrac%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29%7D%7Bk%5Cdelta%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29%20%2B%20%5Cleft%28%201%20%2B%20%5Cfrac%7B1%7D%7Bk%20%5Cdelta%7D%20%5Cright%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                            {\textsc{opt}\xspace}(S^+) &amp;\le {\textsc{opt}\xspace}(S) + \frac{{\textsc{opt}\xspace}(S)}{k\delta} \\
                            &amp;= {\textsc{opt}\xspace}(S) + \left( 1 + \frac{1}{k \delta} \right)
                        \end{aligned}" title="\begin{aligned}
                            {\textsc{opt}\xspace}(S^+) &amp;\le {\textsc{opt}\xspace}(S) + \frac{{\textsc{opt}\xspace}(S)}{k\delta} \\
                            &amp;= {\textsc{opt}\xspace}(S) + \left( 1 + \frac{1}{k \delta} \right)
                        \end{aligned}" /><br /></p>
<p>If we set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%3D%20%5Cfrac%7B1%7D%7B%5Cdelta%5E2%7D" alt="k = \frac{1}{\delta^2}" title="k = \frac{1}{\delta^2}" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%5E%2B%29%20%5Cle%20opt%28S%29%281%20%2B%20%5Cdelta%29" alt="{\textsc{opt}\xspace}(S^+) \le opt(S)(1 + \delta)" title="{\textsc{opt}\xspace}(S^+) \le opt(S)(1 + \delta)" />.</p></li>
</ol>
<p>The final algorithm uses case 2 to pack all <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_i" alt="s_i" title="s_i" />’s where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_i%20%5Cge%20%5Cdelta" alt="s_i \ge \delta" title="s_i \ge \delta" />, then use first fit to pack the remaining <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_i" alt="s_i" title="s_i" />’s in the empty spaces of all bins.</p>
<h3 id="sub:analysis_of_the_ptas">Analysis of the PTAS</h3>
<p>Our goal is to prove that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%20%5Cle%20%281%20%2B%20%5Cvarepsilon%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%2B%201" alt="A \le (1 + \varepsilon) {\textsc{opt}\xspace}+ 1" title="A \le (1 + \varepsilon) {\textsc{opt}\xspace}+ 1" />.</p>
<p>If the second part does not use new bins, then it’s ok to use <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cdelta%20%3D%20%5Cvarepsilon" alt="\delta = \varepsilon" title="\delta = \varepsilon" />.</p>
<p>Otherwise, we have use <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> bins in our algorithm.</p>
<p>Only the last bin can have size <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%201%20-%20%5Cdelta" alt="\le 1 - \delta" title="\le 1 - \delta" />, otherwise first fit wouldn’t have filled the last bin. Then:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Csum%20s_i%20%5Cge%20%28m-1%29%281-%5Cdelta%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20m%20%5Cle%20%5Cfrac%7B%5Csum%20s_i%7D%7B1-%5Cdelta%7D%20%2B%201%20%5Cle%20%5Cfrac%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29%7D%7B1%20-%20%5Cdelta%7D%20%2B%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \sum s_i \ge (m-1)(1-\delta) \\
                        m \le \frac{\sum s_i}{1-\delta} + 1 \le \frac{{\textsc{opt}\xspace}(S)}{1 - \delta} + 1
                    \end{aligned}" title="\begin{aligned}
                        \sum s_i \ge (m-1)(1-\delta) \\
                        m \le \frac{\sum s_i}{1-\delta} + 1 \le \frac{{\textsc{opt}\xspace}(S)}{1 - \delta} + 1
                    \end{aligned}" /><br /></p>
<p>If we choose <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B1-%5Cdelta%7D%20%3D%201%20%2B%20%5Cvarepsilon" alt="\frac{1}{1-\delta} = 1 + \varepsilon" title="\frac{1}{1-\delta} = 1 + \varepsilon" />, then we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cdelta%20%3D%20%5Cfrac%7B%5Cvarepsilon%7D%7B1%20%2B%20%5Cvarepsilon%7D" alt="\delta = \frac{\varepsilon}{1 + \varepsilon}" title="\delta = \frac{\varepsilon}{1 + \varepsilon}" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20%5Cle%20%281%20%2B%20%5Cvarepsilon%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29%20%2B%201" alt="m \le (1 + \varepsilon) {\textsc{opt}\xspace}(S) + 1" title="m \le (1 + \varepsilon) {\textsc{opt}\xspace}(S) + 1" /> as desired.</p>
<p>The runtime is as follows:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20O%28n%5E%7Bk%5E%5Cfrac%7B1%7D%7B%5Cdelta%7D%7D%29%20%26%3D%20O%5Cleft%28n%5E%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Cleft%28%20%5Cfrac%7B%281%20%2B%20%5Cvarepsilon%29%5E2%7D%7B%5Cvarepsilon%7D%20%5Cright%29%20%5E%5Cfrac%7B1%2B%5Cvarepsilon%7D%7B%5Cvarepsilon%7D%7D%0A%5Cright%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        O(n^{k^\frac{1}{\delta}}) &amp;= O\left(n^                        {\left( \frac{(1 + \varepsilon)^2}{\varepsilon} \right) ^\frac{1+\varepsilon}{\varepsilon}}
\right)
                    \end{aligned}" title="\begin{aligned}
                        O(n^{k^\frac{1}{\delta}}) &amp;= O\left(n^                        {\left( \frac{(1 + \varepsilon)^2}{\varepsilon} \right) ^\frac{1+\varepsilon}{\varepsilon}}
\right)
                    \end{aligned}" /><br /></p>
<h2 id="sec:improvements_for_bin_packing_algorithms">Improvements for Bin Packing Algorithms</h2>
<p>Karmarkar and Karp in `82 created an asymptotic <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%281%20%2B%20%5Cvarepsilon%29" alt="(1 + \varepsilon)" title="(1 + \varepsilon)" />-approximation that runs in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%5Cleft%28%20%5Cleft%28%5Cfrac%7B1%7D%7B%5Cvarepsilon%7D%20%5Cright%29%5E8%20n%20%5Clog%20n%20%5Cright%29" alt="O\left( \left(\frac{1}{\varepsilon} \right)^8 n \log n \right)" title="O\left( \left(\frac{1}{\varepsilon} \right)^8 n \log n \right)" /> time. This is an example of a FPTAS.</p>
<p>It is <span><span style="font-variant: small-caps;">open</span></span>if we can get <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n_%5Ctext%7Bbins%7D%20%5Cle%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28S%29%20%2B%20O%281%29" alt="n_\text{bins} \le {\textsc{opt}\xspace}(S) + O(1)" title="n_\text{bins} \le {\textsc{opt}\xspace}(S) + O(1)" /> in <span><span style="font-variant: small-caps;">P</span></span>time.</p>
<h1 id="cha:knapsack_fptas">Knapsack FPTAS</h1>
<h2 id="sec:problem_background">Problem Background</h2>
<blockquote>
<p>Give objects <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1%20%5Cldots%20n" alt="1 \ldots n" title="1 \ldots n" />, each with size <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_i%20%5Cin%20%5Cmathbf%7BN%7D" alt="s_i \in \mathbf{N}" title="s_i \in \mathbf{N}" /> and profit <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i%20%5Cin%20%5Cmathbf%7BN%7D" alt="p_i \in \mathbf{N}" title="p_i \in \mathbf{N}" />, given knapsack capacity <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B" alt="B" title="B" /> find <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=K%20%5Csubseteq%20%5C%7B1%2C%20%5Cldots%2C%20n%20%5C%7D" alt="K \subseteq \{1, \ldots, n \}" title="K \subseteq \{1, \ldots, n \}" /> such that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Csum_%7Bi%20%5Cin%20K%7D%20s_i%20%5Cle%20B" alt="\sum_{i \in K} s_i \le B" title="\sum_{i \in K} s_i \le B" /> while maximizing <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Csum_%7Bi%20%5Cin%20K%7D%20p_i" alt="\sum_{i \in K} p_i" title="\sum_{i \in K} p_i" />.</p>
</blockquote>
<p>The decision version of this problem is <span><span style="font-variant: small-caps;">NP-complete</span></span><a href="#fn69" class="footnoteRef" id="fnref69"><sup>69</sup></a>.</p>
<h2 id="sec:pseudo_polynomial_time_algorithm_for_knapsack_with_dp">Pseudo-Polynomial Time Algorithm for Knapsack with DP</h2>
<p>We want to find a solution to the knapsack problem using a DP solution.</p>
<p>A subproblem <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%28i%2C%20p%29" alt="S(i, p)" title="S(i, p)" /> is defined as the minimum size of the subset of items in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5B1%2C%20i%5D" alt="[1, i]" title="[1, i]" /> with profit of exactly <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p" alt="p" title="p" />.</p>
<p>Our algorithm is as follows:</p>
<pre><code>knapsack_dp(S[] s, P[] p, B):
    p_max = max(P)
    sums = [n][p_max];
    for p = [1, p_max]:
        if (p == p[1]):
            sums[1][p] = p[1]
        else:
            sums[1][p] = infinity
    for i = [2, n]:
        for p = [1, p_max]:
            sums[i][p] = min(sums[i-1][p], sums[i-1][p-p[i]] + s[i])
    return max p such that sums[n][p] &lt;= B
                </code></pre>
<p>The runtime of this is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Cverb%7Cp_max%7C%29" alt="O(n \verb|p_max|)" title="O(n \verb|p_max|)" />, which is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E2%20%5Cmax_i%28p_i%29%29" alt="O(n^2 \max_i(p_i))" title="O(n^2 \max_i(p_i))" />.</p>
<p>This algorithm is pseudo-polynomial time, since the runtime depends on the largest <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" />, not on the size of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" />’s, which is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%28p_i%29" alt="\log(p_i)" title="\log(p_i)" /> bits.</p>
<p>Some <span><span style="font-variant: small-caps;">NP-complete</span></span>problems don’t have pseudo-polynomial time algorithms (unless <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />). For example, <span style="font-variant: small-caps;">tsp</span> is still <span><span style="font-variant: small-caps;">NP-complete</span></span>with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0-1" alt="0-1" title="0-1" /> weights, since it still can be reduced to the Hamiltonian cycle problem.</p>
<h2 id="sec:fptas_for_the_knapsack_problem">FPTAS for the Knapsack Problem</h2>
<p>The idea is that if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" /> is few bits, then the pseudo-polynomial time algorithm runs in polynomial time <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E2%20%5Cmax_i%20%28p_i%29%29" alt="O(n^2 \max_i (p_i))" title="O(n^2 \max_i (p_i))" />. So let’s round <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" />’s to have few bits.</p>
<p>Run the following algorithm for a value of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" />:</p>
<pre><code>knapsack_fptas(epsilon, S[] s, P[] p_initial, B):
    t = ...
    P[] p = new P[p_initial.length]
    for i = [0, p_initial.length]:
        p[i] = floor(p_initial[i]/t)
    return knapsack_dp(s, p, B)
                </code></pre>
<p>Suppose the result returns <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=K%28t%29%20%5Csubseteq%20%5B1%2C%20n%5D" alt="K(t) \subseteq [1, n]" title="K(t) \subseteq [1, n]" />. <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=K%28t%29" alt="K(t)" title="K(t)" /> is feasible, since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Csum_%7Bi%20%5Cin%20K%28t%29%7D%20s_i%20%5Cle%20B" alt="\sum_{i \in K(t)} s_i \le B" title="\sum_{i \in K(t)} s_i \le B" />.</p>
<p>We need to analyze <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P%28K%28t%29%29%20%3D%20%5Csum_%7Bi%20%5Cin%20K%28t%29%7D%20p_i" alt="P(K(t)) = \sum_{i \in K(t)} p_i" title="P(K(t)) = \sum_{i \in K(t)} p_i" /> compared to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P%28K%5E%2A%29%20%3D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D" alt="P(K^*) = {\textsc{opt}\xspace}" title="P(K^*) = {\textsc{opt}\xspace}" />.</p>
<p>We know that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i%20-%20t%20%3C%20tp%27_i%20%5Cle%20p_i" alt="p_i - t &lt; tp&#39;_i \le p_i" title="p_i - t &lt; tp&#39;_i \le p_i" />. Then we have:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Csum_%7Bi%20%5Cin%20K%28t%29%7D%20p_i%20%26%5Cge%20%5Csum_%7Bi%20%5Cin%20K%28t%29%7D%20tp%27_i%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%5Csum_%7Bi%20%5Cin%20K%5E%2A%7D%20tp%27_i%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%5Csum_%7Bi%20%5Cin%20K%5E%2A%7D%28p_i%20-%20t%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Csum_%7Bi%20%5Cin%20K%5E%2A%7Dp_i%20-%20t%7CK%5E%2A%7C%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D-%20t%7CK%5E%2A%7C%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D-%20tn%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Cleft%281%20-%20%5Cfrac%7Btn%7D%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D%5Cright%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%5Cleft%28%201%20-%20%5Cfrac%7Btn%7D%7B%5Cmax_i%20%28p_i%29%7D%20%5Cright%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    \sum_{i \in K(t)} p_i &amp;\ge \sum_{i \in K(t)} tp&#39;_i \\
                    &amp;\ge \sum_{i \in K^*} tp&#39;_i \\
                    &amp;\ge \sum_{i \in K^*}(p_i - t) \\
                    &amp;= \sum_{i \in K^*}p_i - t|K^*| \\
                    &amp;\ge {\textsc{opt}\xspace}- t|K^*| \\
                    &amp;\ge {\textsc{opt}\xspace}- tn \\
                    &amp;= {\textsc{opt}\xspace}\left(1 - \frac{tn}{{\textsc{opt}\xspace}}\right) \\
                    &amp;\ge {\textsc{opt}\xspace}\left( 1 - \frac{tn}{\max_i (p_i)} \right)
                \end{aligned}" title="\begin{aligned}
                    \sum_{i \in K(t)} p_i &amp;\ge \sum_{i \in K(t)} tp&#39;_i \\
                    &amp;\ge \sum_{i \in K^*} tp&#39;_i \\
                    &amp;\ge \sum_{i \in K^*}(p_i - t) \\
                    &amp;= \sum_{i \in K^*}p_i - t|K^*| \\
                    &amp;\ge {\textsc{opt}\xspace}- t|K^*| \\
                    &amp;\ge {\textsc{opt}\xspace}- tn \\
                    &amp;= {\textsc{opt}\xspace}\left(1 - \frac{tn}{{\textsc{opt}\xspace}}\right) \\
                    &amp;\ge {\textsc{opt}\xspace}\left( 1 - \frac{tn}{\max_i (p_i)} \right)
                \end{aligned}" /><br /></p>
<p>We want <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%281%20-%20%5Cvarepsilon%29" alt="\ge {\textsc{opt}\xspace}(1 - \varepsilon)" title="\ge {\textsc{opt}\xspace}(1 - \varepsilon)" />, so we choose <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" /> such that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvarepsilon%20%3D%20%5Cfrac%7Btn%7D%7B%5Cmax_i%20%28p_i%29%7D" alt="\varepsilon = \frac{tn}{\max_i (p_i)}" title="\varepsilon = \frac{tn}{\max_i (p_i)}" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t%20%3D%20%5Cfrac%7B%5Cvarepsilon%20%5Cmax_i%20p_i%7D%7Bn%7D" alt="t = \frac{\varepsilon \max_i p_i}{n}" title="t = \frac{\varepsilon \max_i p_i}{n}" />.</p>
<p>The runtime is in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E2%20%5Cmax_i%20%28p%27_i%29%29" alt="O(n^2 \max_i (p&#39;_i))" title="O(n^2 \max_i (p&#39;_i))" />. We know that:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20p%27_i%20%26%3D%20%7B%5Cleft%20%5Clfloor%20%5Cfrac%7Bp_i%7D%7Bt%7D%20%5Cright%20%5Crfloor%20%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%7B%5Cleft%20%5Clfloor%20%20%5Cfrac%7Bn%20p_i%7D%7B%5Cvarepsilon%20%5Cmax_i%20%28p_i%29%7D%20%5Cright%20%5Crfloor%20%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%20%5Cfrac%7Bn%7D%7B%5Cvarepsilon%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    p&#39;_i &amp;= {\left \lfloor \frac{p_i}{t} \right \rfloor } \\
                    &amp;= {\left \lfloor  \frac{n p_i}{\varepsilon \max_i (p_i)} \right \rfloor } \\
                    &amp;\le \frac{n}{\varepsilon}
                \end{aligned}" title="\begin{aligned}
                    p&#39;_i &amp;= {\left \lfloor \frac{p_i}{t} \right \rfloor } \\
                    &amp;= {\left \lfloor  \frac{n p_i}{\varepsilon \max_i (p_i)} \right \rfloor } \\
                    &amp;\le \frac{n}{\varepsilon}
                \end{aligned}" /><br /></p>
<p>Thus, the runtime is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E3%20%5Cfrac%7B1%7D%7B%5Cvarepsilon%7D%29" alt="O(n^3 \frac{1}{\varepsilon})" title="O(n^3 \frac{1}{\varepsilon})" />, which means it’s a FPTAS.</p>
<h3 id="sub:comments_on_the_state_of_the_art">Comments on the State-of-the-Art</h3>
<p>The best known algorithm has the runtime <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20%5Cfrac%7B1%7D%7B%5Cvarepsilon%7D%20%2B%20%5Cleft%28%20%5Cfrac%7B1%7D%7B%5Cvarepsilon%7D%20%5Cright%29%5E4%29" alt="O(n \log \frac{1}{\varepsilon} + \left( \frac{1}{\varepsilon} \right)^4)" title="O(n \log \frac{1}{\varepsilon} + \left( \frac{1}{\varepsilon} \right)^4)" />. The general idea is to separate it into large profit items and small profit items, then to use the large ones first.</p>
<h3 id="sub:fptas_and_pseudo_polynomial_time_algorithms">FPTAS and Pseudo-Polynomial Time Algorithms</h3>
<p>Though we’ve shown that for the knapsack problem, having a pseudo-polynomial time algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cto" alt="\to" title="\to" /> FPTAS, it’s not known (i.e. it’s <span><span style="font-variant: small-caps;">open</span></span>) that this is true in general.</p>
<p>Garey &amp; Johnson in `78 proved that if a problem has a FPTAS<a href="#fn70" class="footnoteRef" id="fnref70"><sup>70</sup></a>, then there must exist a pseudo-polynomial time algorithm for the problem.</p>
<p>The idea is that with a minimization problem and a obj function that’s integer-valued (this is the technical assumption, I’m not sure what it means), and a bound of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%3C%20q%20%28%7CI_%5Ctext%7Bunary%7D%7C%29" alt="{\textsc{opt}\xspace}&lt; q (|I_\text{unary}|)" title="{\textsc{opt}\xspace}&lt; q (|I_\text{unary}|)" />, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=I_%5Ctext%7Bunary%7D" alt="I_\text{unary}" title="I_\text{unary}" /> is the input with numbers expressed in unary and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=q" alt="q" title="q" /> is some polynomial.</p>
<p>Suppose our algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> is a FPTAS with runtime <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p%28%7CI%7C%2C%20%5Cfrac%7B1%7D%7B%5Cvarepsilon%7D%29" alt="p(|I|, \frac{1}{\varepsilon})" title="p(|I|, \frac{1}{\varepsilon})" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%28I%29%20%5Cle%20%281%20%2B%20%5Cvarepsilon%29%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28I%29" alt="A(I) \le (1 + \varepsilon) {\textsc{opt}\xspace}(I)" title="A(I) \le (1 + \varepsilon) {\textsc{opt}\xspace}(I)" />.</p>
<p>Picking that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvarepsilon" alt="\varepsilon" title="\varepsilon" /> small enough to get the <span><span style="font-variant: small-caps;">opt</span></span>, we can argue that this is pseudo-polynomial.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cvarepsilon%20%26%3D%20%5Cfrac%7B1%7D%7Bq%28%7CI_%5Ctext%7Bunary%7D%7C%29%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20A%28I%29%20%26%5Cle%20%281%20%2B%20%5Cvarepsilon%29%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28I%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3C%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28I%29%20%2B%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        \varepsilon &amp;= \frac{1}{q(|I_\text{unary}|)} \\
                        A(I) &amp;\le (1 + \varepsilon){\textsc{opt}\xspace}(I) \\
                        &amp;&lt; {\textsc{opt}\xspace}(I) + 1
                    \end{aligned}" title="\begin{aligned}
                        \varepsilon &amp;= \frac{1}{q(|I_\text{unary}|)} \\
                        A(I) &amp;\le (1 + \varepsilon){\textsc{opt}\xspace}(I) \\
                        &amp;&lt; {\textsc{opt}\xspace}(I) + 1
                    \end{aligned}" /><br /></p>
<p>Since our obj function is integer valued, we can make the argument that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> must give the <span><span style="font-variant: small-caps;">opt</span></span>solution.</p>
<p>Thus, the runtime is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p%28%7CI%7C%2C%20%5Cfrac%7B1%7D%7B%5Cvarepsilon%7D%29%20%3D%20p%28%7CI%7C%2C%20q%28%7CI_%5Ctext%7Bunary%7D%7C%29%29" alt="p(|I|, \frac{1}{\varepsilon}) = p(|I|, q(|I_\text{unary}|))" title="p(|I|, \frac{1}{\varepsilon}) = p(|I|, q(|I_\text{unary}|))" />, which is pseudo-polynomial time.</p>
<h1 id="cha:hardness_of_approximation">Hardness of Approximation</h1>
<p>In general, some <span><span style="font-variant: small-caps;">NP-complete</span></span>problems can be approximated in different manners.</p>
<p>Listed from hardest to easiest, we have:</p>
<ul>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E%5Cvarepsilon%29" alt="O(n^\varepsilon)" title="O(n^\varepsilon)" /> - factor</p></li>
<li><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%29" alt="O(n \log n)" title="O(n \log n)" /> - factor (Set Cover)</p></li>
<li><p>Constant factor (Vertex Cover, Euclidean TSP)</p></li>
<li><p><span><span style="font-variant: small-caps;">ptas</span></span>(Packing Unit Squares, Bin Packing)</p></li>
<li><p><span><span style="font-variant: small-caps;">fptas</span></span>(knapsack)</p></li>
</ul>
<p>If the positive results give an approximation algorithm, then negative results give that it’s hardest.</p>
<p>We can show that a <span><span style="font-variant: small-caps;">ptas</span></span>for vertex cover existing implies that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />.</p>
<p>For the Max-3SAT problem, we know through reductions that a <span><span style="font-variant: small-caps;">ptas</span></span>for either vertex cover or Independent Set implies that there must be a <span><span style="font-variant: small-caps;">ptas</span></span>for Max-3SAT, since there are reductions preserving good approximations.</p>
<h2 id="sec:a_new_definition_of_np">A New Definition of <span><span style="font-variant: small-caps;">NP</span></span></h2>
<p>Earlier, we defined <span><span style="font-variant: small-caps;">NP</span></span>as a set of decision problems verifiable in <span><span style="font-variant: small-caps;">P</span></span>given a certificate of polynomial size.</p>
<p>If we think about this as a game between the prover <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> (who finds the certificate) and the verifier <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> (verifies the problem), then we can get some edge by talking about how much <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> asks <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> and how much <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> guesses randomly.</p>
<p>An interactive proof system is essentially what we’re building. <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> asks <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> about parts of the proof, and guesses<a href="#fn71" class="footnoteRef" id="fnref71"><sup>71</sup></a> some others.</p>
<h3 id="sub:graph_isomorphism">Graph Isomorphism</h3>
<blockquote>
<p>Given 2 graphs <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G_1" alt="G_1" title="G_1" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G_2" alt="G_2" title="G_2" />, can you relabel <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G_1" alt="G_1" title="G_1" /> to get <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G_2" alt="G_2" title="G_2" />?</p>
</blockquote>
<p>Graph isomorphism is in <span><span style="font-variant: small-caps;">NP</span></span>, but it is <span><span style="font-variant: small-caps;">open</span></span>if it is in <span><span style="font-variant: small-caps;">P</span></span>or in <span><span style="font-variant: small-caps;">NP-complete</span></span>.</p>
<p>For the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" />, we can pick one of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G_1" alt="G_1" title="G_1" /> or <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G_2" alt="G_2" title="G_2" /> at random, and ask <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> about which one we relabeled.</p>
<ul>
<li><p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G_1%20%5Cnot%3D%20G_2" alt="G_1 \not= G_2" title="G_1 \not= G_2" />, then the prover can answer correctly.</p></li>
<li><p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G_1%20%3D%20G_2" alt="G_1 = G_2" title="G_1 = G_2" />, then the prover can’t do better than 50% right.</p></li>
</ul>
<p>Thus <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> runs many trials to verify <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G_1%20%5Cnot%3D%20G_2" alt="G_1 \not= G_2" title="G_1 \not= G_2" /> with high probability.</p>
<p>This is a restricted instance, since there are no rounds and only one prover<a href="#fn72" class="footnoteRef" id="fnref72"><sup>72</sup></a>.</p>
<h3 id="sub:probabilistically_checkable_proofs">Probabilistically Checkable Proofs</h3>
<p>Given a result to a decision problem, we have a game between the Prover and Verifier.</p>
<ul>
<li><p>Prover writes the “proof”.</p></li>
<li><p>The Verifier is a randomized algorithm that “checks” the proof and answers <span style="font-variant: small-caps;">yes</span> or <span style="font-variant: small-caps;">no</span>.</p></li>
</ul>
<p>If the statement is true, then there is (always?) a proof that makes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> (always?) answer <span style="font-variant: small-caps;">yes</span>.</p>
<p>If the statement is false, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> must answer <span style="font-variant: small-caps;">no</span> with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7BPr%7D%20%5Cge%20%5Cfrac%7B3%7D%7B4%7D" alt="\text{Pr} \ge \frac{3}{4}" title="\text{Pr} \ge \frac{3}{4}" />, no matter the proof given.</p>
<p>If we limit <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28f%28n%29%29" alt="O(f(n))" title="O(f(n))" /> random bits, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28g%28n%29%29" alt="O(g(n))" title="O(g(n))" />, then we define <span style="font-variant: small-caps;">pcp</span> as follows:</p>
<blockquote>
<p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctextsc%7Bpcp%7D%5Bf%2C%20g%5D" alt="\textsc{pcp}[f, g]" title="\textsc{pcp}[f, g]" /> is the class of decision problems with Probabilistically Checkable Proof where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> uses <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28f%28n%29%29" alt="O(f(n))" title="O(f(n))" /> random bits, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28g%28n%29%29" alt="O(g(n))" title="O(g(n))" /> bits of the proof.</p>
</blockquote>
<p>We have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctextsc%7Bpcp%7D%5B0%2C%20%5Ctext%7Bpoly%7D%28n%29%5D%20%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="\textsc{pcp}[0, \text{poly}(n)] = {\textsc{NP}\xspace}" title="\textsc{pcp}[0, \text{poly}(n)] = {\textsc{NP}\xspace}" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctextsc%7Bpcp%7D%5B0%2C%200%5D%20%3D%20%7B%5Ctextsc%7BP%7D%5Cxspace%7D" alt="\textsc{pcp}[0, 0] = {\textsc{P}\xspace}" title="\textsc{pcp}[0, 0] = {\textsc{P}\xspace}" />.</p>
<h3 id="sub:pcp_theorem">PCP Theorem</h3>
<p>The “PCP Theorem” is by (Aurora, Lund, Motwani, Sudan, and Szegedy in `92). It states that:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D%26%3D%20%5Ctextsc%7Bpcp%7D%5B%5Clog%20n%2C%201%5D.%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        {\textsc{NP}\xspace}&amp;= \textsc{pcp}[\log n, 1].
                    \end{aligned}" title="\begin{aligned}
                        {\textsc{NP}\xspace}&amp;= \textsc{pcp}[\log n, 1].
                    \end{aligned}" /><br /></p>
<p>Essentially, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V" alt="V" title="V" /> uses to choose to look at the proof.</p>
<p>Proving <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctextsc%7Bpcp%7D%5B%5Clog%20n%2C%201%5D%20%5Csubseteq%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D%3D%20%5Ctextsc%7Bpcp%7D%5B0%2C%20%5Ctext%7Bpoly%7D%28n%29%5D" alt="\textsc{pcp}[\log n, 1] \subseteq {\textsc{NP}\xspace}= \textsc{pcp}[0, \text{poly}(n)]" title="\textsc{pcp}[\log n, 1] \subseteq {\textsc{NP}\xspace}= \textsc{pcp}[0, \text{poly}(n)]" /> is not hard, since the verifier only needs to eliminate randomness and tries all possible random strings of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20n%29" alt="O(\log n)" title="O(\log n)" /> bits. It then looks at <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%5Ek" alt="n^k" title="n^k" /> bits of the proof.</p>
<p>The other direction is hard.</p>
<h3 id="sub:implications_of_the_pcp_theorem_to_hardness_of_approximation">Implications of the PCP Theorem to Hardness of Approximation</h3>
<p>From the <span style="font-variant: small-caps;">pcp</span> theorem, we know that a <span><span style="font-variant: small-caps;">ptas</span></span>for Max 3-SAT implies that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />.</p>
<p>Using <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BNP%7D%5Cxspace%7D%3D%20%5Ctextsc%7Bpcp%7D%5B%5Clog%20n%2C%201%5D" alt="{\textsc{NP}\xspace}= \textsc{pcp}[\log n, 1]" title="{\textsc{NP}\xspace}= \textsc{pcp}[\log n, 1]" />, we can take any problem in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{NP}\xspace}" title="{\textsc{NP}\xspace}" /> and the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctextsc%7Bpcp%7D%5B%5Clog%20n%2C%201%5D" alt="\textsc{pcp}[\log n, 1]" title="\textsc{pcp}[\log n, 1]" /> verifier’s algorithm for it.</p>
<p>The algorithm depends on the input bits <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x_1%2C%20%5Cldots%2C%20x_n" alt="x_1, \ldots, x_n" title="x_1, \ldots, x_n" />, the proof bits <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y_1%2C%20%5Cldots%2C%20y_t" alt="y_1, \ldots, y_t" title="y_1, \ldots, y_t" /> (for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t%20%5Cin%20O%28%5Ctext%7Bpoly%7D%28n%29%29" alt="t \in O(\text{poly}(n))" title="t \in O(\text{poly}(n))" />), and the random bits <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_1%2C%20%5Cldots%2C%20r_k" alt="r_1, \ldots, r_k" title="r_1, \ldots, r_k" /> (for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%5Cin%20O%28%5Clog%20n%29" alt="k \in O(\log n)" title="k \in O(\log n)" />).</p>
<p>We can reduce any<a href="#fn73" class="footnoteRef" id="fnref73"><sup>73</sup></a> algorithm to a Boolean 3-SAT formula.</p>
<p>Using variables for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y_1%2C%20%5Cldots%2C%20y_t" alt="y_1, \ldots, y_t" title="y_1, \ldots, y_t" />, we can choose the formula <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=F%28x%2C%20y%2C%20r%29" alt="F(x, y, r)" title="F(x, y, r)" /> to capture the verifier’s algorithm.</p>
<p>Let <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=F%28x%2C%20y%29%20%3D%20%5Cland_%7Br%7D%20F%28x%2C%20y%2C%20r%29" alt="F(x, y) = \land_{r} F(x, y, r)" title="F(x, y) = \land_{r} F(x, y, r)" />.</p>
<p>Since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r" alt="r" title="r" /> is polynomial size, we can say the following:</p>
<ul>
<li><p>if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> is <span style="font-variant: small-caps;">yes</span> input, then there exists a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" /> such that all <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=F%28x%2C%20y%2C%20x%29" alt="F(x, y, x)" title="F(x, y, x)" /> are satisfied and thus <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=F%28x%2C%20y%29" alt="F(x, y)" title="F(x, y)" /> is satisfied.</p></li>
<li><p>if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> is <span style="font-variant: small-caps;">no</span> input, then for any <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=y" alt="y" title="y" />, at most <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B4%7D" alt="\frac{1}{4}" title="\frac{1}{4}" /> of the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=F%28x%2C%20y%2C%20x%29" alt="F(x, y, x)" title="F(x, y, x)" /> are satisfied, and at most a fraction of the clauses of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=F%28x%2C%20y%29" alt="F(x, y)" title="F(x, y)" /> can be satisfied.</p></li>
</ul>
<p>By having a gap when <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=x" alt="x" title="x" /> is a <span style="font-variant: small-caps;">no</span> input between <span><span style="font-variant: small-caps;">opt</span></span>and “all”, we can detect this gap with a good approximation algorithm.</p>
<h1 id="cha:online_algorithms">Online Algorithms</h1>
<p>Given a sequence of requests, our algorithm must handle each request as it comes. This is the usual scenario for data structures, but we will study situations where it makes sense to compare with complete solutions.</p>
<ul>
<li><p>Bin packing: (first vs best fit)</p></li>
<li><p>Splay Trees - dynamic optimality conjecture</p></li>
<li><p>Paging (LRU and LFU)</p></li>
<li><p>Ski rental - rental is $30, but purchasing skiis is $300.</p></li>
</ul>
<h2 id="sec:robots_finding_doors">Robots Finding Doors</h2>
<p>Suppose we have a robot an unknown distance <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" /> away from a door in an unknown direction.</p>
<p>In an <span><span style="font-variant: small-caps;">opt</span></span>route, we can provide a solution in length <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" />.</p>
<h3 id="sub:algorithm_0">Algorithm 0</h3>
<pre><code>find_door_0():
    i = 0
    while (true):
        i++
        go i steps right
        go 2i steps left
        go i steps right
        if seen_door():
            goto door
                    </code></pre>
<p>This takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=4%28%5Csum_i%5E%7Bd-1%7D%29%20%2B%20d" alt="4(\sum_i^{d-1}) + d" title="4(\sum_i^{d-1}) + d" /> steps if the door is on the right, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=4%28%5Csum_i%5E%7Bd-1%7D%29%20%2B%203d" alt="4(\sum_i^{d-1}) + 3d" title="4(\sum_i^{d-1}) + 3d" /> steps if the door is on the left, so this runs in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%28d%5E2%29" alt="\theta(d^2)" title="\theta(d^2)" /> time.</p>
<h3 id="sub:algorithm_1">Algorithm 1</h3>
<pre><code>find_door_1():
    i=0
    while (true):
        i++
        if i is odd:
            go 2^i steps right
            go 2^i steps left
        else: // (i is even)
            go 2^i steps left
            go 2^i steps right
                    </code></pre>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%5Ei%20%5Cle%20d%20%5Cle%202%5E%7Bi%2B1%7D" alt="2^i \le d \le 2^{i+1}" title="2^i \le d \le 2^{i+1}" />, then the distance travelled is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%202%5Csum_j%5E%7Bi%2B1%7D%20j%5E2%20%2B%20d" alt="\le 2\sum_j^{i+1} j^2 + d" title="\le 2\sum_j^{i+1} j^2 + d" />. Thus the distance travelled <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%202%20%282%5E%7Bi%2B2%7D%20-%201%29%20%2B%20d%20%5Cle%202%20%284d%20%2B%201%29%20%2B%20d%20%5Cle%209d" alt="\le 2 (2^{i+2} - 1) + d \le 2 (4d + 1) + d \le 9d" title="\le 2 (2^{i+2} - 1) + d \le 2 (4d + 1) + d \le 9d" />.</p>
<p>Since we know the distance travelled is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=9d" alt="9d" title="9d" />, then we have what we call a competitive ratio of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=9" alt="9" title="9" />.</p>
<h3 id="sub:algorithm_2">Algorithm 2</h3>
<p>This is a randomized version of the algorithm.</p>
<p>Flip a coin to choose th initial direction - <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f%20%5Cin%20%5C%7B0%2C%201%5C%7D" alt="f \in \{0, 1\}" title="f \in \{0, 1\}" />.</p>
<p>Then we do the algorithm described in Section [sub:algorithm<sub>1</sub>]. The odd/even test becomes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cmod%202%20%3D%20f" alt="i \mod 2 = f" title="i \mod 2 = f" />, and we now get to see the expected distance travelled:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%202%28%5Csum_j%202%5Ej%29%20%2B%20%5Cfrac%7B1%7D%7B2%7D%202%282%5E%7Bi%2B1%7D%29%20%2B%20d%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%202%282%5E%7Bi%2B1%7D%20-%201%29%20%2B%202%282%5E%7Bi%2B1%7D%29%20%2B%20d%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%202%282d%20-%201%29%20%2B%202d%20%2B%20d%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cle%207d%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                        2(\sum_j 2^j) + \frac{1}{2} 2(2^{i+1}) + d \\
                        &amp;= 2(2^{i+1} - 1) + 2(2^{i+1}) + d \\
                        &amp;\le 2(2d - 1) + 2d + d \\
                        &amp;\le 7d
                    \end{aligned}" title="\begin{aligned}
                        2(\sum_j 2^j) + \frac{1}{2} 2(2^{i+1}) + d \\
                        &amp;= 2(2^{i+1} - 1) + 2(2^{i+1}) + d \\
                        &amp;\le 2(2d - 1) + 2d + d \\
                        &amp;\le 7d
                    \end{aligned}" /><br /></p>
<p>We have a competitive ratio of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=7" alt="7" title="7" /> in this case.</p>
<h3 id="sub:algorithm_3">Algorithm 3</h3>
<p>The best randomized algorithm has a competitive ratio of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=4.592" alt="4.592" title="4.592" />. Let’s take a look at it.</p>
<p>For a value of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r" alt="r" title="r" /> chosen below, do the following algorithm:</p>
<pre><code>find_door_3():
    f = random_bit()
    x = random_float(0, 1)
    i = 0
    while (true):
        if i %2 = f:
            walk r^{i+x} right
            walk r^{i-x} left
        else:
            walk r^{i+x} left
            walk r^{i-x} right
        ++i
                    </code></pre>
<p>It can be shown that the expected distance travelled <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Cfrac%7Br%2B1%7D%7B%5Cln%20r%7D%20%2B%201" alt="\le \frac{r+1}{\ln r} + 1" title="\le \frac{r+1}{\ln r} + 1" />, which is minimized when <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r%20%3D%203.59" alt="r = 3.59" title="r = 3.59" />, giving the distance <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=4.59d" alt="4.59d" title="4.59d" />.</p>
<p>This is the best known approximation factor.</p>
<h3 id="sub:further_expansion">Further Expansion</h3>
<p>This becomes harder in 2D, as a robot is trying to find an unknown shape in a plane.</p>
<h2 id="sec:auction_strategies">Auction Strategies</h2>
<p>There is an item of value <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B" alt="B" title="B" />, and the auction bids occur one at a time. These bids are more like offers, since the algorithm must accept or reject bids immediately as they arrive. All bids are positive nonzero integers.</p>
<p>We want <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%28%5Csigma%29%20%5Cge%20c%20%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28%5Csigma%29%20%2B%20b" alt="A(\sigma) \ge c {\textsc{opt}\xspace}(\sigma) + b" title="A(\sigma) \ge c {\textsc{opt}\xspace}(\sigma) + b" />, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c%20%5Cle%201" alt="c \le 1" title="c \le 1" />.</p>
<p>If the number of bids is unknown, then the algorithm must accept the first bid, or else <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7BA%7D%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D%20%3D%200" alt="\frac{A}{{\textsc{opt}\xspace}} = 0" title="\frac{A}{{\textsc{opt}\xspace}} = 0" />.</p>
<p>Supposing the number of bids is known, the algorithm accepts the first bid above some threshold <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" />, otherwise it accepts the last bid.</p>
<p>Supposing the maximum bid is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M%20%5Cle%20B" alt="M \le B" title="M \le B" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%3D%20M" alt="{\textsc{opt}\xspace}= M" title="{\textsc{opt}\xspace}= M" />.</p>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%20%3D%202" alt="T = 2" title="T = 2" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M%20%5Cge%202" alt="M \ge 2" title="M \ge 2" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B2%7D%7BM%7D%20%5Cge%20%5Cfrac%7B2%7D%7BB%7D" alt="\frac{2}{M} \ge \frac{2}{B}" title="\frac{2}{M} \ge \frac{2}{B}" />. If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%20%3D%201" alt="T = 1" title="T = 1" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M%20%3D%201" alt="M = 1" title="M = 1" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B1%7D%20%3D%201" alt="\frac{1}{1} = 1" title="\frac{1}{1} = 1" />. It’s best to have the highest <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> possible.</p>
<h3 id="sub:t_threshold">Deterministic <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> Threshold</h3>
<p>If we set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%20%3D%20%7B%5Cleft%20%5Clfloor%20%5Csqrt%7BB%7D%20%5Cright%20%5Crfloor%20%7D" alt="T = {\left \lfloor \sqrt{B} \right \rfloor }" title="T = {\left \lfloor \sqrt{B} \right \rfloor }" />, we claim that the competitive ratio is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B%5Csqrt%7BB%7D%7D" alt="\frac{1}{\sqrt{B}}" title="\frac{1}{\sqrt{B}}" />.</p>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M%3E%20%7B%5Cleft%20%5Clfloor%20%5Csqrt%7BB%7D%20%5Cright%20%5Crfloor%20%7D" alt="M&gt; {\left \lfloor \sqrt{B} \right \rfloor }" title="M&gt; {\left \lfloor \sqrt{B} \right \rfloor }" />, then in the worst case <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> accepts <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Cleft%20%5Clfloor%20%5Csqrt%7BB%7D%20%5Cright%20%5Crfloor%20%7D%20%2B%201" alt="{\left \lfloor \sqrt{B} \right \rfloor } + 1" title="{\left \lfloor \sqrt{B} \right \rfloor } + 1" />. The competitive ratio is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B%7B%5Cleft%20%5Clfloor%20%5Csqrt%7BB%7D%20%5Cright%20%5Crfloor%20%7D%20%2B%201%7D%7BM%7D%20%5Cge%20%5Cfrac%7B%7B%5Cleft%20%5Clfloor%20%5Csqrt%7BB%7D%20%5Cright%20%5Crfloor%20%7D%20%2B%201%7D%7BB%7D%20%5Cge%20%5Cfrac%7B1%7D%7B%5Csqrt%7BB%7D%7D" alt="\frac{{\left \lfloor \sqrt{B} \right \rfloor } + 1}{M} \ge \frac{{\left \lfloor \sqrt{B} \right \rfloor } + 1}{B} \ge \frac{1}{\sqrt{B}}" title="\frac{{\left \lfloor \sqrt{B} \right \rfloor } + 1}{M} \ge \frac{{\left \lfloor \sqrt{B} \right \rfloor } + 1}{B} \ge \frac{1}{\sqrt{B}}" />.</p>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M%20%5Cle%20%7B%5Cleft%20%5Clfloor%20%5Csqrt%7BB%7D%20%5Cright%20%5Crfloor%20%7D" alt="M \le {\left \lfloor \sqrt{B} \right \rfloor }" title="M \le {\left \lfloor \sqrt{B} \right \rfloor }" />, then the algorithm accepts the last bid. In the worst case, that bid is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1" alt="1" title="1" />, so the competive ratio is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B%5Csqrt%7BB%7D%7D" alt="\frac{1}{\sqrt{B}}" title="\frac{1}{\sqrt{B}}" />.</p>
<p>In either case, the competitive ratio is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B%5Csqrt%7BB%7D%7D" alt="\frac{1}{\sqrt{B}}" title="\frac{1}{\sqrt{B}}" />.</p>
<h3 id="sub:random_threshold">Random <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" /> Threshold</h3>
<p>Choose a random <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" /> threshold from <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%5Cin%20%5Bi%2C%20%5Clog%20B%5D" alt="i \in [i, \log B]" title="i \in [i, \log B]" />, then set <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%20%3D%202%5Ei" alt="T = 2^i" title="T = 2^i" />.</p>
<p>The worst case is that no bid is occurs <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%202%5Ei" alt="\ge 2^i" title="\ge 2^i" />, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> gets <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=0" alt="0" title="0" />.</p>
<p>We want to prove the expected competitive ratio is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20O%5Cleft%28%20%5Cfrac%7B1%7D%7B%5Clog%20b%7D%20%5Cright%29" alt="\ge O\left( \frac{1}{\log b} \right)" title="\ge O\left( \frac{1}{\log b} \right)" />.</p>
<p>Suppose that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M" alt="M" title="M" /> is the max bid, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%3D%20M" alt="{\textsc{opt}\xspace}= M" title="{\textsc{opt}\xspace}= M" />.</p>
<p>Suppose that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%5Ek%20%5Cle%20M%20%3C%202%5E%7Bk%2B1%7D" alt="2^k \le M &lt; 2^{k+1}" title="2^k \le M &lt; 2^{k+1}" />. The probability that we choose <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%3Dk" alt="i=k" title="i=k" /> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7B%5Clog%20B%7D" alt="\frac{1}{\log B}" title="\frac{1}{\log B}" />.</p>
<p>For <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i%20%3D%20k" alt="i = k" title="i = k" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> gets <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%202%5Ek%20%5Cge%20%5Cfrac%7BM%7D%7B2%7D" alt="\ge 2^k \ge \frac{M}{2}" title="\ge 2^k \ge \frac{M}{2}" />.</p>
<p>Thus the expected value for the algorithm is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Cfrac%7BM%7D%7B2%20%5Clog%20B%7D" alt="\ge \frac{M}{2 \log B}" title="\ge \frac{M}{2 \log B}" />. Then, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7BA%7D%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D%20%5Cge%20%5Cfrac%7B1%7D%7B2%20%5Clog%20B%7D" alt="\frac{A}{{\textsc{opt}\xspace}} \ge \frac{1}{2 \log B}" title="\frac{A}{{\textsc{opt}\xspace}} \ge \frac{1}{2 \log B}" />.</p>
<h1 id="cha:paging">Paging</h1>
<p>An online algorithm is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" />-competitive if there exists a constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=b" alt="b" title="b" /> such that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%28%5Csigma%29%20%5Cle%20c%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%28%5Csigma%29%20%2B%20b" alt="A(\sigma) \le c{\textsc{opt}\xspace}(\sigma) + b" title="A(\sigma) \le c{\textsc{opt}\xspace}(\sigma) + b" />.</p>
<p>We define the paging problem as follows:</p>
<blockquote>
<p>We are given a “cache” of fast memory that holds <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> elements, and a “disk” of slow memory that holds <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%3E%3E%20k" alt="n &gt;&gt; k" title="n &gt;&gt; k" /> pages.</p>
<p>When a page is requested, if it’s in the cache, we have no problem.</p>
<p>Otherwise, we “page fault” and read the page into the cache at a cost of 1, evicting at least one page to do it.</p>
<p>We’d like to choose a page eviction strategy with a minimal cost.</p>
</blockquote>
<h2 id="sec:optimum_offline_strategy">Optimum Offline Strategy</h2>
<p>The optimum strategy is to evict the page with the next request furthest in the future. The proof is done from the observation that we can modify any optimum solution to this one, decision by decision.</p>
<h2 id="sec:online_cache_strategies">Online Cache Strategies</h2>
<dl>
<dt>FIFO</dt>
<dd><p>- first in first out</p>
</dd>
<dt>LRU</dt>
<dd><p>- least recently used</p>
</dd>
<dt>LFU</dt>
<dd><p>- least frequently used</p>
</dd>
</dl>
<h3 id="sub:lru_vs_fifo">LRU vs FIFO</h3>
<p>Despite LRU being better than FIFO in practice, both LRU and FIFO have competitive ratio <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />.</p>
<p>We can prove this by dividing a request sequence into phases. A phase stops just before the <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%2B1" alt="k+1" title="k+1" />th different page is requested.</p>
<p>The algorithms use <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20k" alt="\le k" title="\le k" /> swaps per page, since LRU and FIFO will not evict a page used in that single phase. We know that <span><span style="font-variant: small-caps;">opt</span></span>must evict <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%201" alt="\ge 1" title="\ge 1" /> page per phase, because there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%2B1" alt="k+1" title="k+1" /> distinct pages involved. Thus, we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7BA%7D%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D%20%5Cle%20k" alt="\frac{A}{{\textsc{opt}\xspace}} \le k" title="\frac{A}{{\textsc{opt}\xspace}} \le k" />, plus an additive constant for a partial phase at an end of a request sequence.</p>
<h3 id="sub:limitations_of_deterministic_selection">Limitations of Deterministic Selection</h3>
<p>We’d like to prove that any deterministic algorithm has competitive ratio <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20k" alt="\ge k" title="\ge k" />.</p>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> is the cache size, and the number of pages is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%2B1" alt="k+1" title="k+1" />, and the adversary can always supply a sequence of length <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> asking for the page known not to be in the cache.</p>
<p>Since there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> swaps in a sequence of length <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />, and we know that a perfect solution subjected to this adversary would use <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7Bn%7D%7Bk%7D" alt="\frac{n}{k}" title="\frac{n}{k}" /> swaps, because each time it evicts, it must be good for the next <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> requests.</p>
<p>Then we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7BA%7D%7B%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%7D%20%5Cge%20k" alt="\frac{A}{{\textsc{opt}\xspace}} \ge k" title="\frac{A}{{\textsc{opt}\xspace}} \ge k" /> for all deterministic algorithms.</p>
<h3 id="sub:randomized_page_swapping_algorithm">Randomized Page Swapping Algorithm</h3>
<p>This randomized algorithm is attributed to Fiat in `91.</p>
<pre><code>serve(p):
    p.makeRecent()
    if !cache.contains(p):
        if all pages are recent
            pages.all.makeNotRecent()
        evict a random non-recent page
                    </code></pre>
<p>Without proof, the expected competitive ratio is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CTheta%28%5Clog%20k%29" alt="\Theta(\log k)" title="\Theta(\log k)" />, which is the best possible for randomized algorithms, assuming the adversary does not see the random choices.</p>
<h2 id="sec:k_server_problem"><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-Server Problem</h2>
<p>The problem formulation is as follows:</p>
<blockquote>
<p>There are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> servers to service requests in metric space at points <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5C%7Bp_1%2C%20%5Cldots%2C%20p_n%5C%7D" alt="\{p_1, \ldots, p_n\}" title="\{p_1, \ldots, p_n\}" />.</p>
<p>When a request for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" /> occurs, if a server is at <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" />, fine.</p>
<p>Otherwise, move a server from its location (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_j" alt="p_j" title="p_j" />) to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p_i" alt="p_i" title="p_i" /> at cost <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d%28p_j%2C%20p_i%29" alt="d(p_j, p_i)" title="d(p_j, p_i)" />.</p>
<p>We’d like to serve requests in a given order while minimizing the total distance.</p>
</blockquote>
<p>Paging is a special case of this algorithm where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d%28p_i%2C%20p_j%29%20%3D%201" alt="d(p_i, p_j) = 1" title="d(p_i, p_j) = 1" /> for all <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=i" alt="i" title="i" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=j" alt="j" title="j" />.</p>
<p>Without proof, we state that the offline algorithm can solve the problem in poly-time.</p>
<h3 id="sub:greedy_online_algorithm">Greedy Online Algorithm</h3>
<p>Given that all points are in 2D, our heuristic is to move the closest server to the point.</p>
<p>This unboundedly bad, as a sequence of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28p_1%2C%20p_2%2C%20p_1%2C%20p_2%2C%20%5Cldots%29" alt="(p_1, p_2, p_1, p_2, \ldots)" title="(p_1, p_2, p_1, p_2, \ldots)" /> will take more time than necessary.</p>
<p>It is <span><span style="font-variant: small-caps;">open</span></span><a href="#fn74" class="footnoteRef" id="fnref74"><sup>74</sup></a> if there is a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-competitive algorithm that solves the problem, in any dimension.</p>
<p>The best known algorithm is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%282k-1%29" alt="(2k-1)" title="(2k-1)" />-competitive (`94).</p>
<h3 id="sub:k_competitive_algorithm_for_points_on_a_line"><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-Competitive Algorithm for Points on a Line</h3>
<p>For points on a line, we split up requests <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_i" alt="r_i" title="r_i" /> into three types:</p>
<ol>
<li><p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_i" alt="r_i" title="r_i" /> is to the right of all servers, move the rightmost server right.</p></li>
<li><p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_i" alt="r_i" title="r_i" /> is to the left of all servers, move the leftmost server left.</p></li>
<li><p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_i" alt="r_i" title="r_i" /> is between two servers <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_a" alt="s_a" title="s_a" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s_b" alt="s_b" title="s_b" />, move them both towards <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r_i" alt="r_i" title="r_i" />, stopping both when one reaches the request.</p></li>
</ol>
<p>If multiple servers arrive at the same location, break ties arbitrarily.</p>
<p>We present that (without proof) this algorithm is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-competitive.</p>
<h1 id="cha:fixed_parameter_tractable_algorithms_i">Fixed Parameter Tractable Algorithms I</h1>
<p>We know that <span><span style="font-variant: small-caps;">NP-complete</span></span>problems seem to only have exponential time algorithms, but we’d like to classify “how exponential” these problems are.</p>
<h2 id="sec:completing_problems_with_fixed_parameters">Completing Problems with Fixed Parameters</h2>
<p>When solving the Vertex Cover problem to find <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C%20%5Csubseteq%20V" alt="C \subseteq V" title="C \subseteq V" /> such that every edge has at least one end point in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" />.</p>
<p>Say that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> is the minimum size vertex cover, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> is known.</p>
<p>We try to find all subsets of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> vertices <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7Bn%20%5Cchoose%20k%7D%20O%28n%5Ek%29%20%3D%20O%28%7Bn%20%5Cchoose%20k%7D%20n%5Ek%29%20%3D%20O%28k%20n%5E%7Bk%2B1%7D%29" alt="{n \choose k} O(n^k) = O({n \choose k} n^k) = O(k n^{k+1})" title="{n \choose k} O(n^k) = O({n \choose k} n^k) = O(k n^{k+1})" />, which is polynomial time for constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />.</p>
<p>The same idea works for both clique and independent set but not for graph coloring<a href="#fn75" class="footnoteRef" id="fnref75"><sup>75</sup></a>.</p>
<h2 id="sec:a_feel_for_fixed_parameter_tractable_algorithms">A feel for Fixed Parameter Tractable Algorithms</h2>
<p>While <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5Ek%29" alt="O(n^k)" title="O(n^k)" /> is not exponential, it’s still pretty bad.</p>
<p>We’d much prefer <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28f%28k%29%20n%5Ec%29" alt="O(f(k) n^c)" title="O(f(k) n^c)" /> for some polynomial <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f%28k%29" alt="f(k)" title="f(k)" /> independent of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> and some constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" /> independent of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />. Even better would be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28f%28k%29%20%2B%20n%5Ec%29" alt="O(f(k) + n^c)" title="O(f(k) + n^c)" />.</p>
<h3 id="sub:fpta_for_vertex_cover">FPTA for Vertex Cover</h3>
<p>We want to build a FPTA for Vertex Cover by branching on all possibilities that for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%20%3D%20%28u%2C%20v%29" alt="e = (u, v)" title="e = (u, v)" />, either <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" /> or <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> is in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" /> (where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" /> is the cover).</p>
<p>At each tree, we pick an uncovered edge to branch on.</p>
<pre><code>vertex_cover(E, V, k):
    if E == {} return true
    if k == 0 return false
    pick e = E.random()
    (u, v) = e
    return vertex_cover(E.without_incident(u), V-u, k-1)
        || vertex_cover(E.without_incident(v), V-v, k-1)
                    </code></pre>
<p>The tree has depth <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />, so we take time <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%282%5Ek%20n%29" alt="O(2^k n)" title="O(2^k n)" />.</p>
<p>By modifying the algorithm, we can trivially find the vertex cover itself.</p>
<h3 id="sub:kernelization">Kernelization</h3>
<p>If we wanted to, we can improve the Vertex Cover technique to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28f%28k%29%20%2B%20n%5Ec%29" alt="O(f(k) + n^c)" title="O(f(k) + n^c)" /> using kernelization.</p>
<p>Essentially, if there exists a vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctext%7Bdeg%7D%28v%29%20%3E%20k" alt="\text{deg}(v) &gt; k" title="\text{deg}(v) &gt; k" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> must be in the cover <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" />, otherwise we’d need all neighbors of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> (of which there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3Ek" alt="&gt;k" title="&gt;k" />) to be in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C" alt="C" title="C" />.</p>
<pre><code>vertex_cover_kernelized(E, V, k):
    c_2 = all vertexes with deg(v) &gt; k
    k_2 = k - |C_2|
    V_2 = V - C_2
    E_2 = E.without_any_incident(C_2).remove_isolated()
    if |V_2| &gt; 2k^2
        return false
    return VC(E_2, V_2, k_2)
                    </code></pre>
<p>The actual vertex cover is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C%27%20%5Ccup%20%5Ctextsc%7BVC%7D%28E%27%2C%20V%27%2C%20k%27%29" alt="C&#39; \cup \textsc{VC}(E&#39;, V&#39;, k&#39;)" title="C&#39; \cup \textsc{VC}(E&#39;, V&#39;, k&#39;)" /> We know that the maximum degree in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V%27" alt="V&#39;" title="V&#39;" /> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20k" alt="\le k" title="\le k" />. If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28V%27%2C%20E%27%29" alt="(V&#39;, E&#39;)" title="(V&#39;, E&#39;)" /> has a vertex cover of size <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20k" alt="\le k" title="\le k" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=V%27" alt="V&#39;" title="V&#39;" /> has <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20k%5E2" alt="\le k^2" title="\le k^2" /> edges. So <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CE%27%7C%20%5Cle%202k%5E2" alt="|E&#39;| \le 2k^2" title="|E&#39;| \le 2k^2" />, which is not very big.</p>
<p>The idea of kernalization is due to Prof. J. Buss in `93.</p>
<p>The call to <span style="font-variant: small-caps;">vc</span> takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%282%5Ek%20%7CE%27%7C%29%20%3D%20O%282%5Ek%202%20k%5E2%29" alt="O(2^k |E&#39;|) = O(2^k 2 k^2)" title="O(2^k |E&#39;|) = O(2^k 2 k^2)" />, and finding <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=C%27" alt="C&#39;" title="C&#39;" /> takes <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%20%2B%20n%29" alt="O(m + n)" title="O(m + n)" /> time. Thus, the total run time is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%282%5Ek%20k%5E2%20%2B%20m%20%2B%20n%29" alt="O(2^k k^2 + m + n)" title="O(2^k k^2 + m + n)" />.</p>
<h2 id="sec:defining_fixed_parameter_tractable_algorithms">Defining Fixed Parameter Tractable Algorithms</h2>
<p>A problem is (FPT) in parameter <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> if it has an algorithm<a href="#fn76" class="footnoteRef" id="fnref76"><sup>76</sup></a> with runtime <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28f%28k%29%20n%5Ec%29" alt="O(f(k) n^c)" title="O(f(k) n^c)" />, wher <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is the input size, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f%28k%29" alt="f(k)" title="f(k)" /> is independent of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" />, and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" /> is a constant independent of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />.</p>
<p>Given a FPT problem, we can get an algorithm with runtime <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28f%27%28k%29%20%2B%20n%5E%7Bc%27%7D%29" alt="O(f&#39;(k) + n^{c&#39;})" title="O(f&#39;(k) + n^{c&#39;})" />. This is neither deep, indicative on how to construct this, nor useful, but is interesting.</p>
<h3 id="sub:common_parameter_examples">Common Parameter Examples</h3>
<p>We can pick a few types of examples of parameters:</p>
<ul>
<li><p>Value of the <span><span style="font-variant: small-caps;">opt</span></span>solution</p></li>
<li><p>Maximum degree of the graph</p></li>
<li><p>Dimension for geometric problems</p></li>
<li><p>Genus of a graph<a href="#fn77" class="footnoteRef" id="fnref77"><sup>77</sup></a></p></li>
</ul>
<p>Refer to Chapter 23 for many FPTA examples.</p>
<h2 id="sec:randomized_fpt_algorithm_for_k_path">Randomized FPT Algorithm for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-Path</h2>
<blockquote>
<p>Given graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G" alt="G" title="G" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%5Cin%20%5Cmathbf%7BN%7D" alt="k \in \mathbf{N}" title="k \in \mathbf{N}" />, and a starting vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s" alt="s" title="s" /> and an end vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" />, find a simple<a href="#fn78" class="footnoteRef" id="fnref78"><sup>78</sup></a> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s%20%5Cto%20t" alt="s \to t" title="s \to t" /> path with <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> internal vertexes.</p>
</blockquote>
<p>In general, this is a <span><span style="font-variant: small-caps;">NP-hard</span></span>problem, since if <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k%20%3D%20n-2" alt="k = n-2" title="k = n-2" />, we’re asking for a Hamiltonian Path <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s%20%5Cto%20t" alt="s \to t" title="s \to t" />.</p>
<p>With the power of randomness, we can save the day!</p>
<p>Randomly color all vertexes into <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> different colors. Then look only for paths that use all <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> colors.</p>
<p>The algorithm will always say “<span style="font-variant: small-caps;">no</span>” correctly, since it will never find a simple <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" />-path within the coloring.</p>
<p>If there does exist a simple path <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" />, we can say the following:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Ctext%7BPr%7D%28%5Ctext%7BP%20is%20colorful%7D%29%20%26%3D%20%5Cfrac%7Bk%21%7D%7Bk%5Ek%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%5Cfrac%7B%5Cleft%28%20%5Cfrac%7Bk%7D%7Be%7D%20%5Cright%29%5Ek%7D%7Bk%5Ek%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B1%7D%7Be%5Ek%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    \text{Pr}(\text{P is colorful}) &amp;= \frac{k!}{k^k} \\
                    &amp;\ge \frac{\left( \frac{k}{e} \right)^k}{k^k} \\
                    &amp;= \frac{1}{e^k}
                \end{aligned}" title="\begin{aligned}
                    \text{Pr}(\text{P is colorful}) &amp;= \frac{k!}{k^k} \\
                    &amp;\ge \frac{\left( \frac{k}{e} \right)^k}{k^k} \\
                    &amp;= \frac{1}{e^k}
                \end{aligned}" /><br /></p>
<p>So the algorithm is correct when it says “<span style="font-variant: small-caps;">yes</span>” with a probability <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20%5Cfrac%7B1%7D%7Be%5Ek%7D" alt="\ge \frac{1}{e^k}" title="\ge \frac{1}{e^k}" />.</p>
<p>Defining <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=p%20%3D%20%5Cfrac%7B1%7D%7Be%5Ek%7D" alt="p = \frac{1}{e^k}" title="p = \frac{1}{e^k}" />, then we can say:</p>
<p>Since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> is correct with Probability <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20p" alt="\ge p" title="\ge p" />, then after <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cfrac%7B1%7D%7Bp%7D" alt="\frac{1}{p}" title="\frac{1}{p}" /> repetitions, the probability of failure is</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%281%20-%20p%29%5E%7B%5Cfrac%7B1%7D%7Bp%7D%7D%20%26%3C%20%28e%5E%7B-p%7D%29%20%5E%20%5Cfrac%7B1%7D%7Bp%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B1%7D%7Be%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    (1 - p)^{\frac{1}{p}} &amp;&lt; (e^{-p}) ^ \frac{1}{p} \\
                    &amp;= \frac{1}{e}
                \end{aligned}" title="\begin{aligned}
                    (1 - p)^{\frac{1}{p}} &amp;&lt; (e^{-p}) ^ \frac{1}{p} \\
                    &amp;= \frac{1}{e}
                \end{aligned}" /><br /></p>
<p>In our case, repeating <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%5Ek" alt="e^k" title="e^k" /> times gives us the probability of error <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Cfrac%7B1%7D%7Be%7D" alt="\le \frac{1}{e}" title="\le \frac{1}{e}" />.</p>
<p>Finding a colorful path for a given ordering is easy, so we find all of them.</p>
<p>The runtime of setting up and searching orderings is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28k%21%20m%29" alt="O(k! m)" title="O(k! m)" />, so the final runtime is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28e%5Ek%202%5Ek%20m%29" alt="O(e^k 2^k m)" title="O(e^k 2^k m)" />, with a probability of error of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20%5Cfrac%7B1%7D%7Be%7D" alt="\le \frac{1}{e}" title="\le \frac{1}{e}" />.</p>
<h1 id="cha:fixed_parameter_tractable_algorithms_ii">Fixed Parameter Tractable Algorithms II</h1>
<p>The Independent set problem is expressed as follows:</p>
<blockquote>
<p>Given a graph <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G" alt="G" title="G" />, does it have an independent set<a href="#fn79" class="footnoteRef" id="fnref79"><sup>79</sup></a> <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%20k" alt="\ge k" title="\ge k" />?</p>
</blockquote>
<p>The brute-force time is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5Ek%20%28n%2Bm%29%29" alt="O(n^k (n+m))" title="O(n^k (n+m))" />, where there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> subsets of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> vertexes. The brute-force solution FPT.</p>
<p>In fact, it is <span><span style="font-variant: small-caps;">open</span></span>if there is a FPTA for Independent Set (and this parameter), and it’s also <span><span style="font-variant: small-caps;">open</span></span>if existence of a FPTA implies <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%5Ctextsc%7BP%7D%5Cxspace%7D%3D%20%7B%5Ctextsc%7BNP%7D%5Cxspace%7D" alt="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" title="{\textsc{P}\xspace}= {\textsc{NP}\xspace}" />.</p>
<h2 id="sec:fpta_for_independent_set">FPTA for Independent Set</h2>
<p>The general idea is to use a parameter for a FPTA that measures the “tree-ness” of our graph.</p>
<h3 id="sub:independent_set_on_a_tree">Independent Set on a Tree</h3>
<p>We want to find the independent set on a tree.</p>
<p>We define the recursive functions <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=IS%28v%29" alt="IS(v)" title="IS(v)" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=IS%27%28V%29" alt="IS&#39;(V)" title="IS&#39;(V)" />, which are the maximum weight of the independent set of the subtree rooted at <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> that do (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=IS%28v%29" alt="IS(v)" title="IS(v)" />) or do not (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=IS%27%28v%29" alt="IS&#39;(v)" title="IS&#39;(v)" />) include <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" />.</p>
<p>We can even put weights on vertexes as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=w%28v%29" alt="w(v)" title="w(v)" />.</p>
<pre><code>ind_set_tree(V):
    for v = V.leaves:
        IS_2[v] = 0
        IS[v] = w(v)
    for v in V.vertexes-in-leaf-to-root-order:
        // where v_i are the children of v...
        IS_2[v] = sum_i(IS[v_i])
        IS[v]  = max(w(v) + sum_i(IS_2[v_i]), IS_2[v])
    return IS[root]
                    </code></pre>
<h3 id="sub:independent_set_on_graphs_that_are_almost_trees">Independent Set on Graphs that are “Almost” Trees</h3>
<h4 id="ssub:series_parallel_graphs">Series Parallel Graphs</h4>
<p>A Series-Parallel graph (SP) is defined recursively as:</p>
<ul>
<li><p>A single edge connecting two vertexes.</p></li>
<li><p>Two parallel SP graphs sharing the same start and end vertexes.</p></li>
<li><p>Two SP graphs connected in series.</p></li>
</ul>
<p>Refer to Figure [fig:sp<sub>c</sub>omposition] for an example.</p>
<p><img src="images/sp_composition.png" title="fig:" alt="Composition of SP Graphs" /> [fig:sp<sub>c</sub>omposition]</p>
<p>We can find the Independent set in series parallel graph by dynamic programming based on the maximum independent set for all permutations containing or not containing <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=s" alt="s" title="s" /> or <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=t" alt="t" title="t" />.</p>
<h3 id="sub:decomposing_series_parallel_graphs">Decomposing Series Parallel Graphs</h3>
<p>We can model the decomposition of a SP as a tree.</p>
<p>Vertexes that represent a parallel decomposition are a 2-tuple of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28s%2C%20t%29" alt="(s, t)" title="(s, t)" />. Vertexes that represent a series decomposition are a 3-tuple of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28s%2C%20v_%5Ctext%7Bmiddle%7D%2C%20t%29" alt="(s, v_\text{middle}, t)" title="(s, v_\text{middle}, t)" />. Edges in the graph appear as leaf vertexes.</p>
<p>We have two properties:</p>
<ol>
<li><p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=e%20%3D%20%28u%2C%20v%29" alt="e = (u, v)" title="e = (u, v)" /> is an edge of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G" alt="G" title="G" /> then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=u" alt="u" title="u" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> trivially appear together in a tree node.</p></li>
<li><p>Every vertex <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G" alt="G" title="G" /> corresponds to a sub-tree <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T" alt="T" title="T" />.</p></li>
</ol>
<h3 id="sub:generalization_to_general_graphs">Generalization to General Graphs</h3>
<p>The concept of Tree-Width was created by Robertson &amp; Seymour as part of the “Graph Minors Project”, the result of 20 papers, totaling around 500 pages.</p>
<p>We want to represent a graph as a tree, and have properties 1 and 2 from above.</p>
<p>I believe that we define bags as a 2-or-3-tuple of a vertex.</p>
<p>The width of a decomposition is the size of the largest bag in the tree - 1.</p>
<p>The tree width of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=G" alt="G" title="G" /> is the minimum width of any tree decomposition, which is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20n%20-%201" alt="\le n - 1" title="\le n - 1" />.</p>
<p>And we only need <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20n" alt="\le n" title="\le n" /> bags in any tree decomposition.</p>
<p>Finding the tree-width of a graph is <span><span style="font-variant: small-caps;">NP-hard</span></span>, but there is a FPT algorithm <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%282%5E%7BO%28k%5E3%7D%20n%29" alt="O(2^{O(k^3} n)" title="O(2^{O(k^3} n)" />.</p>
<h3 id="sub:graphs_of_tree_width">Graphs of Tree Width</h3>
<p>The maximum weight of the independent set in a graph of a tree-width <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=k" alt="k" title="k" /> can be found in time <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%282%5Ek%20n%29" alt="O(2^k n)" title="O(2^k n)" />.</p>
<p>The idea of the proof is to use DP to the tree upwards.</p>
<p>For each bag <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B" alt="B" title="B" /> of size <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%20k%20%2B%201" alt="\le k + 1" title="\le k + 1" /> we find for each subset <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%20%5Csubseteq%20B" alt="A \subseteq B" title="A \subseteq B" /> (there are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%282%5Ek%29" alt="O(2^k)" title="O(2^k)" /> of them), a maximum weight independent set including <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A" alt="A" title="A" /> (excluding <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B%20-%20a" alt="B - a" title="B - a" />) in the subtree rooted at <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=B" alt="B" title="B" />.</p>
<h3 id="sub:other_problems_fpt_in_tree_width">Other Problems FPT in Tree-Width</h3>
<ul>
<li><p>3-Coloring</p></li>
<li><p>Minimum coloring</p></li>
<li><p>Hamiltonian cycle (apparently it’s even more complicated)</p></li>
</ul>
<h3 id="sub:hardness_results_of_fpt_problems">Hardness Results of FPT Problems</h3>
<p>All relative results are of the form: A FPT algorithm existing for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X" alt="X" title="X" /> implies there is a FPT algorithm for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Y" alt="Y" title="Y" />, and is proved through a reduction that preserves the parameter and the FPT.</p>
<h1 id="cha:sample_algorithms">Sample Algorithms</h1>
<h2 id="sec:quicksort">QuickSort</h2>
<p>We have data <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S%20%3D%20%5C%7B%20s_1%20%5Cldots%20s_n%20%5C%7D" alt="S = \{ s_1 \ldots s_n \}" title="S = \{ s_1 \ldots s_n \}" />.</p>
<pre><code>def QuickSort(S):
    if n == 0 or n == 1:
        return S
    i = random(1, n)
    L = {s_j : s_j &lt; s_i}
    M = {s_j : s_j = s_i}
    R = {s_j : s_j &gt; s_i}
    return QuickSort(L).append(M).append(QuickSort(R))
            </code></pre>
<p>In the worst case, this runs in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28n%29%20%3D%20T%28n-1%29%20%2B%20O%28n%29%20%3D%20O%28n%5E2%29" alt="T(n) = T(n-1) + O(n) = O(n^2)" title="T(n) = T(n-1) + O(n) = O(n^2)" /> time.</p>
<p>We “expect” the pivot to be in the middle, so <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%7CL%7C%20%3D%20%7CB%7C%20%3D%20%5Cfrac%7Bn%7D%7B2%7D" alt="|L| = |B| = \frac{n}{2}" title="|L| = |B| = \frac{n}{2}" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28n%29%20%3D%202%20T%28%5Cfrac%7Bn%7D%7B2%7D%29%20%2B%20O%28n%29%20%3D%20O%28n%20%5Clog%20n%29" alt="T(n) = 2 T(\frac{n}{2}) + O(n) = O(n \log n)" title="T(n) = 2 T(\frac{n}{2}) + O(n) = O(n \log n)" />.<a href="#fn80" class="footnoteRef" id="fnref80"><sup>80</sup></a></p>
<p>More formally, we’ll analyze randomized QuickSort with recursive calls of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28%5Cell%29%20%2B%20T%28n%20-%20%5Cell%20-%201%29" alt="T(\ell) + T(n - \ell - 1)" title="T(\ell) + T(n - \ell - 1)" />.</p>
<p>By random choice of pivot, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cell" alt="\ell" title="\ell" /> is equally likely to be each of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5C%7B0%20%5Cldots%20n-1%5C%7D" alt="\{0 \ldots n-1\}" title="\{0 \ldots n-1\}" />, each with a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%28%5Cfrac%7B1%7D%7Bn%7D%29" alt="\Pr(\frac{1}{n})" title="\Pr(\frac{1}{n})" />. Then, we get:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20T%28n%29%20%26%3D%20%5Cfrac%7B1%7D%7Bn%7D%20%5Cleft%28%5Csum%5E%7Bn-1%7D_%7B%5Cell%20%3D%200%7D%20T%28%5Cell%29%20%2B%20T%28n%20-%20%5Cell%20-%201%29%5Cright%29%20%2B%20O%28n%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B2%7D%7Bn%7D%20%5Cleft%28%5Csum%5E%7Bn-1%7D_%7B%5Cell%20%3D%200%7D%20T%28%5Cell%29%5Cright%29%20%2B%20O%28n%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                T(n) &amp;= \frac{1}{n} \left(\sum^{n-1}_{\ell = 0} T(\ell) + T(n - \ell - 1)\right) + O(n) \\
                &amp;= \frac{2}{n} \left(\sum^{n-1}_{\ell = 0} T(\ell)\right) + O(n)
            \end{aligned}" title="\begin{aligned}
                T(n) &amp;= \frac{1}{n} \left(\sum^{n-1}_{\ell = 0} T(\ell) + T(n - \ell - 1)\right) + O(n) \\
                &amp;= \frac{2}{n} \left(\sum^{n-1}_{\ell = 0} T(\ell)\right) + O(n)
            \end{aligned}" /><br /></p>
<p>Using a proof by induction, we arrive at <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%28n%29%20%3D%20O%28n%20%5Clog%20n%29" alt="T(n) = O(n \log n)" title="T(n) = O(n \log n)" />, which means that we can expect quicksort to take <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%20%5Clog%20n%29" alt="O(n \log n)" title="O(n \log n)" /> time<a href="#fn81" class="footnoteRef" id="fnref81"><sup>81</sup></a>.</p>
<h1 id="cha:math_review">Math Review</h1>
<h2 id="sec:expected_values_statistics">Expected Values - Statistics</h2>
<p>The expected value of the random variable <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X" alt="X" title="X" /> is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E%28X%29" alt="E(X)" title="E(X)" />. For discrete <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X" alt="X" title="X" />, we know:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%28X%29%20%26%3D%20%5Csum_x%20xPr%5C%7BX%20%3D%20x%5C%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                E(X) &amp;= \sum_x xPr\{X = x\}
            \end{aligned}" title="\begin{aligned}
                E(X) &amp;= \sum_x xPr\{X = x\}
            \end{aligned}" /><br /></p>
<p>For any <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X" alt="X" title="X" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Y" alt="Y" title="Y" />, we know that:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%28X%20%2B%20Y%29%20%26%3D%20E%28X%29%20%2B%20E%28Y%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                E(X + Y) &amp;= E(X) + E(Y)
            \end{aligned}" title="\begin{aligned}
                E(X + Y) &amp;= E(X) + E(Y)
            \end{aligned}" /><br /></p>
<p>For a constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" />, we know:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%28cX%29%20%26%3D%20cE%28X%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                E(cX) &amp;= cE(X)
            \end{aligned}" title="\begin{aligned}
                E(cX) &amp;= cE(X)
            \end{aligned}" /><br /></p>
<p>If <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X" alt="X" title="X" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=Y" alt="Y" title="Y" /> are independent random variables, we know:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Pr%5C%7BX%20%3D%20x%20%5Ctext%7B%20and%20%7D%20Y%20%3D%20y%5C%7D%20%26%3D%20Pr%5C%7BX%20%3D%20x%5C%7D%20Pr%5C%7BY%20%3D%20y%5C%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%28XY%29%20%26%3D%20E%28X%29%20E%28Y%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                Pr\{X = x \text{ and } Y = y\} &amp;= Pr\{X = x\} Pr\{Y = y\} \\
                E(XY) &amp;= E(X) E(Y)
            \end{aligned}" title="\begin{aligned}
                Pr\{X = x \text{ and } Y = y\} &amp;= Pr\{X = x\} Pr\{Y = y\} \\
                E(XY) &amp;= E(X) E(Y)
            \end{aligned}" /><br /></p>
<p>More details are in CLRS.</p>
<h2 id="sec:markov_s_inequality">Markov’s Inequality</h2>
<p>If the random variable <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=X%20%5Cge%200" alt="X \ge 0" title="X \ge 0" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=E%28X%29%20%3D%20%5Cmu" alt="E(X) = \mu" title="E(X) = \mu" />, then <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CPr%5C%7B%20X%20%5Cge%20c%20%5Cmu%20%5C%7D%20%5Cle%20%5Cfrac%7B1%7D%7Bc%7D" alt="\Pr\{ X \ge c \mu \} \le \frac{1}{c}" title="\Pr\{ X \ge c \mu \} \le \frac{1}{c}" /> for a constant <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=c" alt="c" title="c" />.</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cmu%20%26%3D%20E%28X%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Csum%20x%20%5CPr%28X%20%3D%20x%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20%5Csum_%7Bx%20%5Cge%20c%20%5Cmu%7D%20x%20%5CPr%28X%20%3D%20x%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%5Cge%20c%20%5Cmu%20%5Csum_%7Bx%20%5Cge%20c%20%5Cmu%7D%20%5CPr%28X%20%3D%20x%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5CPr%28X%20%5Cge%20c%20%5Cmu%29%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5CPr%28X%20%5Cge%20c%20%5Cmu%29%20%26%5Cle%20%5Cfrac%7B%5Cmu%7D%7Bc%20%5Cmu%7D%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%26%3D%20%5Cfrac%7B1%7D%7Bc%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                \mu &amp;= E(X) \\
                &amp;= \sum x \Pr(X = x) \\
                &amp;\ge \sum_{x \ge c \mu} x \Pr(X = x) \\
                &amp;\ge c \mu \sum_{x \ge c \mu} \Pr(X = x) \\
                &amp;= \Pr(X \ge c \mu) \\
                \Pr(X \ge c \mu) &amp;\le \frac{\mu}{c \mu} \\
                &amp;= \frac{1}{c}
            \end{aligned}" title="\begin{aligned}
                \mu &amp;= E(X) \\
                &amp;= \sum x \Pr(X = x) \\
                &amp;\ge \sum_{x \ge c \mu} x \Pr(X = x) \\
                &amp;\ge c \mu \sum_{x \ge c \mu} \Pr(X = x) \\
                &amp;= \Pr(X \ge c \mu) \\
                \Pr(X \ge c \mu) &amp;\le \frac{\mu}{c \mu} \\
                &amp;= \frac{1}{c}
            \end{aligned}" /><br /></p>
<p>This proof can be found on page 5 of the Lecture 11 notes.</p>
<h2 id="sec:logic">Logic</h2>
<h3 id="sub:contrapositive">Contrapositive</h3>
<p>The contrapositive is defined as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28A%20%5Cimplies%20B%29%20%5Cimplies%20%28%5Clnot%20B%20%5Cimplies%20%5Clnot%20A%29" alt="(A \implies B) \implies (\lnot B \implies \lnot A)" title="(A \implies B) \implies (\lnot B \implies \lnot A)" />.</p>
<h3 id="sub:conjunctive_normal_form_">Conjunctive Normal Form (CNF)</h3>
<p>Given a boolean formula, <span style="font-variant: small-caps;">CNF</span> is the form:</p>
<p><br /><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cbegin%7Baligned%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20E%20%26%3D%20%28x_1%20%5Clor%20x_2%20%5Clor%20x_3%29%20%5Cland%20%28x_1%20%5Clor%20%5Clnot%20x_2%29%20%5Cland%20%28%5Clnot%20x_1%20%5Clor%20%5Clnot%20x_2%20%5Clor%20%5Clnot%20x_3%29%20%5Cland%20%28x_2%20%5Clor%20%5Clnot%20x_3%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5Cend%7Baligned%7D" alt="\begin{aligned}
                    E &amp;= (x_1 \lor x_2 \lor x_3) \land (x_1 \lor \lnot x_2) \land (\lnot x_1 \lor \lnot x_2 \lor \lnot x_3) \land (x_2 \lor \lnot x_3)
                \end{aligned}" title="\begin{aligned}
                    E &amp;= (x_1 \lor x_2 \lor x_3) \land (x_1 \lor \lnot x_2) \land (\lnot x_1 \lor \lnot x_2 \lor \lnot x_3) \land (x_2 \lor \lnot x_3)
                \end{aligned}" /><br /></p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>A tour is a traversal ordering of vertexes in a graph<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>A Eulerian Tour is a tour that goes through each vertex exactly once and returns to the first vertex.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>A complete graph is one where there exists an edge between all vertexes in the graph.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>An approximation for this would solve the Hamiltonian-Cycle decision problem in <span><span style="font-variant: small-caps;">P</span></span>time. The Hamiltonian Cycle decision problem is known to be <span><span style="font-variant: small-caps;">NP-complete</span></span>.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>There is a <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%281.5%29" alt="(1.5)" title="(1.5)" />-approximation algorithm, but the minimum bound is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1.0045" alt="1.0045" title="1.0045" />.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>There is an <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28%5Cepsilon%2B1%29" alt="(\epsilon+1)" title="(\epsilon+1)" />-solution for an <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cforall%20%5Cepsilon%20%3E%200" alt="\forall \epsilon &gt; 0" title="\forall \epsilon &gt; 0" />, but time grows as <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cepsilon" alt="\epsilon" title="\epsilon" /> decreases. This is a <a href="https://en.wikipedia.org/wiki/Polynomial-time_approximation_scheme">Polynomial Time Approximation Scheme</a>. See Chapter TODO for PTASs.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>We know this, since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20%3D%20O%28n%5E2%29" alt="m = O(n^2)" title="m = O(n^2)" /> implies that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%20m%20%3D%20O%28%5Clog%20n%29" alt="\log m = O(\log n)" title="\log m = O(\log n)" />, within a constant<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>All properties in this list can be proved by induction.<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>TODO: is the amortized time different?<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>scraig postulates that this can be proved with a telescoping sum<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>This is a special case of <strong>Incremental Dynamic Connectivity</strong>.<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>Greedy algorithm that orders edges by weight, then adds them slowly into a tree (if an edge creates a cycle, don’t add it). We end up with a minimum spanning tree.<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>Since <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m%20%5Cle%20n%5E2" alt="m \le n^2" title="m \le n^2" />, we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28%5Clog%20m%29%20%3D%20O%28%5Clog%20n%29" alt="O(\log m) = O(\log n)" title="O(\log m) = O(\log n)" /><a href="#fnref13">↩</a></p></li>
<li id="fn14"><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Calpha%28m%2C%20n%29" alt="\alpha(m, n)" title="\alpha(m, n)" /> is the inverse Ackerman function. It is very slow growing, and is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle%205" alt="\le 5" title="\le 5" /> for all practical purposes.<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%5E%2A%20n" alt="\log^* n" title="\log^* n" /> is essentially the minimum number of times <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=log%28n%29" alt="log(n)" title="log(n)" /> needs to be recursively called in order for <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Clog%28%5Clog%28%5Cldots%28n%29%29%29%20%5Cle%201" alt="\log(\log(\ldots(n))) \le 1" title="\log(\log(\ldots(n))) \le 1" />. The inverse of this is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2%5Cuparrow%20n" alt="2\uparrow n" title="2\uparrow n" />, which is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=2" alt="2" title="2" /> exponentiated with itself <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> times.<a href="#fnref15">↩</a></p></li>
<li id="fn16"><p>This is because a vertex of rank <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> has <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n%20%5Cge%202%5Er" alt="n \ge 2^r" title="n \ge 2^r" /> descendants, and vertexes of rank <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=r" alt="r" title="r" /> have disjoint descendants.<a href="#fnref16">↩</a></p></li>
<li id="fn17"><p>See the QuickSort details in Section  [sec:quicksort]<a href="#fnref17">↩</a></p></li>
<li id="fn18"><p>We can get the first method using the second.<a href="#fnref18">↩</a></p></li>
<li id="fn19"><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=I" alt="I" title="I" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> are different types, and polymorphism works in pseudocode.<a href="#fnref19">↩</a></p></li>
<li id="fn20"><p>Blum et al. `75<a href="#fnref20">↩</a></p></li>
<li id="fn21"><p>This proof type is an adversary proof.<a href="#fnref21">↩</a></p></li>
<li id="fn22"><p>We’re effectively trying to find the worst case scenario, played out by an adversary. Stick to the plot, foo!<a href="#fnref22">↩</a></p></li>
<li id="fn23"><p>This can probably be done using induction, but it isn’t noted.<a href="#fnref23">↩</a></p></li>
<li id="fn24"><p>In other words, is <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> not prime?<a href="#fnref24">↩</a></p></li>
<li id="fn25"><p>In 2002, Agrawal, Kayal, and Saxena published a poly-time non-randomized algorithm to test primality known as the <a href="https://en.wikipedia.org/wiki/AKS_primality_test">AKS Primality Test</a>.<a href="#fnref25">↩</a></p></li>
<li id="fn26"><p>Contrapositive notes can be found at [sub:contrapositive].<a href="#fnref26">↩</a></p></li>
<li id="fn27"><p>The numbers without Fermat witnesses are called . The first <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=3" alt="3" title="3" /> are <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=561" alt="561" title="561" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1105" alt="1105" title="1105" />, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=1729" alt="1729" title="1729" />.<a href="#fnref27">↩</a></p></li>
<li id="fn28"><p>This means that for a decision problem, only one of <span style="font-variant: small-caps;">YES</span> or <span style="font-variant: small-caps;">NO</span> can be wrong.<a href="#fnref28">↩</a></p></li>
<li id="fn29"><p>i.e. the <span style="font-variant: small-caps;">yes</span> answers can be verified in poly-time.<a href="#fnref29">↩</a></p></li>
<li id="fn30"><p>okay, maybe “many”<a href="#fnref30">↩</a></p></li>
<li id="fn31"><p>The classes <span style="font-variant: small-caps;">rp</span> and <span style="font-variant: small-caps;">co-np</span> are defined later.<a href="#fnref31">↩</a></p></li>
<li id="fn32"><p>Though the specification is that the probability must be <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cge%200.5" alt="\ge 0.5" title="\ge 0.5" />, repeated random tests can increase the probability for lower values. A better constraint is that the probability that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=A%28x%29" alt="A(x)" title="A(x)" /> accepts must be non-zero.<a href="#fnref32">↩</a></p></li>
<li id="fn33"><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M" alt="M" title="M" /> is chosen later<a href="#fnref33">↩</a></p></li>
<li id="fn34"><p>This is a prime number theorem.<a href="#fnref34">↩</a></p></li>
<li id="fn35"><p>We have a few other methods:<br />Using finite automata, we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28m%7C%5CSigma%7C%20%2B%20n%29" alt="O(m|\Sigma| + n)" title="O(m|\Sigma| + n)" /> non-randomized algorithms, where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5CSigma" alt="\Sigma" title="\Sigma" /> is the size of the alphabet.<br />Using Knuth-Morris-Pratt or Boyer-Moore algorithms, we have <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%2Bm%29" alt="O(n+m)" title="O(n+m)" /> non-randomized algorithms.<a href="#fnref35">↩</a></p></li>
<li id="fn36"><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=H_p%28T%5Bi%2B1%20%5Cldots%20i%2Bm%5D%29%20%3D%20%282%20H_p%28T%5Bi%20%5Cldots%20i%2Bm%20-%201%5D%29%20-%20T%5Bi%5D%202%5Em%20%2B%20T%5Bi%20%2B%20m%5D%29%20%5Cmod%20p%20" alt="H_p(T[i+1 \ldots i+m]) = (2 H_p(T[i \ldots i+m - 1]) - T[i] 2^m + T[i + m]) \mod p " title="H_p(T[i+1 \ldots i+m]) = (2 H_p(T[i \ldots i+m - 1]) - T[i] 2^m + T[i + m]) \mod p " /><a href="#fnref36">↩</a></p></li>
<li id="fn37"><p>Where <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> and <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=T%5B%5Cldots%5D" alt="T[\ldots]" title="T[\ldots]" /> are viewed as binary numbers<a href="#fnref37">↩</a></p></li>
<li id="fn38"><p>There exists a efficient algorithm for computing determinants.<a href="#fnref38">↩</a></p></li>
<li id="fn39"><p>Can compute modulo prime<a href="#fnref39">↩</a></p></li>
<li id="fn40"><p>There’s a theorem for equality that’s useful, but that type of test comes up in symbolic math programs<a href="#fnref40">↩</a></p></li>
<li id="fn41"><p>e.g. <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=f%28x_1%2C%20x_2%2C%20x_3%29%20%3D%20x_1%20x_2%5E3%20%2B%20x_3%5E2%20%2B%20x_1%20x_2" alt="f(x_1, x_2, x_3) = x_1 x_2^3 + x_3^2 + x_1 x_2" title="f(x_1, x_2, x_3) = x_1 x_2^3 + x_3^2 + x_1 x_2" /> has total degree <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=4" alt="4" title="4" />.<a href="#fnref41">↩</a></p></li>
<li id="fn42"><p>There are slight improvements since, notably Williams finding <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%28n%5E%7B2.3727%7D%29" alt="O(n^{2.3727})" title="O(n^{2.3727})" />.<a href="#fnref42">↩</a></p></li>
<li id="fn43"><p>By the previous part, this is a degree 1 (<img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d%3D1" alt="d=1" title="d=1" />) multivariate polynomial.<a href="#fnref43">↩</a></p></li>
<li id="fn44"><p>If there is no inequality bounding this, then the optimal solution occurs at <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cpm%20%5Cinfty" alt="\pm \infty" title="\pm \infty" />.<a href="#fnref44">↩</a></p></li>
<li id="fn45"><p>It’s important to note that the optimal solution may not be unique.<a href="#fnref45">↩</a></p></li>
<li id="fn46"><p>de Berg et al. used 3D linear programming to achieve this<a href="#fnref46">↩</a></p></li>
<li id="fn47"><p>Actually, this algorithm runs in <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=O%282%5E%7B2%5Ed%7D%20n%29" alt="O(2^{2^d} n)" title="O(2^{2^d} n)" />, but the “linear” growth of <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=n" alt="n" title="n" /> is the object<a href="#fnref47">↩</a></p></li>
<li id="fn48"><p>The idea of this kind of analysis is to consider the situation after an element has been added, and note that it is a random element among the set added so far.<a href="#fnref48">↩</a></p></li>
<li id="fn49"><p>That of course depends badly on <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=d" alt="d" title="d" />.<a href="#fnref49">↩</a></p></li>
<li id="fn50"><p>TODO: Why isn’t this guaranteed?<a href="#fnref50">↩</a></p></li>
<li id="fn51"><p>By concentrating on 2-SAT then broadening our scope to 3-SAT.<a href="#fnref51">↩</a></p></li>
<li id="fn52"><p>Analysis omitted from course slides.<a href="#fnref52">↩</a></p></li>
<li id="fn53"><p>If they aren’t, we only need to break ties consistently.<a href="#fnref53">↩</a></p></li>
<li id="fn54"><p>I have no clue what this means.<a href="#fnref54">↩</a></p></li>
<li id="fn55"><p>An incident edge to <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> is an edge between <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=v" alt="v" title="v" /> and another vertex.<a href="#fnref55">↩</a></p></li>
<li id="fn56"><p>In class, she alluded that this is complicated, and didn’t go any further. At the bottom of her notes though, there is a link to <a href="https://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15750-s01/www/notes/lect0208">A CMU grad course’s (link)</a> explanation of the matter.<a href="#fnref56">↩</a></p></li>
<li id="fn57"><p>Two edges are incident if they share a vertex.<a href="#fnref57">↩</a></p></li>
<li id="fn58"><p>This seems to be the only reference to Vazirani in her notes, but she mentions in class that he visited UWaterloo a while ago and showed her a misprint in the subtitle of an old version of his book.<a href="#fnref58">↩</a></p></li>
<li id="fn59"><p>A matching <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=M" alt="M" title="M" /> is a set of edges such that no two share a common vertex.<a href="#fnref59">↩</a></p></li>
<li id="fn60"><p>There is no proof given, and Chapter [cha:linear<sub>p</sub>rogramming] doesn’t deal with this type of problem.<a href="#fnref60">↩</a></p></li>
<li id="fn61"><p>That is, the number of edges cut.<a href="#fnref61">↩</a></p></li>
<li id="fn62"><p>As usual, <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=m" alt="m" title="m" /> is the number of edges.<a href="#fnref62">↩</a></p></li>
<li id="fn63"><p>To prove that it is <span><span style="font-variant: small-caps;">NP-complete</span></span>, we only need to reduce 3-<span style="font-variant: small-caps;">sat</span> to Max 2-<span style="font-variant: small-caps;">sat</span>, just turn <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28x%20%5Clor%20y%20%5Clor%20z%29" alt="(x \lor y \lor z)" title="(x \lor y \lor z)" /> into about 10 2-<span style="font-variant: small-caps;">sat</span> clauses such that <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28x%20%5Clor%20y%20%5Clor%20z%29" alt="(x \lor y \lor z)" title="(x \lor y \lor z)" /> is satisfied if about 7 of the 2-<span style="font-variant: small-caps;">sat</span> clauses are satisfied.<a href="#fnref63">↩</a></p></li>
<li id="fn64"><p>Not explained in class, but apparently there are many powerful consequences.<a href="#fnref64">↩</a></p></li>
<li id="fn65"><p>Yes, this is the same factor as Max-Cut, as denoted on page  [ssub:state<sub>o</sub>f<sub>t</sub>he<sub>a</sub>rt<sub>i</sub>n<sub>m</sub>ax<sub>c</sub>ut]<a href="#fnref65">↩</a></p></li>
<li id="fn66"><p>Discovered by Hochbaum &amp; Maas, `85.<a href="#fnref66">↩</a></p></li>
<li id="fn67"><p>I don’t know why she used <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=S" alt="S" title="S" />, given that it usually denotes a set. Oh well.<a href="#fnref67">↩</a></p></li>
<li id="fn68"><p>Being tight means that we’ve proved that it’s <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cle1.7" alt="\le1.7" title="\le1.7" />, and have infinitely many examples where the algorithm gives this ratio, effectively proving the approximation uses <img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=%3D%201.7%7B%5Ctextsc%7Bopt%7D%5Cxspace%7D%2B%201" alt="= 1.7{\textsc{opt}\xspace}+ 1" title="= 1.7{\textsc{opt}\xspace}+ 1" /> bins.<a href="#fnref68">↩</a></p></li>
<li id="fn69"><p>This can be proved by reducing subset sum to knapsack or partition.<a href="#fnref69">↩</a></p></li>
<li id="fn70"><p>Apparently they made some technical assumptions as well.<a href="#fnref70">↩</a></p></li>
<li id="fn71"><p><img style="vertical-align:middle" src="http://chart.apis.google.com/chart?cht=tx&amp;chl=P" alt="P" title="P" /> does not infer, but guesses randomly.<a href="#fnref71">↩</a></p></li>
<li id="fn72"><p>Apparently there are instances where more than one prover is necessary, but I can’t think of any.<a href="#fnref72">↩</a></p></li>
<li id="fn73"><p>Maybe any <span><span style="font-variant: small-caps;">NP-complete</span></span>?<a href="#fnref73">↩</a></p></li>
<li id="fn74"><p>Since 1988, the time is apparently nigh<a href="#fnref74">↩</a></p></li>
<li id="fn75"><p>Given a graph, is it 3-colorable is <span><span style="font-variant: small-caps;">NP-complete</span></span>, so we still run into that issue.<a href="#fnref75">↩</a></p></li>
<li id="fn76"><p>The algorithm is a Fixed-Parameter Tractable Algorithm (FPTA).<a href="#fnref76">↩</a></p></li>
<li id="fn77"><p>Apparently, this means 0 for planar graphs, and 1 for embeddable on a torus without crossing edges.<a href="#fnref77">↩</a></p></li>
<li id="fn78"><p>Don’t repeat vertexes.<a href="#fnref78">↩</a></p></li>
<li id="fn79"><p>of vertexes that share no edges<a href="#fnref79">↩</a></p></li>
<li id="fn80"><p>In this case, we use “expectations” that the input is “average”, which is not amortized analysis. Better analysis is below.<a href="#fnref80">↩</a></p></li>
<li id="fn81"><p>In CLRS, there is nice analysis without recurrence relations.<a href="#fnref81">↩</a></p></li>
</ol>
</section>
</body>
</html>
